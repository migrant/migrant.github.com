<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 翻译 | Migrant]]></title>
  <link href="http://migrant.github.io/blog/categories/fan-yi/atom.xml" rel="self"/>
  <link href="http://migrant.github.io/"/>
  <updated>2014-02-12T12:15:44+08:00</updated>
  <id>http://migrant.github.io/</id>
  <author>
    <name><![CDATA[Migrant]]></name>
    <email><![CDATA[tomigrant@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基础集合类]]></title>
    <link href="http://migrant.github.io/blog/2014/01/20/the-foundation-collection-classes/"/>
    <updated>2014-01-20T17:41:00+08:00</updated>
    <id>http://migrant.github.io/blog/2014/01/20/the-foundation-collection-classes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-7/collections.html">The Foundation Collection Classes</a>，转载请注明出处。</p>

<h2>NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个Mac/iOS应用的基本组成部分。在本文中，我们将对"老类"(<code>NSArray</code>, <code>NSSet</code>)和"新类"(<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>)进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示:本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行多个、复杂的测试。这些结果的目的是给出一个快速和主要的运行时统计。所有的测试基于iPhone 5s，使用Xcode 5.1b1和iOS 7.1b1，64位的程序。编译选项设置为-Ofast的发布构建。Vectorize loops和unroll loops(默认设置)均设置为关闭。</p>

<!--more-->


<h2>大O符号</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>描述。它定义了一个函数的 <em>极限特征</em> ，通常被用于描绘其算法效率。O定义了函数增长率的上限。通过查看通常使用的O符号和所需要的操作数来查看差异的大小。</p>

<p><img src="/images/posts/2014-01-20-the-foundation-collection-classes-01.png" alt="" /></p>

<p>例如，如果用算法复杂度为O(n<sup>2</sup>)的算法对一个有50个元素的数组排序，需要2500步的操作。而且，还有内部的系统开销和方法调用 &mdash; 所以是2500个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的算法通常需要O(n*log n)的时间</a>。</p>

<h2>可变性</h2>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性:就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么?<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种突变异常的风险。你的API <em>绝不</em> 应该暴露可变集合。</p>

<p>当然从不可变到可变再变回来会有一定的代价 &mdash; 对象必须被拷贝两次，所有集合内的对象将被retain/release。有时在内部使用一个可变的集合而在出口返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同，苹果没有提供一个线程安全的可变集合，<code>NSCache</code>是例外 &mdash; 但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你的确想要高于集合级别的同步。想象一段代码，作用是检查字典中一个key是否存在，并根据检查结果决定设置一个新的key或者返回某些值 &mdash; 你通常需要把多个操作归类，这时线程安全的可变变体并不能帮助你。</p>

<p>这里有一些同步的，线程安全的可变集合有效的使用案例，只需要用几行代码，通过子类和组合的方法建立诸如<a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a>或<a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些更新式的集合类，如<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，或者某个你想要不常见的可变类的场景。</p>

<h2>NSArray</h2>

<p><code>NSArray</code>作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的<code>[NSArray arrayWithObjects:..., nil]</code>简短得多的快速语法糖符号<code>@[...]</code>。</p>

<p><code>NSArray</code>实现了<code>objectAtIndexedSubscript:</code>，因为我们可以使用类C的语法<code>array[0]</code>来代替原来的<code>[array objectAtIndex:0]</code>。</p>

<h2>性能特征</h2>

<p>关于<code>NSArray</code>的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证O(1)的访问时间 &mdash; 正如你在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h">CFArray.h CoreFoundation header</a>中的关于算法复杂度的注解中可以读到的:</p>

<blockquote><p>The access time for a value in the array is guaranteed to be at worst O(lg N) for any implementation, current and future, but will often be O(1) (constant time). Linear search operations similarly have a worst case complexity of O(Nlg N), though typically the bounds will be tighter, and so on. Insertion or deletion operations will typically be linear in the number of values in the array, but may be O(Nlg N) clearly in the worst case in some implementations. There are no favored positions within the array for performance; that is, it is not necessarily faster to access values with low indices, or to insert or delete values with high indices, or whatever.</p></blockquote>

<p>在测量的时候，<code>NSArray</code>产生了一些<a href="http://ridiculousfish.com/blog/posts/array.html">有趣的额外的性能特征</a>。在数组的开头和结尾插入/删除元素通常是一个O(1)操作，而随机的插入/删除通常是 O(N)的。</p>

<h2>有用的方法</h2>

<p><code>NSArray</code>的大多数方法使用<code>isEqual:</code>来检查对象间的关系(例如<code>containsObject:</code>)。有一个特别的方法<code>indexOfObjectIdenticalTo:</code>用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。</p>

<p>在iOS 7中，我们最终得到了与<code>lastObject</code>对应的公开的<code>firstObject</code>方法，对于空数组，这两个方法都会返回<code>nil</code> &mdash; 而常规的访问方法会抛出一个<code>NSRangeException</code>异常。</p>

<p>关于构造(可变)数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为nil的数组创建一个可变数组，通常会这么写:</p>

<p>```objc
NSMutableArray *mutableObjects = [array mutableCopy];
if (!mutableObjects) {</p>

<pre><code>mutableObjects = [NSMutableArray array];
</code></pre>

<p>}
```</p>

<p>或者通过更简洁的<a href="http://en.wikipedia.org/wiki/%3F:">三元运算符</a>:</p>

<p><code>objc
NSMutableArray *mutableObjects = [array mutableCopy] ?: [NSMutableArray array];
</code></p>

<p>更好的解决方案是使用<code>arrayWithArray:</code>，即使原数组为nil，该方法也会返回一个数组对象:</p>

<p><code>objc
NSMutableArray *mutableObjects = [NSMutableArray arrayWithArray:array];
</code></p>

<p>这两个操作在效率上几乎相等。使用<code>copy</code>会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。<strong>提醒:</strong>不要使用<code>[@[] mutableCopy]</code>。经典的<code>[NSMutableArray array]</code>可读性更好。</p>

<p>翻转一个数组非常简单:<code>array.reverseObjectEnumerator.allObjects</code>。我们使用系统提供的<code>reverseObjectEnumerator</code>，每一个<code>NSEnumerator</code>都实现了<code>allObjects</code>，该方法返回一个新数组。虽然没有原生的<code>randomObjectEnumerator</code>方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用<a href="https://github.com/mattt/TTTRandomizedEnumerator/blob/master/TTTRandomizedEnumerator/TTTRandomizedEnumerator.m">一些出色的开源代码</a>。</p>

<h2>数组排序</h2>

<p>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，<code>sortedArrayUsingSelector:</code>是第一选择:</p>

<p><code>objc
NSArray *array = @[@"John Appleseed", @"Tim Cook", @"Hair Force One", @"Michael Jurewitz"];
NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
</code></p>

<p>下面的代码对存储数字的内容同样很好，因为<code>NSNumber</code>实现了<code>compare:</code>:</p>

<p><code>objc
NSArray *numbers = @[@9, @5, @11, @3, @1];
NSArray *sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)];
</code></p>

<p>如果想更可控，可以使用基于函数指针的排序方法:</p>

<p>```objc
&ndash; (NSData <em>)sortedArrayHint;
&ndash; (NSArray </em>)sortedArrayUsingFunction:(NSInteger (<em>)(id, id, void </em>))comparator</p>

<pre><code>                          context:(void *)context;
</code></pre>

<ul>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void <em>))comparator
                            context:(void </em>)context hint:(NSData *)hint;
```</li>
</ul>


<p>苹果增加了一个方法来加速使用<code>sortedArrayHint</code>的排序。</p>

<blockquote><p>The hinted sort is most efficient when you have a large array (N entries) that you sort once and then change only slightly (P additions and deletions, where P is much smaller than N). You can reuse the work you did in the original sort by conceptually doing a merge sort between the N “old” items and the P “new” items. To obtain an appropriate hint, you use sortedArrayHint when the original array has been sorted, and keep hold of it until you need it (when you want to re-sort the array after it has been modified).</p></blockquote>

<p>因为block的引入，也出现了一些基于block的排序方法:</p>

<p>```objc
&ndash; (NSArray <em>)sortedArrayUsingComparator:(NSComparator)cmptr;
&ndash; (NSArray </em>)sortedArrayWithOptions:(NSSortOptions)opts</p>

<pre><code>                usingComparator:(NSComparator)cmptr;
</code></pre>

<p>```</p>

<p>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于selector的方式是最快的。<a href="https://github.com/steipete/PSTFoundationBenchmark">你可以在GitHub上找到测试用的源代码</a>:</p>

<p><code>
Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].
</code></p>

<h2>二分查找</h2>

<p><code>NSArray</code>从iOS 4/Snow Leopard开始内置了<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a></p>

<p>```objc
typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) {</p>

<pre><code>    NSBinarySearchingFirstEqual     = (1UL &lt;&lt; 8),
    NSBinarySearchingLastEqual      = (1UL &lt;&lt; 9),
    NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),
</code></pre>

<p>};</p>

<ul>
<li>(NSUInteger)indexOfObject:(id)obj
            inSortedRange:(NSRange)r
                  options:(NSBinarySearchingOptions)opts
          usingComparator:(NSComparator)cmp;
```</li>
</ul>


<p>为什么要使用这个方法?类似<code>containsObject:</code>和<code>indexOfObject:</code>这样的方法从0索引开始搜索每个对象直到找到目标 &mdash; 不需要数组被排序而且是O(n)的效率特性。换句话说，二分查找需要数组事先被排序，但只需要O(log n)的时间。因此，对于1,000,000的记录，二分查找法最多只需要21次比较，而传统的线性查找则平均需要5000,000次的比较。</p>

<p>这是个简单的衡量二分查找有多快的数据:</p>

<p><code>
Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]
</code></p>

<p>作为比较，查找<code>NSOrderedSet</code>中的指定索引花费0.23毫秒 &mdash; 即使跟二分查找相比也快了30多倍。</p>

<p>记住排序的开销也是昂贵的。苹果使用复杂度为O(n*log n)的归并排序，所以如果执行过<code>indexOfObject:</code>一次，就没有必要使用二分查找了。</p>

<p>通过指定<code>NSBinarySearchingInsertionIndex</code>，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>

<h2>枚举和高阶消息</h2>

<p>作为参照，我们来看一个普通的使用场景。从一个数组中过滤出另一个数组。测试了多个枚举方法和API特性:</p>

<p><code>``objc
// First variant, using</code>indexesOfObjectsWithOptions:passingTest:`.
NSIndexSet *indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent</p>

<pre><code>                                               passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) {
return testObj(obj);
</code></pre>

<p>}];
NSArray *filteredArray = [randomArray objectsAtIndexes:indexes];</p>

<p>// Filtering using predicates (block-based or text)  <br/>
NSArray <em>filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary </em>bindings) {</p>

<pre><code>return testObj(obj);
</code></pre>

<p>}]];</p>

<p>// Block-based enumeration
NSMutableArray <em>mutableArray = [NSMutableArray array];
[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}];</p>

<p>// Classic enumeration
NSMutableArray *mutableArray = [NSMutableArray array];
for (id obj in randomArray) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}</p>

<p>// Using NSEnumerator, old school.
NSMutableArray <em>mutableArray = [NSMutableArray array];
NSEnumerator </em>enumerator = [randomArray objectEnumerator];
id obj = nil;
while ((obj = [enumerator nextObject]) != nil) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}</p>

<p>// Using objectAtIndex: (via subscripting)
NSMutableArray *mutableArray = [NSMutableArray array];
for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) {</p>

<pre><code>id obj = randomArray[idx];
if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}
```</p>

<!--
Enumeration Method / Time [ms]  | 10.000.000 elements | 10.000 elements
:------------------------------ | ------------------: | --------------:
`indexesOfObjects:`, concurrent |             1844.73 |            2.25
`NSFastEnumeration` (for in)    |             3223.45 |            3.21
`indexesOfObjects:`             |             4221.23 |            3.36
`enumerateObjectsUsingBlock:`    |             5459.43 |            5.43
`objectAtIndex:`                |             5282.67 |            5.53
`NSEnumerator`                  |             5566.92 |            5.75
`filteredArrayUsingPredicate:`  |             6466.95 |            6.31
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Enumeration Method / Time [ms]  </th>
<th align="right"> 10.000.000 elements </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>indexesOfObjects:</code>, concurrent </td>
<td align="right"> 1844.73             </td>
<td align="right">            2.25 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code> (for in)    </td>
<td align="right"> 3223.45             </td>
<td align="right">            3.21 </td>
</tr>
<tr>
<td align="left"> <code>indexesOfObjects:</code>              </td>
<td align="right">             4221.23 </td>
<td align="right">            3.36 </td>
</tr>
<tr>
<td align="left"> <code>enumerateObjectsUsingBlock:</code>    </td>
<td align="right">             5459.43 </td>
<td align="right">            5.43 </td>
</tr>
<tr>
<td align="left"> <code>objectAtIndex:</code>                </td>
<td align="right">             5282.67 </td>
<td align="right">            5.53 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumerator</code>                  </td>
<td align="right">             5566.92 </td>
<td align="right">            5.75 </td>
</tr>
<tr>
<td align="left"> <code>filteredArrayUsingPredicate:</code>  </td>
<td align="right">             6466.95 </td>
<td align="right">            6.31 </td>
</tr>
</tbody>
</table>


<p>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>

<p><code>indexesOfObjectsWithOptions:passingTest:</code>必须每次都执行一次block因此比传统的使用<code>NSFastEnumeration</code>技术的基于for循环的枚举要稍微低效一些。然后如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎2倍。iPhone 5s是双核的，所以这说得通。这里并没有体现出来的是<code>NSEnumerationConcurrent</code>只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至<code>NSEnumerationConcurrent</code>上额外的线程管理实际上会使结果变得更慢。</p>

<p>最大的输家是<code>filteredArrayUsingPredicate:</code>。<code>NSPredicate</code>需要在这里提及是因为，人们可以写出<a href="http://nshipster.com/nspredicate/">非常复杂的表达式</a>，尤其是用不基于block的变体。使用Core Data的用户应该会很熟悉。</p>

<p>为了比较的完整，我们也加入了<code>NSEnumerator</code>作为比较 &mdash; 虽然没有任何理由再使用它了。然而它竟出人意料的快(比基于<code>NSPredicate</code>的查找要快)，它的运行时消耗无疑比快速枚举更多 &mdash; 现在它只用于向后兼容。甚至没有优化过的<code>objectAtIndex:</code>都要更快些。</p>

<h2>NSFastEnumeration</h2>

<p>在OSX 10.5和iOS的最初版本中，苹果增加了<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html"><code>NSFastEnumeration</code></a>。在此之前，只有每次返回一个元素的<code>NSEnumeration</code>，每次迭代都有运行时开销。而快速枚举，苹果通过<code>countByEnumeratingWithState:objects:count:</code>返回一个数据块。该数据块被解析成<code>ids</code>类型的C数组。这就是更快的速度的原因;迭代一个C数组更快，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的<a href="https://developer.apple.com/library/ios/samplecode/FastEnumerationSample/Introduction/Intro.html">FastEnumerationSample</a>是一个不错的开始，还有一篇<a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash的文章</a>也很不错。</p>

<h2>应该用arrayWithCapacity:吗?</h2>

<p>初始化<code>NSArray</code>的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 &mdash; 测量的时间几乎相等，且在统计不确定性的范围内。有消息透漏说实际上苹果并没有使用这个特性。然而使用<code>arrayWithCapacity:</code>仍然有用，在文档不清晰的代码中，它可以帮助理解代码:</p>

<p><code>
Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].
</code></p>

<h2>子类化注意事项</h2>

<p>很少有理由去子类化基础集合类。大多数时候，使用CoreFoundation级别的类并且自定义回调函数定制自定义行为是更好的解决方案。</p>

<p>创建一个大小写不敏感的字典，一种方法是子类化<code>NSDictionary</code>并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一个不同的<code>CFDictionaryKeyCallBacks</code>集，你可以提供自定义的<code>hash</code>和<code>isEqual:</code>回调。你可以在<a href="https://gist.github.com/steipete/7739473">这里</a>找到一个例子。这种方法的优美之处(感谢<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridging</a>)在于它仍然是一个简单的字典，可以被任何使用<code>NSDictionary</code>作为参数的API接受。</p>

<p>子类作用的一个例子是有序字典的用例。.NET提供了一个<code>SortedDictionary</code>，Java有<code>TreeMap</code>，C++有<code>std::map</code>。虽然你 <em>可以</em> 使用C++的STL容器，但却无法使它自动的<code>retain/release</code>，这会使使用起来笨重的多。因为<code>NSDictionary</code>是一个<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">类簇</a>，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，<a href="https://github.com/nicklockwood/OrderedDictionary/blob/master/OrderedDictionary/OrderedDictionary.m">这里</a>有一个真实的有序字典的例子。</p>

<h2>NSDictionary</h2>

<p>一个字典存储任意的对象键值对。 由于历史原因，初始化方法使用相反的对象到值的方法，<code>[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]</code>，而新的快捷语法则从key开始，<code>@{key : value, ...}</code>。</p>

<p><code>NSDictionary</code>中的键是被拷贝的并且需要是恒定的。如果在一个键在被用于在字典中放入一个值后被改变，那么这个值可能就会变得无法获取了。一个有趣的细节，在<code>NSDictionary</code>中键是被拷贝的，而在使用一个toll-free桥接的<code>CFDictionary</code>时却只被retain。CoreFoundation类没有通用对象的拷贝方法，因此这时拷贝是不可能的(*)。这只适用于使用<code>CFDictionarySetValue()</code>的时候。如果通过<code>setObject:forKey</code>使用toll-free桥接的<code>CFDictionary</code>，苹果增加了额外处理逻辑来使键被拷贝。反过来这个结论则不成立 &mdash; 转换为<code>CFDictionary</code>的<code>NSDictionary</code>对象，对其使用<code>CFDictionarySetValue()</code>方法会调用回<code>setObject:forKey</code>并拷贝键。</p>

<p>(*)有一个现成的键的回调函数<code>kCFCopyStringDictionaryKeyCallBacks</code>会拷贝字符串，因为<code>CFStringCreateCopy()</code>会调用<code>[NSObject copy]</code>，我们可以使用这个回调来创建一个拷贝键的<code>CFDictionary</code>。</p>

<h2>性能特征</h2>

<p>苹果在定义计算复杂度时显得相当安静。关于它的唯一注释可以在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h"><code>CFDictionary</code>的头文件</a>中找到:</p>

<blockquote><p>The access time for a value in the dictionary is guaranteed to be at worst O(N) for any implementation, current and future, but will often be O(1) (constant time). Insertion or deletion operations will typically be constant time as well, but are O(N*N) in the worst case in some implementations. Access of values through a key is faster than accessing values directly (if there are any such operations). Dictionaries will tend to use significantly more memory than a array with the same number of values.</p></blockquote>

<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>

<h2>枚举和高阶消息</h2>

<p>过滤字典有几个不同的方法:</p>

<p>```objc
// Using keysOfEntriesWithOptions:passingTest:,optionally concurrent
NSSet *matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrent</p>

<pre><code>                                           passingTest:^BOOL(id key, id obj, BOOL *stop) 
</code></pre>

<p>{</p>

<pre><code>return testObj(obj);
</code></pre>

<p>}];
NSArray <em>keys = matchingKeys.allObjects;
NSArray </em>values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];
__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values</p>

<pre><code>                                                                    forKeys:keys];    
</code></pre>

<p>// Block-based enumeration.
NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];
[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL </em>stop) {</p>

<pre><code>if (testObj(obj)) {
    mutableDictionary[key] = obj;
}
</code></pre>

<p>}];</p>

<p>// NSFastEnumeration
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
for (id key in randomDict) {</p>

<pre><code>id obj = randomDict[key];
if (testObj(obj)) {
    mutableDictionary[key] = obj;
}
</code></pre>

<p>}</p>

<p> // NSEnumeration
 NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];
 NSEnumerator </em>enumerator = [randomDict keyEnumerator];
 id key = nil;
 while ((key = [enumerator nextObject]) != nil) {</p>

<pre><code>   id obj = randomDict[key];
   if (testObj(obj)) {
       mutableDictionary[key] = obj;
   }
</code></pre>

<p> }</p>

<p>// C-based array enumeration via getObjects:andKeys:
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
id <strong>unsafe_unretained objects[numberOfEntries];
id </strong>unsafe_unretained keys[numberOfEntries];
[randomDict getObjects:objects andKeys:keys];
for (int i = 0; i &lt; numberOfEntries; i++) {</p>

<pre><code>id obj = objects[i];
id key = keys[i];
if (testObj(obj)) {
   mutableDictionary[key] = obj;
}
</code></pre>

<p> }
```</p>

<!--
Filtering/Enumeration Method / Time [ms] | 50.000 elements | 1.000.000 elements
:--------------------------------------- | --------------: | -----------------:
`keysOfEntriesWithOptions:`, concurrent  |           16.65 |             425.24
`getObjects:andKeys:`                    |           30.33 |            798.49*
`keysOfEntriesWithOptions:`              |           30.59 |             856.93
`enumerateKeysAndObjectsUsingBlock:`     |           36.33 |             882.93
`NSFastEnumeration`                      |           41.20 |            1043.42
`NSEnumeration`                          |           42.21 |            1113.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Filtering/Enumeration Method / Time [ms] </th>
<th align="right"> 50.000 elements </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>, concurrent  </td>
<td align="right">           16.65 </td>
<td align="right">             425.24 </td>
</tr>
<tr>
<td align="left"> <code>getObjects:andKeys:</code>                    </td>
<td align="right">           30.33 </td>
<td align="right">            798.49* </td>
</tr>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>              </td>
<td align="right">           30.59 </td>
<td align="right">             856.93 </td>
</tr>
<tr>
<td align="left"> <code>enumerateKeysAndObjectsUsingBlock:</code>     </td>
<td align="right">           36.33 </td>
<td align="right">             882.93 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code>                      </td>
<td align="right">           41.20 </td>
<td align="right">            1043.42 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumeration</code>                          </td>
<td align="right">           42.21 </td>
<td align="right">            1113.08 </td>
</tr>
</tbody>
</table>


<p>(*)使用<code>getObjects:andKeys:</code>时需要注意。在上面的代码例子中，我们使用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">可变长度数组</a>的C99特性(通常，数组的数量需要是一个固定值)。在栈上分配了内存，虽然有限但是更方便一点。上面的代码在有数量较大的元素的时候会崩溃掉，所以使用基于<code>malloc/calloc</code>的分配(和<code>free</code>)以确保安全。</p>

<p>为什么这次<code>NSFastEnumeration</code>这么慢?迭代字典通常需要键和值;快速枚举只能枚举键，我们必须每次都自己获取值。使用基于block的<code>enumerateKeysAndObjectsUsingBlock:</code>更高效，因为值可以更高效的被提前获取。</p>

<p>这个测试的胜利者又是并发迭代<code>keysOfEntriesWithOptions:passingTest:</code>和<code>objectsForKeys:notFoundMarker:</code>。代码稍微多了一点，但是可以用category进行漂亮的封装。</p>

<h2>应该用dictionaryWithCapacity:吗?</h2>

<p>到现在你应该已经知道该如何测试了，简单的回答是<strong>不</strong>，<code>count</code>参数没有改变任何事情:</p>

<p><code>
Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].
</code></p>

<h2>排序</h2>

<p>关于字典排序没有太多可说的。你只能将键排序为一个新对象，因此你可以使用任何正规的<code>NSArray</code>的排序方法:</p>

<p>```objc
&ndash; (NSArray <em>)keysSortedByValueUsingSelector:(SEL)comparator;
&ndash; (NSArray </em>)keysSortedByValueUsingComparator:(NSComparator)cmptr;
&ndash; (NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts</p>

<pre><code>                      usingComparator:(NSComparator)cmptr;
</code></pre>

<p>```</p>

<h2>共享键</h2>

<p>从iOS 6和OS X 10.8开始，字典可以使用一个事先生成好的键集，使用<code>sharedKeySetForKeys:</code>从一个数组中创建键集，用<code>dictionaryWithSharedKeySet:</code>创建字典。共享键集会复用对象，以节省内存。根据<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-FoundationOlderNotes/">Foundation Release Notes</a>，<code>sharedKeySetForKeys:</code>中会计算一个最小最完美的哈希值，这个哈希值丢弃了字典查找过程中探索循环的需要，因此使键的访问更快。</p>

<p>这在JSON解析的时候是完美的使用场景，虽然在我们有限的测试中无法看到苹果在<code>NSJSONSerialization</code>中使用。(使用共享键集创建的字典是<code>NSSharedKeyDictionary</code>的子类;标准的字典是<code>__NSDictionaryI</code>/<code>__NSDictionaryM</code>，I/M表明可变性;toll-free桥接的字典是<code>_NSCFDictionary</code>类，既是可变也是不可变的。)</p>

<p><strong>有趣的细节</strong>:共享键字典<strong>始终是可变的</strong>，即使对它们执行了"copy"命令后。这个行为文档中并没有说明，但很容易被测试:</p>

<p><code>objc
id sharedKeySet = [NSDictionary sharedKeySetForKeys:@[@1, @2, @3]]; // returns NSSharedKeySet
NSMutableDictionary *test = [NSMutableDictionary dictionaryWithSharedKeySet:sharedKeySet];
test[@4] = @"First element (not in the shared key set, but will work as well)";
NSDictionary *immutable = [test copy];
NSParameterAssert(immutable == 1);
((NSMutableDictionary *)immutable)[@5] = @"Adding objects to an immutable collection should throw an exception.";
NSParameterAssert(immutable == 2);
</code></p>

<h2>NSSet</h2>

<p><code>NSSet</code>和它的可变变体<code>NSMutableSet</code>是无序对象集合。检查一个对象是否存在通常是一个O(1)的操作，使得比<code>NSArray</code>快很多。<code>NSSet</code>只在被使用的哈希方法平衡的情况下能高效的工作;如果所有的对象都在同一个哈希筐内，<code>NSSet</code>在查找对象是否存在时并不比<code>NSArray</code>快多少。</p>

<p><code>NSSet</code>还有变体<code>NSCountedSet</code>，non-toll-free计数变体<code>CFBag</code>/<code>CFMutableBag</code>。</p>

<p><code>NSSet</code>会retain它其中的对象，但是根据set的规定，对象应该是不可变的。添加一个对象到set中随后改变它会导致一些奇怪的问题并破坏set的状态。</p>

<p><code>NSSet</code>的方法比<code>NSArray</code>少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有<code>allObjects</code>，将对象转化为<code>NSArray</code>，<code>anyObject</code>则返回任意的对象，如果set为空，则返回nil。</p>

<h2>Set操作</h2>

<p><code>NSMutableSet</code>有几个很强大的方法，例如<code>intersectSet:</code>，<code>minusSet:</code>和<code>unionSet:</code>。</p>

<p><img src="/images/posts/2014-01-20-the-foundation-collection-classes-02.png" alt="" /></p>

<h2>应该用setWithCapacity:吗?</h2>

<p>我们再一次测试当创建set时给定容量大小是否会有显著的速度差异:</p>

<p><code>
Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].
</code></p>

<p>在统计不确定性的前提下，结果没有显著差异。有一份证据表明<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">至少在上一运行时版本中，有很多的性能上的影响</a>。</p>

<h2>NSSet性能特征</h2>

<p>苹果在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFSet.h">CFSet头文件</a>中没有提供任何关于算法复杂度的注释:</p>

<!--
Class / Time [ms]               | 1.000.000 elements
:------------------------------ | -----------------:
`NSMutableSet`, adding          |            2504.38
`NSMutableArray`, adding        |            1413.38
`NSMutableSet`, random access   |               4.40
`NSMutableArray`, random access |               7.95
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding          </td>
<td align="right">            2504.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">            1413.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access   </td>
<td align="right">               4.40 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">               7.95 </td>
</tr>
</tbody>
</table>


<p>这个检测非常符合我们的预期:<code>NSSet</code>在每一个被添加的对象上执行<code>hash</code>和<code>isEqual:</code>方法并管理一个哈希筐，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是<code>anyObject</code>。</p>

<p>这里没有必要包含<code>containsObject:</code>的测试，set要快几个数量级，毕竟这是它的特点。</p>

<h2>NSOrderedSet</h2>

<p><code>NSOrderedSet</code>在iOS 5和Mac OS X 10.7中第一次被引入，除了CoreData，几乎没有直接使用它的API。看上去它综合了<code>NSArray</code>和<code>NSSet</code>两者的好处，对象查找，对象唯一性，和快速随机访问。</p>

<p><code>NSOrderedSet</code>有着优秀的API方法，使得它可以很便利的与其他set或者有序set对象合作。合并，交集，差集，就像<code>NSSet</code>支持的那样。它有<code>NSArray</code>中的大多数排序方法，除了比较陈旧的基于函数的排序方法和二分查找。毕竟<code>containsObject:</code>非常快，所以没有必要再用二分查找了。</p>

<p><code>array</code>和<code>set</code>方法分别返回一个<code>NSArray</code>和<code>NSSet</code>，但是。这些对象表面上是对象，像不可变对象那样，在有序set被更新的时候，它们会更新自己。当你打算在多个线程上迭代这些对象并发生了突变异常的时候，了解这一点是有好处的。本质上，这些类使用的是<code>__NSOrderedSetSetProxy</code>和<code>__NSOrderedSetArrayProxy</code>。</p>

<p>附注:如果你想知道为什么<code>NSOrderedSet</code>不是<code>NSSet</code>的子类，<a href="http://nshipster.com/nsorderedset/">NSHipster上有一篇非常好的文章解释了可变/不可变类簇的缺点</a>。</p>

<h2>NSOrderedSet性能特征</h2>

<p>如果你看到这份测试，你会看到<code>NSOrderedSet</code>代价高昂，天下没有免费的午餐:</p>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMutableOrderedSet`, adding        |            3190.52
`NSMutableSet`, adding               |            2511.96
`NSMutableArray`, adding             |            1423.26
`NSMutableOrderedSet`, random access |              10.74
`NSMutableSet`, random access        |               4.47
`NSMutableArray`, random access      |               8.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, adding        </td>
<td align="right">            3190.52 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding               </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding             </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, random access </td>
<td align="right">              10.74 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access        </td>
<td align="right">               4.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access      </td>
<td align="right">               8.08 </td>
</tr>
</tbody>
</table>


<p>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>

<p><code>NSOrderedSet</code>比<code>NSSet</code>和<code>NSArray</code>占用更多的内存，因为它需要一起维护哈希值和索引。</p>

<h2>NSHashTable</h2>

<p><code>NSHashTable</code>效仿了<code>NSSet</code>，但在对象/内存处理时更加的灵活。可以通过自定义<code>CFSet</code>的回调获得<code>NSHashTable</code>的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除 &mdash; 一些手动添加到<code>NSSet</code>的时候非常恶心的事情。它是默认可变的 &mdash; 没有相应的不可变类。</p>

<p><code>NSHashTable</code>有ObjC和原始的C API，C API可以用来存储任意对象。苹果在10.5 Leopard系统中引入了这个类，但是直到最近的iOS 6中才被加入。足够有趣的是它们只移植了 ObjC API;更多强大的C API没有包括在iOS中。</p>

<p><code>NSHashTable</code>可以通过<code>initWithPointerFunctions:capacity:</code>进行大量的设置 &mdash; 我们只选取使用<code>hashTableWithOptions:</code>最普遍的使用场景。最有用的选项有它自己的方便的构造函数<code>weakObjectsHashTable</code>。</p>

<h2>NSPointerFunctions</h2>

<p>这些指针函数可以被用在<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>中，定义了对存储在这个集合中的对象的获取和保留行为。这里是最有用的选项。完整列表参见<code>NSPointerFunctions.h</code>。</p>

<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>

<p><code>NSPointerFunctionsStrongMemory</code>创建了一个retain/release对象的集合，非常像常规的<code>NSSet</code>或<code>NSArray</code>。</p>

<p><code>NSPointerFunctionsWeakMemory</code>使用等价的<code>__weak</code>来存储对象并自动移除被销毁的对象。</p>

<p><code>NSPointerFunctionsCopyIn</code>在对象被加入到集合前拷贝它们。</p>

<p><code>NSPointerFunctionsObjectPersonality</code>使用对象的<code>hash</code>和<code>isEqual:</code>(默认)。</p>

<p><code>NSPointerFunctionsObjectPointerPersonality</code>对于<code>isEqual:</code>和<code>hash</code>使用直接的指针比较。</p>

<h2>NSHashTable性能特征</h2>

<!--
Class / Time [ms]                 | 1.000.000 elements
:-------------------------------- | -----------------:
`NSHashTable`, adding             |            2511.96
`NSMutableSet`, adding            |            1423.26
`NSHashTable`, random access      |               3.13
`NSMutableSet`, random access     |               4.39
`NSHashTable`, containsObject     |               6.56
`NSMutableSet`, containsObject    |               6.77
`NSHashTable`, NSFastEnumeration  |              39.03
`NSMutableSet`, NSFastEnumeration |              30.43
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                 </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSHashTable</code>, adding             </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding            </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, random access      </td>
<td align="right">               3.13 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access     </td>
<td align="right">               4.39 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, containsObject     </td>
<td align="right">               6.56 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, containsObject    </td>
<td align="right">               6.77 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, NSFastEnumeration  </td>
<td align="right">              39.03 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, NSFastEnumeration </td>
<td align="right">              30.43 </td>
</tr>
</tbody>
</table>


<p>如果你只是需要<code>NSSet</code>的特性，请坚持使用<code>NSSet</code>。<code>NSHashTable</code>在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>

<h2>NSMapTable</h2>

<p><code>NSMapTable</code>和<code>NSHashTable</code>相似，但是效仿的是<code>NSDictionary</code>。因此，我们可以通过<code>mapTableWithKeyOptions:valueOptions:</code>分别控制键和值的对象获取/保留行为。存储弱引用是<code>NSMapTable</code>最有用的特性，这里有4个方便的构造函数:</p>

<ul>
<li><code>strongToStrongObjectsMapTable</code></li>
<li><code>weakToStrongObjectsMapTable</code></li>
<li><code>strongToWeakObjectsMapTable</code></li>
<li><code>weakToWeakObjectsMapTable</code></li>
</ul>


<p>注意，除了使用<code>NSPointerFunctionsCopyIn</code>，任何的默认行为都会retain(或弱引用)键对象而不会拷贝它，与<code>CFDictionary</code>的行为相同而与<code>NSDictionary</code>不同。当你需要一个字典，它的键没有实现<code>NSCopying</code>协议，比如<code>UIView</code>，的时候非常有用。</p>

<p>如果你好奇为什么苹果"忘记"为<code>NSMapTable</code>增加下标，你现在知道了。下标访问需要一个<code>id&lt;NSCopying&gt;</code>作为key，对<code>NSMapTable</code>来说这不是强制的。如果不通过一个非法的API协议或者移除<code>NSCopying</code>协议来削弱全局下标，是没有办法给它增加下标的。</p>

<p>你可以通过<code>dictionaryRepresentation</code>把内容转换为普通的<code>NSDictionary</code>。不像<code>NSOrderedSet</code>，这个方法返回一个常规的字典而不是一个代理。</p>

<h2>NSMapTable性能特征</h2>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMapTable`, adding                 |            2958.48
`NSMutableDictionary`, adding        |            2522.47
`NSMapTable`, random access          |              13.25
`NSMutableDictionary`, random access |               9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMapTable</code>, adding                 </td>
<td align="right">            2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding        </td>
<td align="right">            2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMapTable</code>, random access          </td>
<td align="right">              13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access </td>
<td align="right">               9.18 </td>
</tr>
</tbody>
</table>


<p><code>NSMapTable</code>只比<code>NSDictionary</code>略微慢一点。如果你需要一个不retain键的字典，放弃<code>CFDictionary</code>使用它吧。</p>

<h2>NSPointerArray</h2>

<p><code>NSPointerArray</code>类是一个稀疏数组，工作起来与<code>NSMutableArray</code>相似，但可以存储<code>NULL</code>值，并且<code>count</code>方法会反应这些空点。可以用<code>NSPointerFunctions</code>对其进行各种设置，也有应对常见的使用场景的快捷构造函数<code>strongObjectsPointerArray</code>和<code>weakObjectsPointerArray</code>。</p>

<p>在能使用<code>insertPointer:atIndex:</code>之前，我们需要通过直接设置<code>count</code>属性来申请空间，否则会产生一个异常。另一种选择是使用<code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>

<p>你可以通过<code>allObjects</code>将一个<code>NSPointerArray</code>转换成常规的<code>NSArray</code>。这时所有的<code>NULL</code>值会被去掉，只有真正存在的对象被加入到数组 &mdash; 因此数组的对象索引很有可能会跟指针数组的不同。注意:如果向指针数组中存入任何非对象的东西，试图执行<code>allObjects</code>都会造成<code>EXC_BAD_ACCESS</code>崩溃，因为它会一个一个的retain"对象"。</p>

<p>从调试的角度讲，<code>NSPointerArray</code>没有受到太多欢迎。<code>description</code>方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行<code>[pointerArray allObjects]</code>，当然，如果存在<code>NULL</code>的话会改变索引。</p>

<h2>NSPointerArray性能特征</h2>

<p>在性能方面，<code>NSPointerArray</code>真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用<code>NSNull</code>作为空标记的<code>NSMutableArray</code>和使用了<code>NSPointerFunctionsStrongMemory</code>设置的<code>NSPointerArray</code>(这样对象会被适当的retain)。在一个有10,000个元素的数组中，我们每隔十个插入一个字符串"Entry %d"。此测试包括了用<code>NSNull</code>作为<code>null</code>填充的<code>NSMutableArray</code>。对于<code>NSPointerArray</code>，我们使用<code>setCount:</code>来代替:</p>

<!--
Class / Time [ms]               | 10.000 elements
:------------------------------ | --------------:
`NSMutableArray`, adding        |         2958.48
`NSPointerArray`, adding        |         2522.47
`NSMutableArray`, random access |           13.25
`NSPointerArray`, random access |            9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">         2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, adding        </td>
<td align="right">         2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">           13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, random access </td>
<td align="right">            9.18 </td>
</tr>
</tbody>
</table>


<p>注意<code>NSPointerArray</code>需要的时间比<code>NSMutableArray</code>多了超过<strong>250x (!) </strong>。这非常奇怪和意外。跟踪内存比较困难，似乎<code>NSPointerArray</code>更高效，但是因为我们使用同一个<code>NSNull</code>标记空对象，所以除了指针不该有更多的消耗。</p>

<h2>NSCache</h2>

<p><code>NSCache</code>是一个非常奇怪的集合。在iOS 4/Snow Leopard中加入，默认为可变并且<strong>线程安全</strong>的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的"成本"清理自己。与<code>NSDictionary</code>相比，键是被retain而不是被拷贝的。</p>

<p><code>NSCache</code>的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样比被回收更快填满内存的大对象不是个好主意。(这是在<a href="http://pspdfkit.com/">PSPDFKit</a>中很多跟内存有关的crash的原因，在使用自定义的基于LRU的链表的缓存代码之前，我们起初使用<code>NSCache</code>存储事先渲染的图片。)</p>

<p><code>NSCache</code>可以设置撑自动回收实现了<code>NSDiscardableContent</code>协议的对象。实现该属性的一个比较流行的类是同时间加入的<code>NSPurgeableData</code>，但是<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">在OS X 10.9之前，是非线程安全的(没有信息表明这是否也影响到iOS或者是否在iOS 7中被修复了)</a>。</p>

<h2>NSCache性能</h2>

<p>那么<code>NSCache</code>如何承受<code>NSMutableDictionary</code>的考验?加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类(<a href="https://gist.github.com/steipete/5928916">PSPDFThreadSafeMutableDictionary</a>)，它通过<code>OSSpinLock</code>实现同步的访问。</p>

<!--
Class / Time [ms]                                 | 1.000.000 elements | iOS 7x64 Simulator | iPad Mini iOS 6
:------------------------------------------------ | -----------------: | -----------------: | --------------:
`NSMutableDictionary`, adding                     |             195.35 |              51.90 |          921.02
`PSPDFThreadSafeMutableDictionary`, adding        |             248.95 |              57.03 |         1043.79
`NSCache`, adding                                 |             557.68 |             395.92 |         1754.59
`NSMutableDictionary`, random access              |               6.82 |               2.31 |           23.70
`PSPDFThreadSafeMutableDictionary`, random access |               9.09 |               2.80 |           32.33
`NSCache`, random access                          |               9.01 |          **29.06** |           53.25
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                                 </th>
<th align="right"> 1.000.000 elements </th>
<th align="right"> iOS 7x64 Simulator </th>
<th align="right"> iPad Mini iOS 6 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding                     </td>
<td align="right">             195.35 </td>
<td align="right">              51.90 </td>
<td align="right">          921.02 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, adding        </td>
<td align="right">             248.95 </td>
<td align="right">              57.03 </td>
<td align="right">         1043.79 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, adding                                 </td>
<td align="right">             557.68 </td>
<td align="right">             395.92 </td>
<td align="right">         1754.59 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access              </td>
<td align="right">               6.82 </td>
<td align="right">               2.31 </td>
<td align="right">           23.70 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, random access </td>
<td align="right">               9.09 </td>
<td align="right">               2.80 </td>
<td align="right">           32.33 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, random access                          </td>
<td align="right">               9.01 </td>
<td align="right">          <strong>29.06</strong> </td>
<td align="right">           53.25 </td>
</tr>
</tbody>
</table>


<p><code>NSCache</code>表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为<code>NSCache</code>维持着一个可选的决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎10倍。无论对32或64位的系统都是。而且看起来已经在iOS 7中优化过并且受益于64位运行时环境。当在老的设备上测试时，使用<code>NSCache</code>的性能消耗尤为明显。</p>

<p>iOS 6(32 bit)和iOS 7(64 bit)的区别也很明显，因为64位运行时使用<a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">标签指针</a>，因此我们的<code>@(idx)</code>封装要更为高效。</p>

<h2>NSIndexSet</h2>

<p>有些使用场景下<code>NSIndexSet</code>(和它的可变变体，<code>NSMutableIndexSet</code>)真的非常出色，对它的使用贯穿在Foundation中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如set这个名字已经暗示的那样，每一个<code>NSUInteger</code>要么在索引set中要么不在。如果你需要存储任意唯一的整数，最好使用<code>NSArray</code>。</p>

<p>如何把一个整数数组转换伟<code>NSIndexSet</code>:</p>

<p>```objc
NSIndexSet <em>PSPDFIndexSetFromArray(NSArray </em>array) {</p>

<pre><code>NSMutableIndexSet *indexSet = [NSMutableIndexSet indexSet];
for (NSNumber *number in array) {
    [indexSet addIndex:[number unsignedIntegerValue]];
}
return [indexSet copy];
</code></pre>

<p>}
```</p>

<p>如果不使用block，从索引set中拿到所有的索引有点麻烦，<code>getIndexes:maxCount:inIndexRange:</code>是最快的方法，其次是使用<code>firstIndex</code>并迭代直到<code>indexGreaterThanIndex:</code>返回<code>NSNotFound</code>。随着block的到来，使用<code>NSIndexSet</code>工作变得方便的多:</p>

<p>```objc
NSArray <em>PSPDFArrayFromIndexSet(NSIndexSet </em>indexSet) {</p>

<pre><code>NSMutableArray *indexesArray = [NSMutableArray arrayWithCapacity:indexSet.count];
[indexSet enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
   [indexesArray addObject:@(idx)];
}];
return [indexesArray copy];
</code></pre>

<p>}
```</p>

<h2>NSIndexSet性能</h2>

<p>Core Foundation中没有和<code>NSIndexSet</code>相当的类，苹果也没有对性能做出任何承诺。<code>NSIndexSet</code>和<code>NSSet</code>之间的比较也相对的不公平，因为常规的set需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的<code>NSUintegers</code>，并且在两个循环中都会执行<code>unsignedIntegerValue</code>:</p>

<!--
Class / Time [ms]           | #1.000 | #10.000 | #1.000.000 | #10.000.000 | #1.000.000, iPad Mini
:-------------------------- | -----: | ------: | ---------: | ----------: | --------------------:
`NSIndexSet`, adding        |   0.28 |    4.58 |      98.60 |     9396.72 |                179.27
`NSSet`, adding             |   0.30 |    2.60 |       8.03 |       91.93 |                 37.43
`NSIndexSet`, random access |   0.10 |    1.00 |       3.51 |       58.67 |                 13.44
`NSSet`, random access      |   0.17 |    1.32 |       3.56 |       34.42 |                 18.60
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]           </th>
<th align="right"> #1.000 </th>
<th align="right"> #10.000 </th>
<th align="right"> #1.000.000 </th>
<th align="right"> #10.000.000 </th>
<th align="right"> #1.000.000, iPad Mini </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSIndexSet</code>, adding        </td>
<td align="right">   0.28 </td>
<td align="right">    4.58 </td>
<td align="right">      98.60 </td>
<td align="right">     9396.72 </td>
<td align="right">                179.27 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, adding             </td>
<td align="right">   0.30 </td>
<td align="right">    2.60 </td>
<td align="right">       8.03 </td>
<td align="right">       91.93 </td>
<td align="right">                 37.43 </td>
</tr>
<tr>
<td align="left"> <code>NSIndexSet</code>, random access </td>
<td align="right">   0.10 </td>
<td align="right">    1.00 </td>
<td align="right">       3.51 </td>
<td align="right">       58.67 </td>
<td align="right">                 13.44 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, random access      </td>
<td align="right">   0.17 </td>
<td align="right">    1.32 </td>
<td align="right">       3.56 </td>
<td align="right">       34.42 </td>
<td align="right">                 18.60 </td>
</tr>
</tbody>
</table>


<p>我们看到在一百万左右对象的时候，<code>NSIndexSet</code>开始变得比<code>NSSet</code>慢，但只是因为新的运行时和标签指针。在iOS 6上运行相同的测试表明，甚至在更高数量级实体的条件下，<code>NSIndexSet</code>更快。实际上，在大多数应用中，你不会添加太多的整数到索引set中。还有一点这里没有测试，就是<code>NSIndexSet</code>跟<code>NSSet</code>比无疑有更好的内存优化。</p>

<h2>结论</h2>

<p>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但是有用的类，尤其是<code>NSCountedSet</code>，<a href="http://nshipster.com/cfbag/">CFBag</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFTreeRef/Reference/reference.html">CFTree</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBitVectorRef/Reference/reference.html">CFBitVector</a>和<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBinaryHeapRef/Reference/reference.html">CFBinaryHeap</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Frame]]></title>
    <link href="http://migrant.github.io/blog/2013/12/04/understanding-frame/"/>
    <updated>2013-12-04T13:36:00+08:00</updated>
    <id>http://migrant.github.io/blog/2013/12/04/understanding-frame</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://macoscope.com/blog/understanding-frame/">Understanding Frame</a>，转载请注明出处。</p>

<p>Frame是布局的核心。每个开发者都使用frame定位和改变<code>UIView</code>和<code>CALayer</code>的大小。在本文中我将把焦点集中在<code>CALayer</code>上，因为它是<code>UIView</code>的底层实现，<code>view.frame</code>简单的返回了<code>view.layer.frame</code>。此外，我不会讨论<code>setFrame:</code>方法。虽然看起来范围十分有限，但实际上有许多有趣的事情在平凡又古老的<code>frame</code> getter方法中发生。</p>

<!--more-->


<h2>Frame依赖于什么</h2>

<p>众所周知，<code>frame</code>是一个派生属性，实际上它基于一些其他的属性。实际上在计算frame值的时候会参考4个(!)属性:<code>bounds</code>，<code>anchorPoint</code>，<code>transform</code>，和<code>position</code>。</p>

<p>我们从<code>bounds</code>开始。bounds很棘手，它混合了层的内部和外部。<code>bounds.size</code>定义了层本身的面积，声明了它所存在的区域。设置<code>masksToBounds</code>为<code>YES</code>会把所有子层超出bounds范围的部分裁掉。另一方面，<code>bounds</code>的<code>origin</code>属性并不影响层本身的布局；然而它会影响它内部的子层的布局方式。<code>bounds.origin</code>定义了层内部坐标系的原点。</p>

<p>这里有一个例子展示了<code>bounds.origin</code>如何工作。例如我们定义<code>bounds.origin</code>为<code>CGPointMake (20.0f, 30.0f)</code></p>

<p><img src="/images/posts/2013-12-04-understanding-frame-01.png" title="bounds.origin" alt="bounds.origin" /></p>

<p>如何定义本地坐标系？只要把层的左上角放到<code>bounds.origin</code>上就行了。</p>

<p><img src="/images/posts/2013-12-04-understanding-frame-02.png" title="bounds.origin" alt="bounds.origin" /></p>

<p><code>anchorPoint</code>是一个稍微有点不同的讨厌鬼。首先，它的值标准化为0.0-1.0的范围内。获得以"点"为单位的值需要用<code>bounds.size</code>乘以标准化的值。更重要的是，<code>anchorPoint</code>定义了应用变换的坐标系的原点。</p>

<p><img src="/images/posts/2013-12-04-understanding-frame-03.png" title="anchorPoint" alt="anchorPoint" /></p>

<p>变换具有相同<code>bounds</code>但有不同<code>anchorPoint</code>的层(蓝色)会有很大区别(灰色)。</p>

<p><code>position</code>是最简单的一个概念。它定义了经过<code>bounds.size</code>，<code>anchorPoint</code>和<code>transform</code>的混合后，添加到层中的最终位置。</p>

<h2>精度的快速讨论</h2>

<p>在写这篇博客的时候，我留意到有时我的计算结果和CoreAnimation返回的计算结果相比有所出入。有可能是我计算错误或者有精度问题。我理所当然的首先检查了精度问题。幸运的是我的直觉是正确的。<code>CGFloat</code>在32位架构上是一个<code>float</code>的类型定义(在64位架构上是<code>double</code>)，而似乎CoreAnimation并没有理会<code>CGFloat</code>的实际类型而在内部直接使用了<code>double</code>。</p>

<p>要证实这个猜测并不困难。使用<a href="http://www.hopperapp.com/">Hooper</a>工具检查<code>CALayer</code>的<code>frame</code>getter方法的执行内容，我发现了一个叫做<code>mat4_apply_to_rect</code>的函数。然后我在这里设置了一个符号断点，实际上也就是在<code>CA::Mat4Impl::mat4_apply_to_rect(double const*, double*)</code>和<code>CA::Mat4Impl::mat4_apply_to_rect(float const*, float*)</code>上分别设置了一个断点，以确定哪一个函数被执行。当在设备上运行代码的时候，断点停在了参数是<code>double</code>的函数中，即使使用的是32位ARM架构的iPhone。</p>

<p>在一些极端情况下，使用<code>float</code>和<code>double</code>的差异是显而易见的。然而因为我们的目标是对CoreAnimation进行逆向工程并得到完全相同的结果，所以我们也使用<code>double</code>。我们定义一些和CoreGraphics中相同的非常简单的结构体。</p>

<p>```objc
typedef struct MCSDoublePoint {
  double x, y;
} MCSDoublePoint;</p>

<p>typedef struct MCSDoubleSize {
  double width, height;
} MCSDoubleSize;</p>

<p>typedef struct MCSDoubleRect {
  MCSDoublePoint origin;
  MCSDoubleSize size;
} MCSDoubleRect;
```</p>

<p>值得注意的是在64位iOS设备上，我们精心构建的<code>struct</code>会变得多余，因为在该架构上，<code>CGPoint</code>，<code>CGSize</code>和<code>CGRect</code>本来就是用<code>doubles</code>的。</p>

<h2>变换</h2>

<p>在深入分析frame之前，我们先了解一下变换。虽然<code>CALayer</code>使用的是一个完整的4×4的矩阵模拟<code>CATransform3D</code>，但它对计算<code>frame</code>的目的真的没有影响。所以，我们把焦点集中在<code>CGAffineTransform</code>上，它可以用每个人都喜欢的<code>CATransform3DGetAffineTransform</code>方法从<code>CATransform3D</code>中简单获得。</p>

<p>让我们从点开始，使用仿射变换来变换点是入门级的袋鼠:</p>

<p><code>objc
MCSDoublePoint MCSDoublePointApplyTransform(MCSDoublePoint point, CGAffineTransform t)
{
  MCSDoublePoint p;
  p.x = (double)t.a * point.x + (double)t.c * point.y + t.tx;
  p.y = (double)t.b * point.x + (double)t.d * point.y + t.ty;
  return p;
}
</code></p>

<p>上面的代码实现基于<code>CGPointApplyAffineTransform</code>，从根本上来讲是一个3x3的变换矩阵乘一个三维向量。</p>

<p><img src="/images/posts/2013-12-04-understanding-frame-04.gif" title="equation" alt="equation" /></p>

<p>这个矩阵被<code>CGAffineTransform</code>的值填充，被乘的向量由点的x坐标，y坐标和<code>1.0</code>组成，让结果向量从矩阵中也得到转换过的元素。</p>

<p>通过点变换，我们很容易变换矩形。通过变换矩形的顶点并用直线连接它们创建一个平行四边形(通常可以是任意四边形)。
但这并不是<code>CGRectApplyAffineTransform</code>的如何工作的。这个函数接收一个<code>CGRect</code>参数并返回一个<code>CGRect</code>。正如头文件<code>CGAffineTransform.h</code>中的注释声明的:</p>

<blockquote><p>通常来说因为仿射变换并不保护矩形，这个函数返回一个最小的包括经过变换的<code>rect</code>的四个顶点的矩形。</p></blockquote>

<p>读过这个以后，使用double再现<code>CGRectApplyAffineTransform</code>变得相对直接:</p>

<p>```objc
MCSDoubleRect MCSDoubleRectApplyTransform(MCSDoubleRect rect, CGAffineTransform transform)
{
  double xMin = rect.origin.x;
  double xMax = rect.origin.x + rect.size.width;
  double yMin = rect.origin.y;
  double yMax = rect.origin.y + rect.size.height;</p>

<p>  MCSDoublePoint points[4] = {</p>

<pre><code>[0] = MCSDoublePointApplyTransform((MCSDoublePoint){xMin, yMin}, transform),
[1] = MCSDoublePointApplyTransform((MCSDoublePoint){xMin, yMax}, transform),
[2] = MCSDoublePointApplyTransform((MCSDoublePoint){xMax, yMin}, transform),
[3] = MCSDoublePointApplyTransform((MCSDoublePoint){xMax, yMax}, transform),
</code></pre>

<p>  };</p>

<p>  double newXMin =  INFINITY;
  double newXMax = -INFINITY;
  double newYMin =  INFINITY;
  double newYMax = -INFINITY;</p>

<p>  for (int i = 0; i &lt; 4; i++) {</p>

<pre><code>newXMax = MAX(newXMax, points[i].x);
newYMax = MAX(newYMax, points[i].y);
newXMin = MIN(newXMin, points[i].x);
newYMin = MIN(newYMin, points[i].y);
</code></pre>

<p>  }</p>

<p>  MCSDoubleRect result = {newXMin, newYMin, newXMax &ndash; newXMin, newYMax &ndash; newYMin};</p>

<p>  return result;
}
```</p>

<p>我们计算了四个顶点的坐标，变换它们并且得到<code>x</code>和<code>y</code>的极值。</p>

<h2>计算Frame</h2>

<p>我们通过努力了解了每一个影响frame的因素，现在，获得frame将会变得很有趣:</p>

<ul>
<li>定义一个面积为<code>bounds.size</code>的矩形</li>
</ul>


<p><img src="/images/posts/2013-12-04-understanding-frame-05.png" alt="" /></p>

<ul>
<li>计算该矩形内的<code>anchorPoint</code>位置</li>
</ul>


<p><img src="/images/posts/2013-12-04-understanding-frame-06.png" alt="" /></p>

<ul>
<li>将矩形放入坐标系内，<code>anchorPoint</code>作为坐标系的原点</li>
</ul>


<p><img src="/images/posts/2013-12-04-understanding-frame-07.png" alt="" /></p>

<ul>
<li>应用任何你实施的变换，保持一个"包含了经过转换的顶点的最小矩形"</li>
</ul>


<p><img src="/images/posts/2013-12-04-understanding-frame-08.png" alt="" /></p>

<ul>
<li>根据<code>position</code>移动<code>anchorPoint</code></li>
</ul>


<p><img src="/images/posts/2013-12-04-understanding-frame-09.png" alt="" /></p>

<ul>
<li>灰色的就是结果矩形</li>
</ul>


<p>实现这些操作的代码如下:</p>

<p>```objc
&ndash; (CGRect)frameWithBounds:(CGRect)bounds anchorPoint:(CGPoint)anchorPoint transform:(CATransform3D)transform position:(CGPoint)position
{
  MCSDoubleRect rect;</p>

<p>  rect.size.width = bounds.size.width;
  rect.size.height = bounds.size.height;
  rect.origin.x = (double)-bounds.size.width * anchorPoint.x;
  rect.origin.y = (double)-bounds.size.height * anchorPoint.y;</p>

<p>  rect = MCSDoubleRectApplyTransform(rect, CATransform3DGetAffineTransform(transform));</p>

<p>  rect.origin.x += position.x;
  rect.origin.y += position.y;</p>

<p>  return CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height);
}
```</p>

<p>虽然代码不多，但利用了我们讨论过的所有概念。</p>

<h2>这些如何映射到<code>UIView</code></h2>

<p>关于<code>frame</code>getter方法，<code>bounds</code>和<code>center</code>，<code>UIView</code>并没有做什么工作；它只是简单的各自调用它底层的CALayer的<code>frame</code>，<code>bounds</code>和<code>position</code>方法。</p>

<p>注意<code>center</code>到<code>position</code>的映射 &mdash; 改变底层<code>layer</code>的<code>anchorPoint</code>会使<code>center</code>不能正确的对应到层的"中心"或者层的边界矩形的"中点"。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS中创建静态库]]></title>
    <link href="http://migrant.github.io/blog/2013/11/30/creating-a-static-library-in-ios-tutorial/"/>
    <updated>2013-11-30T22:45:00+08:00</updated>
    <id>http://migrant.github.io/blog/2013/11/30/creating-a-static-library-in-ios-tutorial</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">Creating a Static Library in iOS Tutorial</a>，转载请注明出处。</p>

<p><img class="right" src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-00.jpg" title="Create a static library in iOS!" ></p>

<p>如果你作为iOS开发者已经有一段时间，可能会有一套属于自己的类和工具函数，它们在你的大多数项目中被重用。</p>

<p>重用代码的最简单方法是简单的 <em>拷贝/粘贴</em> 源文件。然而，这种方法很快就会成为维护时的噩梦。因为每个应用都有自己的一份代码副本，你很难在修复bug或者升级时保证所有副本的同步。</p>

<p>这就是静态库要拯救你的。一个静态库是若干个类，函数，定义和资源的包装，你可以将其打包并很容易的在项目之间共享。</p>

<p>在本教程中，你将用两种方法亲手创建你自己的通用静态库。</p>

<!--more-->


<p>为了获得最佳效果，你应该熟悉Objective-C和iOS编程。Core Image的相关知识并不是必须的，但是如果你对示例工程和滤镜代码如何工作感兴趣，了解它会有所帮助。</p>

<p>准备好以效率的名义减少，重用并再生你的代码!</p>

<h2>为什么使用静态库</h2>

<p>创建静态库可能出于以下几个理由:</p>

<ul>
<li>你想将一些你和你团队中的同事们经常使用的类打包并轻松的分享给周围其他人。</li>
<li>你想让一些通用代码处于自己的掌控之下，以便于修复和升级。</li>
<li>你想将库共享给其他人，但不想让他们看到你的源代码。</li>
<li>你想创建一个还在不断开发的库的快照版本。</li>
</ul>


<p>本教程假设你已经完成学习<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>，并对其中展示如何应用图片特效的代码得心应手。</p>

<p>将上述代码添加到一个静态库中，然后在一个应用的修改版本中使用这个静态库。我们会得到一个带有上面列表中全部好处的完全相同的应用。</p>

<h2>开始</h2>

<p>运行Xcode，选择<code>File\New\Project</code>，在<code>Choose a template</code> 对话框中选择<code>iOS\Framework &amp; Library\Cocoa Touch Static Library</code>,如下图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-01.png" title="New Lib" alt="New Lib" /></p>

<p>点击<code>Next</code>。在工程选项对话框中，输入<code>ImageFilters</code>作为产品名。再输入一个唯一的公司标识，确保<code>Use Automatic Reference Counting</code>被选中且<code>Include Unit Tests</code>未选中。如下图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-02.png" title="Lib Name" alt="Lib Name" /></p>

<p>点击<code>Next</code>。最后，选择你想保存工程的位置并点击<code>Create</code>。</p>

<p>Xcode已经准备好静态库工程，甚至已经为你添加了一个<code>ImageFilters</code>类。这就是你的滤镜代码将要存放的地方。</p>

<blockquote><p>注意: 你可以添加任意数量的类到静态库中或者从中删除原有的类。本教程中的代码都会写在开始就被创建好的<code>ImageFilters</code>类中。</p></blockquote>

<p>你的Xcode工程还是一片空白，现在我们添加一些代码进去!</p>

<h2>图片滤镜</h2>

<p>该库使用UIKit，为iOS设计，所以你要做的第一件事就是在头文件中导入UIKit。打开<code>ImageFilters.h</code>，在文件顶部添加以下代码:</p>

<p>```objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>```</p>

<p>接下来将以下声明部分的代码粘贴到<code>@interface ImageFilters : NSObject</code>下面</p>

<p>```objc
@property (nonatomic,readonly) UIImage *originalImage;</p>

<ul>
<li>(id)initWithImage:(UIImage *)image;</li>
<li>(UIImage *)grayScaleImage;</li>
<li>(UIImage *)oldImageWithIntensity:(CGFloat)level;
```</li>
</ul>


<p>这些头文件中的声明定义了类的公开接口。其他开发者(包括你自己)使用该库时，只需通过阅读该头文件就可以知道类名和暴露的方法。</p>

<p>现在增加实现。打开<code>ImageFilters.m</code>文件，粘贴以下代码到<code>#import "ImageFilters.h"</code>下面:</p>

<p>```objc
@interface ImageFilters()</p>

<p>@property (nonatomic,strong) CIContext  <em>context;
@property (nonatomic,strong) CIImage    </em>beginImage;</p>

<p>@end
```</p>

<p>上面的代码声明了一些内部使用的属性。它们不是公开的，所以使用该库的引用没有使用它们的入口。</p>

<p>最后，你需要实现方法。粘贴以下代码到<code>@implementation ImageFilters:</code>下面:</p>

<p>```objc
&ndash; (id)initWithImage:(UIImage *)image
{</p>

<pre><code>self = [super init];
if (self) {
    _originalImage  = image;
    _context        = [CIContext contextWithOptions:nil];
    _beginImage     = [[CIImage alloc] initWithImage:_originalImage];
}
return self;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage<em>)imageWithCIImage:(CIImage </em>)ciImage
{
  CGImageRef cgiImage = [self.context createCGImage:ciImage fromRect:ciImage.extent];
  UIImage *image = [UIImage imageWithCGImage:cgiImage];
  CGImageRelease(cgiImage);</p>

<p>  return image;
}</p></li>
<li><p>(UIImage *)grayScaleImage
{
  if( !self.originalImage)
      return nil;</p>

<p>  CIImage *grayScaleFilter = [CIFilter filterWithName:@&ldquo;CIColorControls&rdquo; keysAndValues:kCIInputImageKey, self.beginImage, @&ldquo;inputBrightness&rdquo;, [NSNumber numberWithFloat:0.0], @&ldquo;inputContrast&rdquo;, [NSNumber numberWithFloat:1.1], @&ldquo;inputSaturation&rdquo;, [NSNumber numberWithFloat:0.0], nil].outputImage;</p>

<p>  CIImage *output = [CIFilter filterWithName:@&ldquo;CIExposureAdjust&rdquo; keysAndValues:kCIInputImageKey, grayScaleFilter, @&ldquo;inputEV&rdquo;, [NSNumber numberWithFloat:0.7], nil].outputImage;</p>

<p>  UIImage *filteredImage = [self imageWithCIImage:output];
  return filteredImage;
}</p></li>
<li><p>(UIImage *)oldImageWithIntensity:(CGFloat)intensity
{
  if( !self.originalImage )
      return nil;</p>

<p>  CIFilter *sepia = [CIFilter filterWithName:@&ldquo;CISepiaTone&rdquo;];
  [sepia setValue:self.beginImage forKey:kCIInputImageKey];
  [sepia setValue:@(intensity) forKey:@&ldquo;inputIntensity&rdquo;];</p>

<p>  CIFilter *random = [CIFilter filterWithName:@&ldquo;CIRandomGenerator&rdquo;];</p>

<p>  CIFilter *lighten = [CIFilter filterWithName:@&ldquo;CIColorControls&rdquo;];
  [lighten setValue:random.outputImage forKey:kCIInputImageKey];
  [lighten setValue:@(1 &ndash; intensity) forKey:@&ldquo;inputBrightness&rdquo;];
  [lighten setValue:@0.0 forKey:@&ldquo;inputSaturation&rdquo;];</p>

<p>  CIImage *croppedImage = [lighten.outputImage imageByCroppingToRect:[self.beginImage extent]];</p>

<p>  CIFilter *composite = [CIFilter filterWithName:@&ldquo;CIHardLightBlendMode&rdquo;];
  [composite setValue:sepia.outputImage forKey:kCIInputImageKey];
  [composite setValue:croppedImage forKey:kCIInputBackgroundImageKey];</p>

<p>  CIFilter *vignette = [CIFilter filterWithName:@&ldquo;CIVignette&rdquo;];
  [vignette setValue:composite.outputImage forKey:kCIInputImageKey];
  [vignette setValue:@(intensity * 2) forKey:@&ldquo;inputIntensity&rdquo;];
  [vignette setValue:@(intensity * 30) forKey:@&ldquo;inputRadius&rdquo;];</p>

<p>  UIImage *filteredImage = [self imageWithCIImage:vignette.outputImage];</p>

<p>  return filteredImage;
}
```</p></li>
</ul>


<p>这段代码实现了初始化和图片滤镜功能。详细解释上述代码的功能已经超出了本教程的范围，你可以从<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>中了解到更多的关于 Core Image 和滤镜的知识。</p>

<p>到这里，你已经有了一个静态库，它有一个暴露了以下3个方法的公开类<code>ImageFilters</code>:</p>

<ul>
<li><code>initWithImage</code> : 初始化滤镜类</li>
<li><code>grayScaleImage</code> : 创建灰阶图片</li>
<li><code>oldImageWithIntensity</code> : 创建怀旧效果的图片</li>
</ul>


<p>现在构建并运行你的库。你会注意到Xcode的"Run"按钮只是执行了一次构建，而并不能真正的运行库去查看效果，因为并没有真正的应用。</p>

<p>静态库的后缀名是<code>.a</code>而并不是一个<code>.app</code>或者<code>.ipa</code>文件。可以在工程导航栏中的<code>Products</code>文件夹下找到生成的静态库。右键点击<code>libImageFilters.a</code>并在弹出菜单中选择<code>Show in Finder</code>。</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-03.png" title="Show in Finder" alt="Show in Finder" /></p>

<p>Xcode会在Finder中打开文件夹，你可以看到以下类似的结构:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-04.png" title="Lib Structure" alt="Lib Structure" /></p>

<p>离完成一个库产品还剩两件事:</p>

<ul>
<li><strong>Header files</strong> : 在<code>include</code>文件夹中可以找到库的所有公开头文件。在该示例中，只有一个公开类所以文件夹中只有一个<code>ImageFilters.h</code>文件。稍后你会在你的应用工程中用到这个头文件以便于Xcode在编译期识别暴露的类。</li>
<li><strong>Binary Libraty</strong> : Xcode生成的静态库是<code>ImageFilters.a</code>。想在应用中使用该库，你需要用该文件链接。</li>
</ul>


<p>这两个部分和你想在应用里包含一些新的框架时所需要做的事很相似，简单的导入框架头文件并建立链接。</p>

<p>库已经准备就绪，需要附加说明的是，默认情况下，库文件只会为当前的架构构建。如果你在模拟器下构建，那么库会包含对应i386架构的结果代码；如果在真机设备下构建，你将会得到对应ARM架构的代码。你可能需要构建两个版本的库，并且当从模拟器切换到设备的时候选择其中一个使用。</p>

<p>怎么办？</p>

<p>幸运的是，有一个更好的办法可以不建立多个配置或在工程中构建产品就可以支持多个平台。你可以创建一个对应 <em>2个</em> 架构的包含结果代码的<code>universal binary</code>。</p>

<h2>通用二进制</h2>

<p>通用二进制是一种特殊的二进制文件，它包含对应多个架构的结果代码。你可能在从PowerPC(PPC)到Inter(i386)的Mac电脑产品线的过渡中对其有所熟悉。在这个过程中，Mac应用程序通常迁移为包含 <em>2个</em> 可执行包的一个二进制文件，这样应用程序即能在Inter也能在PowerPC的Mac电脑上运行。</p>

<p>同时支持ARM和i386的概念并没有太大不同。在这里静态库要包含支持iOS设备(ARM)和模拟器(i386)的结果代码。Xcode可以识别通用库，每次你构建应用的时候，它会根据目标选择适当的架构。</p>

<p>为了创建通用二进制库，需要使用一个名为<a href="https://developer.apple.com/library/mac/documentation/darwin/reference/manpages/man1/lipo.1.html">lipo</a>的系统工具。</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-05.jpg" title="Lipo Cat" alt="Lipo Cat" /></p>

<p>别担心宝贝，不是那种lipo! :] (lipo有脂肪的意思 &mdash; 译者注)</p>

<p><strong>lipo</strong>是一个命令行工具，它允许在通用文件上执行操作(类似于创建通用二进制, 列出通用文件内容等等)。本教程中使用<strong>lipo</strong>的目的是联合不同架构的二进制文件到单个输出文件中。你可以直接在命令行中使用<strong>lipo</strong>命令，但在本教程中你可以让Xcode执行一段创建通用库的命令行脚本来为你做这件事。</p>

<p>Xcode中一个集合目标可以一次构建多个目标，包括命令行脚本。在Xcode菜单中选择<code>File/New/Target</code>，选择<code>iOS/Other</code>并点击<code>Aggregate</code>，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-06.png" title="Aggregate Target" alt="Aggregate Target" /></p>

<p>将目标命名为<code>UniversalLib</code>，确保选中<code>ImageFilters</code>工程，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-07.png" title="Aggregate Universal" alt="Aggregate Universal" /></p>

<p>在工程导航视图中选中<code>ImageFilters</code>，然后选择<code>UniversalLib</code>目标。切换到<code>Build Phases</code>标签；在这里设置构建目标时将要执行的动作。</p>

<p>点击<code>Add Build Phase</code>按钮，在弹出的菜单中选择<code>Add Run Script</code>，如下图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-08.png" title="Aggregate Phase" alt="Aggregate Phase" /></p>

<p>现在你需要设置脚本项。展开<code>Run Script</code>模块，在<code>Shell</code>行下粘贴如下代码:</p>

<p>```sh</p>

<h1>define output folder environment variable</h1>

<p>UNIVERSAL_OUTPUTFOLDER=${BUILD_DIR}/${CONFIGURATION}-universal</p>

<h1>Step 1. Build Device and Simulator versions</h1>

<p>xcodebuild -target ImageFilters ONLY_ACTIVE_ARCH=NO -configuration ${CONFIGURATION} -sdk iphoneos  BUILD_DIR=&ldquo;${BUILD_DIR}&rdquo; BUILD_ROOT=&ldquo;${BUILD_ROOT}&rdquo;
xcodebuild -target ImageFilters -configuration ${CONFIGURATION} -sdk iphonesimulator -arch i386 BUILD_DIR=&ldquo;${BUILD_DIR}&rdquo; BUILD_ROOT=&ldquo;${BUILD_ROOT}&rdquo;</p>

<h1>make sure the output directory exists</h1>

<p>mkdir -p &ldquo;${UNIVERSAL_OUTPUTFOLDER}&rdquo;</p>

<h1>Step 2. Create universal binary file using lipo</h1>

<p>lipo -create -output &ldquo;${UNIVERSAL_OUTPUTFOLDER}/lib${PROJECT_NAME}.a&rdquo; &ldquo;${BUILD_DIR}/${CONFIGURATION}-iphoneos/lib${PROJECT_NAME}.a&rdquo; &ldquo;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/lib${PROJECT_NAME}.a&rdquo;</p>

<h1>Last touch. copy the header files. Just for convenience</h1>

<p>cp -R &ldquo;${BUILD_DIR}/${CONFIGURATION}-iphoneos/include&rdquo; &ldquo;${UNIVERSAL_OUTPUTFOLDER}/&rdquo;
```</p>

<p>代码并不十分复杂，它是这样工作的:</p>

<ul>
<li><strong>UNIVERSAL_OUTPUTFOLDER</strong> 包括了通用二进制包将要被存放的文件夹:&ldquo;Debug-universal&rdquo;</li>
<li><strong>Step 1.</strong> 第2行执行了<code>xcodebuild</code>并命令它构建ARM架构的二进制文件。(你可以看到这行中的<code>-sdk iphoneos</code>参数)</li>
<li>下一行再次执行了<code>xcodebuild</code>命令并在另一个文件夹中构建了一个针对Inter架构的iPhone模拟器的二进制文件，在这里关键参数是<code>-sdk iphonesimulator -arch i386</code>。(如果感兴趣，你可以在<a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html">man page</a>了解更多关于xcodebuild的资料)</li>
<li><strong>Step 2.</strong> 现在已经有了2个.a文件分别对应两个架构。执行<code>lipo -create</code>，用它们创建出一个通用二进制。</li>
<li>最后一行的作用是复制头文件到通用构建文件夹的外层。(用<code>cp</code>命令)</li>
</ul>


<p>你的Run Script窗口应该看起来如下:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-09.png" title="Aggregate Script" alt="Aggregate Script" /></p>

<p>现在你已经准备好构建一个静态库的通用版本。在方案下啦菜单中选择集合目标<code>UniversalLib</code>，如下(不像截图上的"iOS Device"，你看到的可能是自己的设备名字):</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-10.png" title="Aggregate Scheme" alt="Aggregate Scheme" /></p>

<p>点击<code>Play</code>按钮来为集合方案构建目标。</p>

<p>在<code>libImageFilters.a</code>上再次选择<code>Show in Finder</code>查看结果。将Finder切换到列视图查看文件夹层次，可以看到一个包含库的通用版本的叫做<code>Debug-Universal</code>的新文件夹(或<code>Release-Universal</code>如果你构建了发布版本)，如下图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-11.png" title="St Finder" alt="St Finder" /></p>

<p>除了这个链接到模拟器和真实设备的二进制文件，你还可以找到普通的头文件和静态库文件。</p>

<p>这是你创建自己的通用静态库所需要学习的所有知识。</p>

<p>概括起来，一个静态库工程和一个应用工程非常相似。可以拥有一个或多个类，最后的产品是头文件和一个.a文件。这个.a文件就是可以链接到多个应用程序中的静态库。</p>

<h2>在应用中使用静态库</h2>

<p>在应用中使用<code>ImageFilters</code>类和直接使用源代码并没有太大区别:导入头文件然后开始使用类。问题是Xcode并不知道头文件和库文件的位置。</p>

<p>有两种办法可以将静态库引入到工程中:</p>

<ul>
<li><strong>方法 1:</strong> 直接引用头文件和库二进制文件(.a)</li>
<li><strong>方法 2:</strong> 将库工程作为子项目</li>
</ul>


<p>选择哪一种方法完全取决于你的喜好或者是否有静态库的源代码和工程配置文件任由你支配。</p>

<p>本教程将分别介绍两种方法。你可以自由尝试第一个或第二个，但推荐按照文中介绍的顺序分别尝试两个。在两个部分的开头，需要一个zip文件，该文件是在<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>中创建的应用的修改版本，修改后的版本使用了库中新的<code>ImageFilters</code>类。</p>

<p>本教程的主要目的是教你如何使用静态库，所以修改后的工程包括了所有应用需要的源代码。这样你就可以将注意力集中在使用库所需要的工程设置上。</p>

<h2>方法 1: 头文件和库二进制文件</h2>

<p>在本节中，你需要下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/CoreImageFun.staticlib.zip">starter project for this section</a>。复制压缩文件到硬盘上的任意文件夹并解压。可以看到如下的文件夹结构:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-12.png" title="Lib File Tree" alt="Lib File Tree" /></p>

<p>为了方便起见，.a通用库文件和头文件已经复制了一份在其中，但工程并未设置使用它们。你将从这里开始。</p>

<blockquote><p>注意: 标准的Unix引入惯例是一个<code>include</code>文件夹，用来存放头文件，一个<code>lib</code>文件夹用来存放库文件(.a)。这种文件夹结构这是一种惯例，并不强制。你并不需要一定遵从这种结构或者复制文件到工程文件夹中。在你自己的应用中，你可以任意选择头文件和库文件的位置，只要随后在Xcode工程中设置了适当的路径。</p></blockquote>

<p>打开工程，构建并运行你的应用，将会看到以下错误:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-13.png" title="Lib Error Include" alt="Lib Error Include" /></p>

<p>正如所期望的那样，应用并不知道去哪里寻找头文件。为了解决这个问题，你需要在工程中添加一个<code>Header Search Path</code>，指明头文件存放的位置。设置头文件搜索路径始终是使用静态库的第一步。</p>

<p>按照下图示范，在导航栏中点击工程根节点(1)，选择<code>CoreImageFun</code>目标(2)。选择<code>Build Settings</code>(3)，在列表中找出<code>Header Search Paths</code>设置项。如果必要，可以在搜索框中输入"header search"来过滤庞大的设置列表(4)。</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-14.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>双击<code>Header Search Paths</code>项，弹出一个浮动窗口，点击<code>+</code>按钮，输入:</p>

<p><code>
$SOURCE_ROOT/include
</code></p>

<p>弹出窗口应该如下所示:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-15.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p><strong>$SOURCE_ROOT</strong>是一个Xcode环境变量，指向工程根文件夹。Xcode会使用包含你工程的实际文件夹代替此变量，这意味着即使你把工程移动到其它文件夹或驱动器，它仍然可以指向最新的位置。</p>

<p>在弹出窗口范围外点击鼠标使其消失，你会看到Xcode已经自动将变量转换为工程的实际位置，如图所示:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-16.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>构建并运行应用，看看结果是什么。呃……一些链接错误出现了:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-17.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>这看起来并不是很好，但是给了你另一个你所需要的信息。仔细看，会发现所有的编译错误全都消失了，全部被链接错误所代替。这表示Xcode找到了头文件并且用它去编译应用，但在链接阶段，Xcode无法找到<code>ImageFilter</code>类的结果代码。为什么？</p>

<p>很简单 &mdash; 你还没有告诉Xcode去哪里寻找包含类实现的库文件。(看，没什么大不了)</p>

<p>如下面的屏幕截图所示，回到<code>CoreImageFun</code>目标(2)的构建设置(1)。选择<code>Build Phases</code>标签(3)，展开<code>Link Binary With Libraries</code>部分(4)。最后，点击<code>+</code>按钮(5)。</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-18.png" title="Lib Link" alt="Lib Link" /></p>

<p>在出现的窗口中，点击<code>Add Other…</code>按钮，在工程根文件夹下的<code>lib</code>子目录中找到<code>libImageFilters.a</code>库文件，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-19.png" title="Lib Link" alt="Lib Link" /></p>

<p>完成这些以后，你的Build Phase标签看起来如下:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-20.png" title="Lib Link" alt="Lib Link" /></p>

<p>最后一步是增加<code>-ObjC</code>链接标识。该链接尝试更高效的只包含需要的代码，而有时会排除静态库代码。使用该标识，库中的所有Objective-C类和类别都将被适当的加载。你可以从苹果的<a href="http://developer.apple.com/library/mac/#qa/qa1490/_index.html">Technical Q&amp;A QA1490</a>了解详细信息。</p>

<p>点击<code>Build Settings</code>标签，找到<code>Other linker Flags</code>设置，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-21.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>在弹出窗口中，点击<code>+</code>按钮并输入<code>-ObjC</code>，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-22.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>最后构建并运行应用，此时应该不会得到任何构建错误信息，应用顺利展示它的光彩之处:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-23.png" title="App" alt="App" /></p>

<p>拖动滑块改变滤镜级别，或者点击GrayScale按钮。对图片应用滤镜的代码来自于静态库，而不是应用。</p>

<p>恭喜 &mdash; 你已经构建了你的第一个静态库并在一个真正的应用里使用它!你会发现这种包含头文件和库的方法在很多第三方库中使用，如AdMob，TestFlight或一些不提供源代码的商业库。</p>

<h2>方法 2: 子项目</h2>

<p>在这部分，请在<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2013/07/CoreImageFun.subproject.zip">这里</a>下载所需工程。</p>

<p>复制下载的文件到任意位置，解压。可以看到以下文件夹结构:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-24.png" title="Subproject Structure" alt="Subproject Structure" /></p>

<p>如果学习了方法一，你可能注意到了工程的差异。这个工程里没有任何的头文件和静态库文件 &mdash; 因为根本不需要。作为替代方案，你要将你在本教程开始创建的<code>ImageFilters</code>库工程添作为依赖加到本工程中。</p>

<p>在做这些之前，构建并运行应用。会看到以下错误:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-25.png" title="Lib Error Include" alt="Lib Error Include" /></p>

<p>如果学习过上一个方法，你已经知道如何修复这个问题。在示例工程中，你在<code>ViewController</code>类中使用了<code>ImageFilters</code>类，但并未告诉Xcode去哪里寻找头文件。Xcode会尝试寻找<code>ImageFilters.h</code>文件，但是失败了。</p>

<p>将<code>ImageFilters</code>库工程作为子项目所需的所有操作就是拖拽库工程文件到库文件树中。如果该工程已经在另一个Xcode窗口中被打开，那么Xcode无法正确将其添加为子工程。所以在继续本教程之前，确保<code>ImageFilters</code>库工程已经被关闭。</p>

<p>在Finder中找到名为<code>ImageFilters.xcodeproj</code>库工程文件。拖拽它到<code>CoreImageFun</code>工程左侧的导航栏中，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-26.png" title="Subproject Drag" alt="Subproject Drag" /></p>

<p>完成拖放后，你的工程浏览视图应该如下图所示:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-27.png" title="Subproject Drag" alt="Subproject Drag" /></p>

<p>现在Xcode已经识别了子工程，你可以将库添加为工程依赖。这样Xcode就可以在构建主应用之前确保库为最新版本。</p>

<p>点击工程文件(1)，选择<code>CoreImageFun</code>目标(2)。点击<code>Build Phases</code>标签(3)并展开<code>Target Dependencies</code>(4)，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-28.png" title="Dependencies" alt="Dependencies" /></p>

<p>点击<code>+</code>按钮增加一个新依赖。如下图所示，确保你从弹出窗口中选择了<code>ImageFilters</code>目标(不是<code>universalLib</code>):</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-29.png" title="Dependency" alt="Dependency" /></p>

<p>添加完成之后，依赖窗口应该如图所示:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-30.png" title="Dependency" alt="Dependency" /></p>

<p>最后，设置静态库工程链接到应用。展开<code>Link Binary with libraries</code>，点击<code>+</code>按钮，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-31.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>选择<code>libImageFilters.a</code>，点击<code>Add</code>:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-32.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>添加库之后，<code>Link Binary with Libraries</code>部分应该如图所示:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-33.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>像方法一那样，最后一步是增加<code>-ObjC</code>链接标识。点击<code>Build Settings</code>标签，找到<code>Other linker Flags</code>设置，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-34.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>在弹出窗口中，点击<code>+</code>按钮并输入<code>-ObjC</code>，如图:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-35.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>构建并运行应用，应该没有任何错误，应用会再一次被打开:</p>

<p><img src="/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-36.png" title="App" alt="App" /></p>

<p>拖动滑块或者点击GrayScale按钮查看图片滤镜结果。滤镜逻辑的代码完全包含在库中。</p>

<p>如果按照第一种方法在应用中添加库(使用头文件和库文件)，你可能注意到和第二种方法的区别。在方法二中，你没有在工程设置中添加任何头文件搜索路径。另一个区别是你没有使用通用库。</p>

<p>为什么会有这样的区别？当添加一个库作为一个子工程，Xcode会为你考虑几乎所有的事情。添加子工程和依赖后，Xcode知道去哪里寻找头文件和二进制文件，也知道根据你的设置去选择哪需要构建哪一个架构的库。这非常方便。</p>

<p>如果你使用你自己的库或者拥有源代码和工程文件，将库作为子工程不失为一个引入静态库的简便的方法。让你更容易作为工程依赖构建整合，并担心更少的事情。</p>

<h2>未来</h2>

<p>你可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/07/Staticlibrary.fullsource.zip">这里</a>下载到包括了本教程所有代码的工程。</p>

<p>希望本教程能够让你对静态库的基本概念和怎样在应用中使用它们有一个更深入的了解。</p>

<p>下一步就是用所学到的知识构建你自己的库了。你肯定有一些添加到工程中通用类。它们是你加入你自己的可复用库的优秀候选人。你也可以考虑根据功能创建多个库:网络部分的代码作为一个，UI部分作为另一个，等等。你可以只向工程中添加所需要的代码。</p>

<p>为了强化和深入探讨你在本教程中所学到的概念，我推荐苹果的文档<a href="http://developer.apple.com/library/ios/#technotes/iOSStaticLibraries/Introduction.html">Introduction to Using Static Libraries in iOS</a>。</p>

<p>希望你喜欢本教程，如果你有任何问题或评论，请在下面的讨论区中讨论。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 翻译 | Migrant]]></title>
  <link href="http://objcio.com/blog/categories/fan-yi/atom.xml" rel="self"/>
  <link href="http://objcio.com/"/>
  <updated>2015-01-06T13:28:42+08:00</updated>
  <id>http://objcio.com/</id>
  <author>
    <name><![CDATA[Migrant]]></name>
    <email><![CDATA[tomigrant@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DTrace]]></title>
    <link href="http://objcio.com/blog/2015/01/06/dtrace/"/>
    <updated>2015-01-06T12:10:00+08:00</updated>
    <id>http://objcio.com/blog/2015/01/06/dtrace</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-19/dtrace.html">DTrace</a>，感谢 <a href="http://onevcat.com/">onevcat</a> 校对，转载请注明出处。本文亦被收录于 <a href="http://objccn.io/">objc中国</a>。</p>

<p>很少有人听过 DTrace，它是隐藏在 OS 中的小宝藏。DTrace 是强大的 debug 工具 &ndash; 因为它拥有极其灵活的特性，并且因为与其它工具差异很大而可能相对不那么有名。</p>

<p>许多时候你的 app 的真正的用户或测试人员会看到一些意外的行为。DTrace 可以让你无需重启 app 就能够在生产版本上回答关于 app 的任何问题。</p>

<!--more-->


<h2>动态追踪</h2>

<p>大概 10 年前，<a href="https://en.wikipedia.org/wiki/Sun_Microsystems">Sun Microsystems</a> 创建了 DTrace，它的名字是 <em>Dynamic Trace</em> 的缩写。2007 年底，苹果公司将它集成在自己的 <a href="https://en.wikipedia.org/wiki/Mac_OS_X_Leopard">操作系统</a> 中。</p>

<p>DTrace 是一个提供了 <em>zero disable cost</em> 的动态追踪框架，也就是说当代码中的探针关闭时，不会有额外的资源消耗 &ndash; 即使在生产版本中我们也可以将探针留在代码中。只有使用的时候才产生消耗。</p>

<p>DTrace 是<strong>动态的</strong>，也就是说我们可以将它附加在一个已经在运行的程序上，也可以不打断程序将它剥离。不需要重新编译或启动。</p>

<p>本文我们将重点介绍如何使用 DTrace 检查我们的程序，但值得注意的是 DTrace 是系统级的: 例如，一个单独的脚本可以观察到系统中<strong>所有</strong>进程的内存分配操作。可以查看 <code>/usr/share/examples/DTTk</code> 来深入了解一些非常好的例子。</p>

<h3>OS X vs. iOS</h3>

<p>正如你现在可能已经猜到的，DTrace 只能在 OS X 上运行。苹果也在 iOS 上使用 DTrace，用以支持像 Instruments 这样的工具，但对于第三方开发者，DTrace 只能运行于 OS X 或 iOS 模拟器。</p>

<p>在 <a href="https://www.wire.com">Wire</a>，即使我们被限制仅能在 iOS 模拟器上使用 DTrace，它也在 iOS 开发中非常有用。如果你读到本文并且认为在 iOS 设备上支持 DTrace 是个好提议，请提交 <a href="https://bugreport.apple.com/">enhancement request</a> 给苹果。</p>

<h3>探针和脚本</h3>

<p>DTrace 有两部分：DTrace 探针，及附加在上面的 DTrace 脚本。</p>

<h4>探针</h4>

<p>你可以将内置 (所谓静态的) 探针加入代码中。IA 探针看起来和普通的 C 函数非常相似。在 Wire，我们的同步代码有一个内部状态机器，我们定义了如下两个探针：</p>

<p>```
provider syncengine_sync {</p>

<pre><code>probe strategy_go_to_state(int);
</code></pre>

<p>} <br/>
```</p>

<p>探针被分组成所谓的 <em>providers</em>。参数 <code>int</code> 是正要进入的状态。在我们的 Objective-C (或 Swift) 代码中，简单的插入以下代码即可：</p>

<p>```objc
&ndash; (void)goToState:(ZMSyncState *)state
{</p>

<pre><code>[self.currentState didLeaveState];
self.currentState = state;
SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE(state.identifier);
[self.currentState didEnterState];
</code></pre>

<p>}
```</p>

<p>我们<a href="#staticProbes">后面</a>会讨论如何整合并且把流程说清楚一些。</p>

<h4>脚本</h4>

<p>现在我们可以编写一个 DTrace 小脚本来展示状态转变：</p>

<p>```
syncengine_sync*:::strategy_go_to_state
{</p>

<pre><code>printf("Transitioning to state %d\n", arg0);
</code></pre>

<p>}
```</p>

<p>(<a href="#DProgrammingLanguage">后面</a>我们会详细展示 DTrace 脚本如何工作。)</p>

<p>如果将 DTrace 保存进 <code>state.d</code>，接下来我们可以使用 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dtrace.1.html" title="dtrace - generic front-end to the DTrace facility"><code>dtrace(1)</code> 命令行工具</a> 来运行它：</p>

<p><code>
% sudo dtrace -q -s state.d
</code></p>

<p>我们可以看到:</p>

<p><code>
Transitioning to state 1
Transitioning to state 2
Transitioning to state 5
</code></p>

<p>正如我们所预期的，并没什么让人激动的。最后使用 <code>^C</code> 可以退出 DTrace。</p>

<p><a name="ATimingExample"></a></p>

<h3>一个定时例子</h3>

<p>因为 DTrace 消耗非常小，所以非常适合用来测试性能 &ndash; 即使需要测试的时间非常短。DTrace 中的时间单位是纳秒。</p>

<p>如果扩展上面的小例子，我们可以输出每个状态所花费的时间:</p>

<p>```
uint64_t last_state;
uint64_t last_state_timestamp;</p>

<p>dtrace:::BEGIN
{</p>

<pre><code>syncState[4] = "EventProcessing";
syncState[5] = "QuickSync1";
syncState[6] = "QuickSync2";
</code></pre>

<p>}</p>

<p>syncengine_sync*:::strategy_go_to_state
/ last_state_timestamp != 0 /
{</p>

<pre><code>t = (walltimestamp - last_state_timestamp) / 1000000;
printf("Spent %d ms in state %s\n", t, syncState[last_state]);
</code></pre>

<p>}</p>

<p>syncengine_sync*:::strategy_go_to_state
{</p>

<pre><code>printf("Transitioning to state %s\n", syncState[arg0]);
last_state = arg0;
last_state_timestamp = walltimestamp;
</code></pre>

<p>}
```</p>

<p>这些代码会输出:</p>

<p><code>
Transitioning to state QuickSync1
Spent 2205 ms in state QuickSync1
Transitioning to state QuickSync2
Spent 115 ms in state QuickSync2
Transitioning to state EventProcessing
</code></p>

<p>脚本中有些新东西。<code>dtrace:::BEGIN</code> 语句在脚本开始时运行。脚本退出时有一个相应的 <code>END</code>。</p>

<p>我们还给第一个探针增加了一个断言 (predicate)，<code>/ last_state_timestamp != 0 /</code>。</p>

<p>最后我们使用全局变量来追踪最后的状态，以及什么时候进入该状态。</p>

<p>内置的 <code>walltimestamp</code> 变量返回当前时间相对于 Unix epoch 时间以来的纳秒数。</p>

<p>还有一个虚拟的单位为纳秒的时间戳变量，<code>vtimestamp</code>。它表示当前的线程在 CPU 上运行的时间减去在 DTrace 上花费的时间。最后，<code>machtimestamp</code> 对应 <code>mach_absolute_time()</code>。</p>

<p>对于上面的脚本，执行的顺序非常重要。我们有两个所谓的<strong>语句</strong>对应同一个探针，(<code>syncengine_sync*:::strategy_go_to_state</code>)。它们会按照在 D 程序中出现的顺序执行。</p>

<h3>结合系统探针</h3>

<p>操作系统，尤其是 kernel，提供了数以千计的探针，被分成不同的提供者 (provider) 组。其中的很多在 <a href="https://docs.oracle.com/cd/E23824_01/html/E22973/gkyal.html" title="Oracle: DTrace Providers">Oracle 的 DTrace 文档</a>中可以找到。</p>

<p>通过下面的脚本，我们可以用 <code>ip</code> 提供者中的 <code>send</code> 探针来检查转换到下一个状态之前通过网络发送了多少字节：</p>

<p>```
uint64_t bytes_sent;</p>

<p>syncengine_sync$target:::strategy_go_to_state
{</p>

<pre><code>printf("Transitioning to state %d\n", arg0);
printf("Sent %d bytes in previous state\n", bytes_sent);
bytes_sent = 0;
</code></pre>

<p>}</p>

<p>ip:::send
/ pid == $target /
{</p>

<pre><code>bytes_sent += args[2]-&gt;ip_plength;
</code></pre>

<p>}
```</p>

<p>这次我们的目标为某个特定的进程 &ndash; <code>ip:::send</code> 会匹配系统的所有进程，而我们只对 <code>Wire</code> 进程感兴趣。我们运行如下的脚本：</p>

<p><code>
sudo dtrace -q -s sample-timing-3.d -p 198
</code></p>

<p>这里 <code>198</code> 是进程标识 (亦称 PID)。我们可以在活动监视器这个 app 中找到这个数字，或者使用 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/ps.1.html"><code>ps(1)</code> 命令行工具</a>。</p>

<p>我们会得到:</p>

<p><code>
Transitioning to state 6
Sent 2043 bytes in previous state
Transitioning to state 4
Sent 581 bytes in previous state
</code></p>

<p><a name="DProgrammingLanguage"></a></p>

<h2>D 语言</h2>

<p>注意：这<strong>不是</strong><a href="https://en.wikipedia.org/wiki/D_%28programming_language%29">W. Bright 和 A. Alexandrescu 的 D 语言</a>。</p>

<p>D 语言的大部分跟 C 语言都非常相似，但总体架构是不同的。每一个 Dtrace 脚本由多个所谓的<strong>探针语句</strong>组成。</p>

<p>在上面的例子中，我们已经看到了一些这种<strong>探针语句</strong>。它们都符合如下的形式:</p>

<p>```
probe descriptions
/ predicate /
{</p>

<pre><code>action statements
</code></pre>

<p>}
```</p>

<p>断言 (<em>predicate</em>) 和动作语句 (<em>action statement</em>) 部分都是可选的。</p>

<h3>探针描述</h3>

<p>探针描述定义了语句匹配什么探针。所有的部分都可以省略，形式如下：</p>

<p><code>
provider:module:function:name
</code></p>

<p>例如，<code>syscall:::</code> 匹配所有 <code>syscall</code> 提供者的探针。我们可以使用 <code>*</code> 匹配任何字符串，例如 <code>syscall::*lwp*:entry</code> 匹配所有 <code>syscall</code> 提供者的 <code>entry</code>，并且函数名字包含 <code>lwp</code> 的探针。</p>

<p>一个探针描述可以包含多个探针，例如:</p>

<p>```
syscall::<em>lwp</em>:entry, syscall::<em>sock</em>:entry
{</p>

<pre><code>trace(timestamp);
</code></pre>

<p>}
```</p>

<h3>断言</h3>

<p>当<strong>动作语句</strong>开始运行时我们可以使用断言来限制。当触发特定的探针时断言会被计算。如果断言结果为非 0，<em>action statements</em> 将会运行，这和 C 语言中的 <code>if</code> 语句类似。</p>

<p>我们可以使用不同的断言来判断同一个探针多次。如果有多个匹配，它们将会按照在 D 程序中的出现的顺序执行。</p>

<h3>动作</h3>

<p>动作包含在花括号中。D 语言是轻量，精悍而且简单的语言。</p>

<p>D 不支持控制流，比如循环和分支。我们不能定义任何用户函数。变量定义也是可选的。</p>

<p>这限制了我们能做的事情。但是一旦知道了一些常见的模式，这种简单也给了我们很多灵活性，我们将在下一节详细讨论。在 <a href="https://docs.oracle.com/cd/E23824_01/html/E22973/gkwpo.html#scrolltoc" title="D Programming Language">D Programming Language</a> 的指南中可以查看更多的细节。</p>

<h2>常见 D 语言模式</h2>

<p>下面的例子会给让我们认识一些我们能做的事情。</p>

<p>这个例子统计了 <em>App Store</em> 应用在 syscall (也就是一个系统调用，或对 kernel 中进行的调用) 中累计使用的时间。</p>

<p>```
syscall:::entry
/ execname == &ldquo;App Store&rdquo; /
{</p>

<pre><code>self-&gt;ts = timestamp;
</code></pre>

<p>}</p>

<p>syscall:::return
/ execname == &ldquo;App Store&rdquo; &amp;&amp; self->ts != 0 /
{</p>

<pre><code>@totals[probefunc] = sum(timestamp - self-&gt;ts);
</code></pre>

<p>}
```</p>

<p>如果运行这个并且开启 <em>App Store</em> 应用，然后用 <code>^C</code> 退出 DTrace 脚本，可以得到像这样的输出:</p>

<p>```
dtrace: script &lsquo;app-store.d&rsquo; matched 980 probes
^C</p>

<p>  <strong>disable_threadsignal                                         2303
  </strong>pthread_sigmask                                              2438
  psynch_cvclrprepost                                            3216
  ftruncate                                                      3663
  bsdthread_register                                             3754
  shared_region_check_np                                         3939
  getpid                                                         4189
  getegid                                                        4276
  gettimeofday                                                   4285
  flock                                                          4825
  sigaltstack                                                    4874
  kdebug_trace                                                   5430
  kqueue                                                         5860
  workq_open                                                     6155
  sigprocmask                                                    6188
  setrlimit                                                      7085
  psynch_cvsignal                                                8909</p>

<p>  [&hellip;]</p>

<p>  stat64                                                      6451260
  read                                                        6657207
  fsync                                                       8231130
  rename                                                      8340468
  open_nocancel                                               8856035
  workq_kernreturn                                           15835068
  getdirentries64                                            17978504
  bsdthread_ctl                                              25418263
  open                                                       29503041
  psynch_mutexwait                                          453338483
  ioctl                                                    1049412360
  __semwait_signal                                         1373514528
  select                                                   1632760820
  kevent64                                                 3656884980
```</p>

<p>在这个例子中，<em>App Store</em> 在 <code>kevent64</code> 中花费了 3.6 秒。</p>

<p>这个脚本中有两个特别有意思的事情：线程本地变量 (<code>self-&gt;ts</code>) 和集积 (aggregation)。</p>

<h3>变量作用域 (scope)</h3>

<p>D 语言有 3 种变量作用域: 全局，线程本地，以及探针语句本地。</p>

<p><code>foo</code> 或 <code>bar</code> 这样的全局变量在整个 D 语言中都是可见的。</p>

<p>线程本地变量命名为 <code>self-&gt;foo</code>，<code>self-&gt;bar</code> 等，并且存在与特定的线程中。</p>

<p>探针语句本地变量与 C 或 Swift 中的本地变量类似。对于中间结果来说很有用。</p>

<p>在这个脚本中，当进入 syscall 时我们使用第一个探针语句来匹配。我们将当前时间戳赋值给线程本地变量 <code>self-&gt;ts</code>：</p>

<p>```
syscall:::entry
/ execname == &ldquo;App Store&rdquo; /
{</p>

<pre><code>self-&gt;ts = timestamp;
</code></pre>

<p>}
```</p>

<p>第二个语句在从 syscall 中返回时匹配。这个调用将和进入时是同一个线程，因此可以确定，即使有多个线程在同一时间进行系统调用，<code>self-&gt;ts</code> 也具有我们所期待的值。</p>

<p>我们在谓词里加入了 <code>self-&gt;ts != 0</code> 来确保即使脚本是在应用处于系统调用中的时候被追加的，它也能正确运行。否则，<code>timestamp - self-&gt;ts</code> 将会是一个非常大的值，因为这时 <code>self-&gt;ts</code> 是还没有被设置的初始值：</p>

<p>```
syscall:::return
/ execname == &ldquo;App Store&rdquo; &amp;&amp; self->ts != 0 /
{</p>

<pre><code>@totals[probefunc] = sum(timestamp - self-&gt;ts);
</code></pre>

<p>}
```</p>

<p>通过 <a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-variables/index.html" title="Dynamic Tracing Guide, Variables">Dynamic Tracing Guide, “Variables.”</a> 可以查看关于变量的核心知识。</p>

<p><a name="Aggregations"></a></p>

<h3>集积 (Aggregation)</h3>

<p>这行代码使用了集积：</p>

<p><code>
@totals[probefunc] = sum(timestamp - self-&gt;ts);
</code></p>

<p>这是 DTrace 的一个极其强大的特性。</p>

<p>我们将 <code>totals</code> 称为集积变量。变量名前面的 <code>@</code> 将它转变为集积行为。<code>probefunc</code> 是一个内置变量 &ndash; 它是探针函数的名字。对于 <code>syscall</code> 探针，<code>probefunc</code> 是正在运行的系统调用的名字。</p>

<p><code>sum</code> 是集积函数。在这个例子中，该集积用来计算每一个 <code>probefunc</code> 对应的 <code>timestamp - self-&gt;ts</code> 的和。</p>

<p><a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-aggs-trunc/index.html">DTrace Guide</a> 展示了一个小例子，该例子使用集积来打印每秒钟调用系统最多的 10 个应用的系统调用的数量。</p>

<p>```</p>

<h1>pragma D option quiet</h1>

<p>BEGIN
{</p>

<pre><code>last = timestamp;
</code></pre>

<p>}</p>

<p>syscall:::entry
{</p>

<pre><code>@func[execname] = count();
</code></pre>

<p>}</p>

<p>tick-10sec
{</p>

<pre><code>trunc(@func, 10);
normalize(@func, (timestamp - last) / 1000000000);
printa(@func);
clear(@func);
last = timestamp;
</code></pre>

<p>}
```</p>

<p>在大多数空闲的 OS X 上，可能会显示如下:</p>

<p>```
kextd                                                             7
ntpd                                                              8
mds_stores                                                       19
cfprefsd                                                         20
dtrace                                                           20
UserEventAgent                                                   34
launchd                                                          42
Safari                                                          109
cloudd                                                          115
com.apple.WebKi                                                 177</p>

<p>mds                                                               8
Wire                                                              8
Terminal                                                         10
com.apple.iClou                                                  15
dtrace                                                           20
securityd                                                        20
tccd                                                             37
syncdefaultsd                                                    98
Safari                                                          109
com.apple.WebKi                                                 212
```</p>

<p>我们看到 Safari，WebKit 和 <code>cloudd</code> 很活跃。</p>

<p>下表为所有集积函数:</p>

<p><code>
Function Name     | Result
------------------|---------
count             | Number of times called
sum               | Sum of the passed in values
avg               | Average of the passed in values
min               | Smallest of the passed in values
max               | Largest of the passed in values
lquantize         | Linear frequency distribution
quantize          | Power-of-two frequency distribution
</code></p>

<p><code>quantize</code> 和 <code>lquantize</code> 函数可以给出一个关于传入的数量的概览:</p>

<p>```
ip:::send
{</p>

<pre><code>@bytes_sent[execname] = quantize(args[2]-&gt;ip_plength);
</code></pre>

<p>}
```</p>

<p>上面的代码会输出类似这样的结果:</p>

<p>```
discoveryd</p>

<pre><code>     value  ------------- Distribution ------------- count    
        16 |                                         0        
        32 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 2        
        64 |                                         0        
</code></pre>

<p>syncdefaultsd</p>

<pre><code>     value  ------------- Distribution ------------- count    
       256 |                                         0        
       512 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 4        
      1024 |                                         0        
</code></pre>

<p>kernel_task</p>

<pre><code>     value  ------------- Distribution ------------- count    
         8 |                                         0        
        16 |@@@@@@@@@@@@@@                           37       
        32 |@@@@@@@@@@@@@@@@@@@@@@@@@@               67       
        64 |                                         0        
</code></pre>

<p>com.apple.WebKi</p>

<pre><code>     value  ------------- Distribution ------------- count    
        16 |                                         0        
        32 |@@@@@@@@@@@@@@@@                         28       
        64 |@@@@                                     7        
       128 |@@@@                                     6        
       256 |                                         0        
       512 |@@@@@@@@@@@@@@@@                         27       
      1024 |                                         0       
</code></pre>

<p>```</p>

<p>查看 <a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-aggs-2/index.html">Dynamic Tracing Guide 的示例</a>来了解如何使用 <code>lquantize</code>。</p>

<h3>联合数组</h3>

<p>不管名字如何，D 语言中的数组更类似 Swift 或 Objective-C 中的字典。另外，它们都是可变的。</p>

<p>我们可以这样定义一个联合数组:</p>

<p><code>
int x[unsigned long long, char];
</code></p>

<p>然后我们可以给它赋值:</p>

<p>```
BEGIN
{</p>

<pre><code>x[123ull, ’a’] = 456;
</code></pre>

<p>}
```</p>

<p>对于 Wire 应用，我们想要追踪 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionTask_class/index.html" title="ADC: NSURLSessionTask">NSURLSessionTask</a> 实例的往复时间。当开始一个任务时，我们触发一个<a href="#staticProbes">静态定义的探针</a>，当完成时还有另一个探针。我们可以写一个简单的脚本：</p>

<p>```
syncengine_sync$target:::operation_loop_enqueue
/ arg0 == 4 /
{</p>

<pre><code>start_transport_request_timestamp[arg1] = timestamp;
</code></pre>

<p>}</p>

<p>syncengine_sync$target:::operation_loop_enqueue
/ arg0 == 6 &amp;&amp; start_transport_request_timestamp[arg1] != 0 /
{</p>

<pre><code>@time["time for transport request round-trip"] = quantize(timestamp - start_transport_request_timestamp[arg1]);
</code></pre>

<p>}
```</p>

<p>我们传入 <a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSURLSessionTask_class/index.html#//apple_ref/occ/instp/NSURLSessionTask/taskIdentifier" title="-[NSURLSessionTask taskIdentifer]"><code>taskIdentifer</code></a> 作为 <code>arg1</code>，任务开始时 <code>arg0</code> 被设置为 4，任务完成时被设置为 6。</p>

<p>正如我们在第一个<a href="#ATimingExample">定时的例子</a>中看到的那样，联合数组在为传入语句的 <code>enum</code> 值提供描述时也非常有用。</p>

<h2>探针和提供者</h2>

<p>让我们回过头看看可用的探针。</p>

<p>可以使用如下的命令来获得一个所有可用探针的列表:</p>

<p><code>
sudo dtrace -l | awk '{ match($2, "([a-z,A-Z]*)"); print substr($2, RSTART, RLENGTH); }' | sort -u
</code></p>

<p>在 OS X 10.10 中有 79 个提供者。其中许多都与 kernel 和系统调用相关。</p>

<p>其中一些提供者是 <a href="https://docs.oracle.com/cd/E23824_01/html/E22973/gkyal.html" title="Oracle: DTrace Providers">Dynamic Tracing Guide</a> 文档中的原始集合中的一部分。让我们看看其中一些我们可用的。</p>

<h3><code>dtrace</code> 提供者</h3>

<p>我们<a href="#ATimingExample">之前</a>提到过 <code>BEGIN</code> 和 <code>END</code> 探针。当以安静模式运行 DTrace 时，<code>dtrace:::END</code> 对于输出摘要尤其有用。错误发生时还有 <code>ERROR</code> 探针。</p>

<h3><code>profile</code> 提供者</h3>

<p><a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-profile/index.html" title="profile Provider"><code>profile</code> 提供者</a>可以用来在某种程度上采样，这对于 Instruments 的用户来说应该非常熟悉。</p>

<p>我们可以以 1001 赫兹的频率来采样栈深度：</p>

<p>```
profile-1001
/pid == $1/
{</p>

<pre><code>@proc[execname] = lquantize(stackdepth, 0, 20, 1);
</code></pre>

<p>}
```</p>

<p>输出会是这样:</p>

<p>```
Safari</p>

<pre><code>     value  ------------- Distribution ------------- count    
       &lt; 0 |                                         0        
         0 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@     704      
         1 |@                                        12       
         2 |@@                                       30       
         3 |@                                        17       
         4 |                                         7        
         5 |                                         6        
         6 |                                         1        
         7 |                                         2        
         8 |                                         1        
         9 |                                         7        
        10 |                                         5        
        11 |                                         1        
        12 |                                         0        
</code></pre>

<p>```</p>

<p>类似的，<code>tick-</code> 探针会每隔固定的时间间隔，以很高打断的级别触发。<code>profile-</code> 探针会在所有 CPU 上触发，而 <code>tick-</code> 每个间隔只会在一个 CPU 上。我们在上面的<a href="#Aggregations">集积</a>例子中使用了 <code>tick-10sec</code> 。</p>

<h3><code>pid</code> 提供者</h3>

<p><code>pid</code> 是一个有点野蛮的提供者。大多数时候，我们真的应该使用下面将要提到的<a href="#staticProbes">静态探针</a>。</p>

<p><code>pid</code> 是进程标识 (process identifier) 的缩写。它可以让我们在进入和退出进程时进行探测。这在<strong>大多数</strong>情况下是可行的。注意函数的进入和返回并不总是可以很好地界定，尤其是在<strong>尾调用优化 (tail-call optimization)</strong>时。另外还有某些函数并不需要创建栈帧等等情况。</p>

<p>当你不能改变代码来增加<a href="#staticProbes">静态探针</a>时，<code>pid</code> 是一个强大的工具。</p>

<p>你可以追踪任何可见的函数。例如这个探针:</p>

<p><code>
pid123:libSystem:printf:return
</code></p>

<p>这个探针会附加到进程标识 (PID) 为 123 的进程中的 <code>printf</code> 函数。</p>

<h3><code>objc</code> 提供者</h3>

<p>与 <code>pid</code> 提供者直接对应的是 <code>objc</code> 提供者。它为 Objective-C 方法的进入和退出提供了探针。还是使用<a href="#staticProbes">静态探针</a>可以提供更好的灵活性。</p>

<p><code>objc</code> 探针的格式如下：</p>

<p><code>
objcpid:[class-name[(category-name)]]:[[+|-]method-name]:[name]
</code></p>

<p>举个例子：</p>

<p><code>
objc207:NSTableView:-*:entry
</code></p>

<p>将匹配进程号 207 中的 <code>NSTableView</code> 的所有实例方法条目。因为冒号 (<code>:</code>) 在 DTrace 中表示探针的指定方案，因此 Objective-C 中方法名里的冒号需要用一个问号 (<code>?</code>) 来替代。比如要匹配 <code>-[NSDate dateByAddingTimeInterval:]</code> 的话，可以这么写：</p>

<p><code>
objc207:NSDate:-dateByAddingTimeInterval?:entry
</code></p>

<p>通过查看 <a href="https://developer.apple.com/library/mac/documentation/Darwin/Reference/ManPages/man1/dtrace.1.html" title="dtrace - generic front-end to the DTrace facility"><code>dtrace(1)</code> 帮助页面</a>可以获得更多详细信息。</p>

<h3><code>io</code> 提供者</h3>

<p>为了追踪与磁盘输入输出相关的活动，<a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-io/index.html" title="io Provider"><code>io</code> 提供者</a> 定义了 6 个探针:</p>

<p><code>
start
done
wait-start
wait-done
journal-start
journal-done
</code></p>

<p><a href="https://docs.oracle.com/cd/E19253-01/817-6223/chp-io/index.html" title="io Provider">Oracle 文档</a>中的例子展示了如何使用：</p>

<p>```</p>

<h1>pragma D option quiet</h1>

<p>BEGIN
{</p>

<pre><code>printf("%10s %58s %2s\n", "DEVICE", "FILE", "RW");
</code></pre>

<p>}</p>

<p>io:::start
{</p>

<pre><code>printf("%10s %58s %2s\n", args[1]-&gt;dev_statname,
        args[2]-&gt;fi_pathname, args[0]-&gt;b_flags &amp; B_READ ? "R" : "W");
</code></pre>

<p>}
```</p>

<p>上面的例子会输出类似这样的结果：</p>

<p><code>
??                   ??/com.apple.Safari.savedState/data.data  R
??            ??/Preferences/com.apple.Terminal.plist.kn0E7LJ  W
??                                            ??/vm/swapfile0  R
??              ??/Preferences/com.apple.Safari.plist.jEQRQ5N  W
??           ??/Preferences/com.apple.HIToolbox.plist.yBPXSnY  W
??       ??/fsCachedData/F2BF76DB-740F-49AF-94DC-71308E08B474  W
??                           ??/com.apple.Safari/Cache.db-wal  W
??                           ??/com.apple.Safari/Cache.db-wal  W
??       ??/fsCachedData/88C00A4D-4D8E-4DD8-906E-B1796AC949A2  W
</code></p>

<h1><code>ip</code> 提供者</h1>

<p><a href="https://wikis.oracle.com/display/DTrace/ip+Provider" title="ip Provider"><code>ip</code> 提供者</a>有 <code>send</code> 和 <code>receive</code> 两个探针。任何时候数据通过 IP 被发送或接收都会触发。参数 <code>arg0</code> 到 <code>arg5</code> 提供了与发送或接收的 IP 包所相关的 kernel 结构体的访问入口。</p>

<p>可以将二者放入非常强大的网络调试工具中。它可以使 <code>tcpdump(1)</code> 的看起来像过时的玩意。<code>ip</code> 提供者可以让我们在需要的时候精确的输出我们所需要的信息。</p>

<p>查看<a href="https://wikis.oracle.com/display/DTrace/ip+Provider" title="ip Provider">文档</a>获得更多很棒的示例。</p>

<p><a name="staticProbes"></a></p>

<h2>定义自己的静态探针</h2>

<p>DTrace 允许我们创建自己的探针，通过这个，我们可以为我们自己的 app 释放 DTrace 的真正威力。</p>

<p>这些在 DTrace 中被称作<strong>静态探针</strong>。我们在<a href="#ATimingExample">第一个例子</a>中曾经简短的提到过。<a href="https://itunes.apple.com/app/wire/id931134707?mt=12">Wire</a> 定义了自己的提供者和探针：</p>

<p>```
provider syncengine_sync {</p>

<pre><code>probe strategy_go_to_state(int);
</code></pre>

<p>}
```</p>

<p>然后我们在代码中调用探针:</p>

<p>```objc
&ndash; (void)goToState:(ZMSyncState *)state
{</p>

<pre><code>[self.currentState didLeaveState];
self.currentState = state;
SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE(state.identifier);
[self.currentState didEnterState];
</code></pre>

<p>}
```</p>

<p>一个可能的争论就是我们本来可以干脆直接使用 <code>objc</code> 提供者；使用我们自己的探针可以更具灵活性。以后我们可以修改 Objective-C 代码而不影响 DTrace 探针。</p>

<p>另外，静态探针给我们提供更方便的参数访问方式。通过上面我们可以看到我们如何利用它来追踪时间和输出日志。</p>

<p>DTrace 静态探针的强大之处在于给我们提供了稳定的接口来调试我们的代码，并且即便是在生产代码中这个接口也是存在的。即使对于应用的生产版本，当有人看到奇怪的行为，我们也可以给正在运行的应用附加一段 DTrace 脚本。DTrace 的灵活性还可以让我们将同一个探针用于其他目的。</p>

<p>我们可以将 DTrace 作为日志工具使用。还可以用来收集与时间，网络，请求等有关的详细的量化信息。</p>

<p>我们可以将探针留在生产代码中的原因是探针是<strong>零损耗</strong>的，或者公平点说，相当于一个测试和分支的 CPU 指令。</p>

<p>下面来看看如何将静态探针加入到我们的工程。</p>

<h3>提供者描述</h3>

<p>首先我们需要创建一个 <code>.d</code> 文件并定义提供者和探针。如果我们创建了一个 <code>provider.d</code> 文件并写入以下内容，会得到两个提供者:</p>

<p>```
provider syncengine_sync {</p>

<pre><code>probe operation_loop_enqueue(int, int, intptr_t);
probe operation_loop_push_channel_data(int, int);
probe strategy_go_to_state(int);
probe strategy_leave_state(int);
probe strategy_update_event(int, int);
probe strategy_update_event_string(int, char *);
</code></pre>

<p>};</p>

<p>provider syncengine_ui {</p>

<pre><code>probe notification(int, intptr_t, char *, char *, int, int, int, int);
</code></pre>

<p>};
```</p>

<p>提供者是 <code>syncengine_sync</code> 和 <code>syncengine_ui</code>。在每个提供者中，我们定义了一组探针。</p>

<h3>创建头文件</h3>

<p>现在我们需要将 <code>provider.d</code> 加入到 Xcode 的构建目标中。确保将类型设置为 <em>DTrace source</em>，这十分重要。Xcode 现在会在构建时自动处理。在这个步骤中，DTrace 会创建一个对应的 <code>provider.h</code> 头文件，我们可以引入它。将 <code>provider.d</code> 同时加入 Xcode 工程和相应的构建目标非常重要。</p>

<p>在处理时，Xcode 会调用 <code>dtrace(1)</code> 工具:</p>

<p><code>
dtrace -h -s provider.d
</code></p>

<p>这会生成相应的头文件。该文件最后会出现在 <a href="https://developer.apple.com/library/mac/documentation/DeveloperTools/Reference/XcodeBuildSettingRef/1-Build_Setting_Reference/build_setting_ref.html#//apple_ref/doc/uid/TP40003931-CH3-SW43" title="DERIVED_FILE_DIR"><code>DERIVED_FILE_DIR</code></a> 中。可以通过以下方式在任何工程内的源文件中引用</p>

<p>```</p>

<h1>import &ldquo;provider.h&rdquo;</h1>

<p>```</p>

<p>Xcode 有一个内置的所谓 <strong>build rule</strong> 来处理 DTrace 提供者描述。比较 <a href="http://objccn.io/issue-6-1">objc.io Build 过程</a>的内容来获取关于构建规则和构建处理的更多的信息。</p>

<h3>增加探针</h3>

<p>对于每一个静态探针，头文件会包含两个宏:</p>

<p><code>
PROVIDER_PROBENAME()
PROVIDER_PROBENAME_ENABLED()
</code></p>

<p>第一个是探针本身。第二个会在探针关闭时取值为 0。</p>

<p>DTrace 探针自己本身在没被启用时是零消耗的，也就是说只要没有附加在探针上的东西，它们就不会产生消耗。然而有时，我们可能想要提前判断或将数据发送给探针之前做一些预处理。在这些不太常见的情况下，我们可以使用 <code>_ENABLED()</code> 宏：</p>

<p>```
if (SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE_ENABLED()) {</p>

<pre><code>argument = /* Expensive argument calculation code here */;
SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE(argument);
</code></pre>

<p>};
```</p>

<h3>包装 DTrace 探针</h3>

<p>代码可读性非常重要。随着增加越来越多的探针到代码中，我们需要确保代码不会因此而变得乱七八糟和难以理解。毕竟探针的目的是帮助我们而不是将事情变得更复杂。</p>

<p>我们所需要做的就是增加另一个简单的包装器。这些包装器既使代码的可读性更好了一些，也增加了 <code>if (…_ENABLED*())</code> 检查。</p>

<p>回到状态机器的例子中，我们的探针宏是这样的：</p>

<p><code>
SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE(state);
</code></p>

<p>为了使它变得更简单，我们创建另一个头文件并定义：</p>

<p>```
static inline void ZMTraceSyncStrategyGoToState(int d) {</p>

<pre><code>SYNCENGINE_SYNC_STRATEGY_GO_TO_STATE(d);
</code></pre>

<p>}
```</p>

<p>有了这个，之后我们就调用：</p>

<p><code>
ZMTraceSyncStrategyGoToState(state);
</code></p>

<p>这看起来有点取巧，但是<a href="https://en.wikipedia.org/wiki/CamelCase">驼峰式命名</a>确实能在混合普通的 Objective-C 和 Swift 代码风格方面做得更好。</p>

<p>更进一步的，如果我们看到上面定义的</p>

<p>```
provider syncengine_ui {</p>

<pre><code>probe notification(int, intptr_t, char *, char *, int, int, int, int);
</code></pre>

<p>};
```</p>

<p>有一长串的参数。在 Wire 中，我们用这个来记录 UI 通知日志。</p>

<p>这个探针有一长串的参数。我们决定只要一个探针来处理许多不同通知，这些通知都是同步代码发给 UI 用以提醒变化的。第一个参数，<code>arg0</code>，定义了是什么通知，第二个参数定义了 <code>NSNotification</code> 的 <code>object</code>。在这使得我们的 DTrace 脚本可以将感兴趣的范围限定在某几个指定的通知中。</p>

<p>剩余的参数定义根据预先的通知不同可以稍微宽松些，而且对于各个单独情况我们有多个包装函数。当想要传入两个 <code>NSUUID</code> 对象的情况，我们类似这样来调用包装函数：</p>

<p>```
ZMTraceUserInterfaceNotification_UUID(1, note.object,</p>

<pre><code>conversation.remoteIdentifier, participant.user.remoteIdentifier,
    wasJoined, participant.isJoined, currentState.connectionState, 0);
</code></pre>

<p>```</p>

<p>这个包装函数是这样定义的:</p>

<p>```
static inline void ZMTraceUserInterfaceNotification_UUID(int d, NSObject <em>obj, NSUUID </em>remoteID1, NSUUID *remoteID2, int e, int f, int g, int h) {</p>

<pre><code>if (SYNCENGINE_UI_NOTIFICATION_ENABLED()) {
    SYNCENGINE_UI_NOTIFICATION(d, (intptr_t) (__bridge void *) obj, remoteID1.transportString.UTF8String, remoteID2.transportString.UTF8String, e, f, g, h);
}
</code></pre>

<p>}
```</p>

<p>正如之前提到的，我们有两个目的。第一，不让类似 <code>(intptr_t) (__bridge void *)</code> 这样的代码把我们的代码搞的乱七八糟。另外，除非因为附加到探针的时候有需要，其他时候我们无需花费 CPU 周期将一个 <code>NSUUID</code> 转换为 <code>NSString</code> 并进一步转换为 <code>char const *</code>。</p>

<p>根据这个模式，我们可以定义多个包装器 / 辅助函数来复用相同的 DTrace 探针。</p>

<h3>DTrace 和 Swift</h3>

<p>像这样包装 DTrace 探针可以让我们整合 Swift 和 DTrace 静态探针。<code>static line</code> 函数现在可以在 Swift 代码中直接调用。</p>

<p>```glsl
func goToState(state: ZMSyncState) {</p>

<pre><code>currentState.didLeaveState()
currentState = state
currentState.didEnterState()
ZMTraceSyncStrategyGoToState(state.identifier)
</code></pre>

<p>}
```</p>

<h2>DTrace 如何工作</h2>

<p>D 语言是编译型语言。当运行 <code>dtrace(1)</code> 工具时，我们传入的脚本被编译成字节码。接着字节码被传入 kernel。在 kernel 中有一个解释器来运行这些字节码。</p>

<p>这就是为什么这种编程语言可以保持简单。没人希望 DTrace 脚本中的 bug 引起 kernel 的死循环并导致系统挂起。</p>

<p>当将静态探针加入可执行程序 (一个 app 或 framework)，它们被作为 <code>S_DTRACE_DOF</code> (Dtrace Object Format) 部分被加入，并且在程序运行时被加载进 kernel。这样 DTrace 就知道当前的静态探针。</p>

<h2>最后的话</h2>

<p>毫无疑问 DTrace 非常强大和灵活。然而需要注意的是 DTrace 并不是一些经过考验和真正的工具的替代品，如 <code>malloc_history</code>，<code>heap</code> 等。记得始终使用正确的工具。</p>

<p>另外，DTrace 并不是魔法。你仍然需要知道你要解决的问题所在。</p>

<p>这就是说，DTrace 可以使你的开发技能和能力达到一个新的水准。它可以让你在生产代码中追踪那些很难或不可能定位的问题。</p>

<p>如果你的代码中有 <code>#ifdef TRACING</code> 或 <code>#if LOG_LEVEL == 1</code>，使用 DTrace 替换它们或许是很好的主意。</p>

<p>记得查看 <a href="https://docs.oracle.com/cd/E23824_01/html/E22973/toc.html" title="Oracle Solaris Dynamic Tracing Guide">Dynamic Tracing Guide</a> (<a href="https://docs.oracle.com/cd/E23824_01/pdf/E22973.pdf" title="Oracle Solaris Dynamic Tracing Guide">PDF version</a>)。并且在你系统的 <code>/usr/share/examples/DTTk</code> 文件夹中获取更多的灵感。</p>

<p>调试快乐！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metal]]></title>
    <link href="http://objcio.com/blog/2014/11/26/metal/"/>
    <updated>2014-11-26T10:03:00+08:00</updated>
    <id>http://objcio.com/blog/2014/11/26/metal</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-18/metal.html">Metal</a>，感谢 <a href="http://onevcat.com/">onevcat</a> 校对，转载请注明出处。本文亦被收录于 <a href="http://objccn.io/">objc中国</a>。</p>

<blockquote><p>Mental 框架支持 GPU 加速高级 3D 图像渲染，以及数据并行计算工作。Mental 提供了先进合理的 API，它不仅为图形的组织、处理和呈现，也为计算命令以及为这些命令相关的数据和资源的管理，提供了细粒度和底层的控制。Mental 的主要目的是最小化 GPU 工作时 CPU 所要的消耗。</p></blockquote>

<p>– <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40014221-CH1-SW1">Metal Programming Guide</a></p>

<p>Mental 是针对 iPhone 和 iPad 中 GPU 编程的高度优化的框架。其名字来源是因为 Metal 是 iOS 平台中最底层的图形框架 (意指 &ldquo;最接近硬件&rdquo;)。</p>

<p>该框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在 <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPU</a>.  上执行。</p>

<!--more-->


<h2>什么人应该使用 Mental?</h2>

<p>在谈论 API 和语言本身之前，我们应该讨论一下什么样的开发者能从 Metal 中受益。正如上面提过的，Metal 提供两个功能: 图形渲染和并行计算。</p>

<p>对于寻找游戏引擎的开发者来说，Metal 不是最佳选择。苹果官方的的 <a href="https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D) 是更好的选择。这些 API 提供了包括物理模拟在内的更高级别的游戏引擎。另外还有功能更全面的 3D 引擎，例如 Epic 的 <a href="https://www.unrealengine.com/">Unreal Engine</a> 或 <a href="http://unity3d.com">Unity</a>，二者都是跨平台的。使用这些引擎，你无需直接使用 Metal 的 API，就可以从 Metal 中获益。</p>

<p>编写基于底层图形 API 的渲染引擎时，除了 Metal 以外的其他选择还有 OpenGL 和 OpenGL ES。OpenGL 不仅支持包括 OSX，Windows，Linux 和 Android 在内的几乎所有平台，还有大量的教程，书籍和最佳实践指南等资料。目前，Metal 的资源非常有限，并且仅限于搭载了 64 位处理器的 iPhone 和 iPad。但另外一方面，因为 OpenGL 的限制，其性能与 Metal 相比并不占优势，毕竟后者是专门用来解决这些问题的。</p>

<p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenCL 在 iOS 上是私有框架，而 Core Image (使用了 OpenCL) 对这样的任务来说既不够强大又不够灵活。</p>

<h2>使用 Metal 的好处</h2>

<p>Metal 的最大好处就是与 OpenGL ES 相比显著降低了消耗。在 OpenGL 中无论创建缓冲区还是纹理，OpenGL 都会复制一份以防止 GPU 在使用它们的时候被意外访问。出于安全的原因复制类似纹理和缓冲区这样的大的资源是非常耗时的操作。而 Metal 并不复制资源。开发者需要负责在 CPU 和 GPU 之间同步访问。幸运的是，苹果提供了另一个很棒的 API 使资源同步访问更加容易，那就是 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html">Grand Central Dispatch</a>。虽然使用 Metal 时仍然有些这方面的问题需要注意，但是一个在渲染时加载和卸载资源的先进的引擎，在避免额外的复制后能够获得更多的好处。</p>

<p>Metal 的另外一个好处是其预估 GPU 状态来避免多余的验证和编译。通常在 OpenGL 中，你需要依次设置 GPU 的状态，在每个绘制指令 (draw call) 之前需要验证新的状态。最坏的情况是 OpenGL 需要再次重新编译着色器 (shader) 以反映新的状态。当然，这种评估是必要的，但 Metal 选择了另一种方法。在渲染引擎初始化过程中，一组状态被烘焙 (bake) 至预估渲染的 路径 (pass) 中。多个不同资源可以共同使用该渲染路径对象，但其它的状态是恒定的。Metal 中一个渲染路径无需更进一步的验证，使 API 的消耗降到最低，从而大大增加每帧的绘制指令的数量。</p>

<h2>Metal API</h2>

<p>虽然这个平台上许多 API 都暴露为具体的类，但 Metal 提供的大多是协议。因为 Metal 对象的具体类型取决于 Metal 运行在哪个设备上。这更鼓励了面向接口而不是面向实现编程。然而，这同时也意味着，如果不使用 Objective-C 运行时的广泛而危险的操作，就不能子类化 Metal 的类或者为其增加扩展，</p>

<p>Metal 为了速度而在安全性上做了必要的妥协。对于错误，苹果的其它框架显得更加安全和健壮，而 Metal 则完全相反。在某些时候，你会收到指向内部缓冲区的裸指针，你必须小心的同步访问它。OpenGL 中发生错误时，结果通常是黑屏；然而在 Metal 中，结果可能是完全随机的效果，例如闪屏和偶尔的崩溃。之所以有这些陷阱，是因为 Metal 框架是对 GPU 的非常轻量级抽象。</p>

<p>一个有趣的方面是苹果并没有为 Metal 实现可以在 iOS 模拟器上使用的软件渲染。使用 Metal 框架的时候应用必须运行在真实设备上。</p>

<h2>基础 Metal 程序</h2>

<p>在这部分中，我们会介绍写出第一个 Metal 程序所必要的部分。这个简单的程序绘制了一个正方形的旋转。你可以在 <a href="https://github.com/warrenm/metal-demo-objcio">GitHub 中下载这篇文章的示例代码</a>。</p>

<p>虽然不能涵盖每一个细节，但我们尽量涉及至少所有的移动部分。你可以阅读源代码和参阅线上资源来深入理解。</p>

<h3>使用 UIKit 创建设备和界面</h3>

<p>在 Metal 中，<strong>设备</strong>是 GPU 的抽象。它被用来创建很多其它类型的对象，例如缓冲区，纹理和函数库。使用 <code>MTLCreateSystemDefaultDevice</code> 函数来获取默认设备:</p>

<p><code>objc
id&lt;MTLDevice&gt; device = MTLCreateSystemDefaultDevice();
</code></p>

<p>注意 device 并不是一个详细具体的类，正如前面提到的，它是遵循 <code>MTLDevice</code> 协议的类。</p>

<p>下面的代码展示了如何创建一个 Metal layer 并将它作为 sublayer 添加到一个 UIView 的 layer:</p>

<p><code>objc
CAMetalLayer *metalLayer = [CAMetalLayer layer];
metalLayer.device = device;
metalLayer.pixelFormat = MTLPixelFormatBGRA8Unorm;
metalLayer.frame = view.bounds;
[view.layer addSublayer:self.metalLayer];
</code></p>

<p><code>CAMetalLayer</code> 是 <a href="https://developer.apple.com/library/mac/Documentation/GraphicsImaging/Reference/CALayer_class/index.html"><code>CALayer</code></a> 的子类，它可以展示 Metal 帧缓冲区的内容。我们必须告诉 layer 该使用哪个 Metal 设备 (我们刚创建的那个)，并通知它所预期的像素格式。我们选择 8-bit-per-channel BGRA 格式，即每个像素由蓝，绿，红和透明组成，值从 0-255。</p>

<h3>库和函数</h3>

<p>你的 Metal 程序的很多功能会被用顶点和片段函数的方式书写，也就是我们所说的着色器。Metal 着色器用 Metal 着色器语言编写，我们将在下面详细讨论。Metal 的优点之一就是着色器函数在你的应用构建到中间语言时进行编译，这可以节省很多应用启动时所需的时间。</p>

<p>一个 Metal 库是一组函数的集合。你的所有写在工程内的着色器函数都将被编译到默认库中，这个库可以通过设备获得:</p>

<p><code>objc
id&lt;MTLLibrary&gt; library = [device newDefaultLibrary]
</code></p>

<p>接下来构建渲染管道状态的时候将使用这个库。</p>

<h3>命令队列</h3>

<p>命令通过与 Metal 设备相关联的命令队列提交给 Metal 设备。命令队列以线程安全的方式接收命令并顺序执行。创建一个命令队列:</p>

<p><code>objc
id&lt;MTLCommandQueue&gt; commandQueue = [device newCommandQueue];
</code></p>

<h3>构建管道</h3>

<p>当我们在 Metal 编程中提到管道，指的是顶点数据在渲染时经历的变化。顶点着色器和片段着色器是管道中两个可编程的节点，但还有其它一定会发生的事件 (剪切，栅格化和视图变化) 不在我们的直接控制之下。管道特性中的后者的类组成了固定功能管道。</p>

<p>在 Metal 中创建一个管道，我们需要指定对于每个顶点和每个像素分别想要执行哪个顶点和片段函数 (译者注: 片段着色器又被称为像素着色器)。我们还需要将帧缓冲区的像素格式告诉管道。在本例中，该格式必须与 Metal layer 的格式匹配，因为我们想在屏幕上绘制。</p>

<p>从库中通过名字来获取函数:</p>

<p><code>objc
id&lt;MTLFunction&gt; vertexProgram = [library newFunctionWithName:@"vertex_function"];
id&lt;MTLFunction&gt; fragmentProgram = [library newFunctionWithName:@"fragment_function"];
</code></p>

<p>接下来创建一个设置了函数和像素格式的管道描述器:</p>

<p><code>objc
MTLRenderPipelineDescriptor *pipelineStateDescriptor = [[MTLRenderPipelineDescriptor alloc] init];
[pipelineStateDescriptor setVertexFunction:vertexProgram];
[pipelineStateDescriptor setFragmentFunction:fragmentProgram];
pipelineStateDescriptor.colorAttachments[0].pixelFormat = MTLPixelFormatBGRA8Unorm;        
</code></p>

<p>最后，我们从描述器中创建管道状态。这会根据程序运行的硬件环境，从中间代码中编译着色器函数为优化后的代码。</p>

<p><code>objc
id&lt;MTLRenderPipelineState&gt; pipelineState = [device newRenderPipelineStateWithDescriptor:pipelineStateDescriptor error:nil];
</code></p>

<h3>读取数据到缓冲区</h3>

<p>现在已经有了一个构建好的管道，我们需要用数据填充它。在示例工程中，我们绘制了一个简单的几何图形: 一个旋转的正方形。正方形由两个共享一条边的直角三角形组成:</p>

<p>```objc
static float quadVertexData[] =
{</p>

<pre><code> 0.5, -0.5, 0.0, 1.0,     1.0, 0.0, 0.0, 1.0,
-0.5, -0.5, 0.0, 1.0,     0.0, 1.0, 0.0, 1.0,
-0.5,  0.5, 0.0, 1.0,     0.0, 0.0, 1.0, 1.0,

 0.5,  0.5, 0.0, 1.0,     1.0, 1.0, 0.0, 1.0,
 0.5, -0.5, 0.0, 1.0,     1.0, 0.0, 0.0, 1.0,
-0.5,  0.5, 0.0, 1.0,     0.0, 0.0, 1.0, 1.0,
</code></pre>

<p>};<br/>
```</p>

<p>每一行的前四个数字代表了每一个顶点的 x，y，z 和 w 元素。后四个数字代表每个顶点的红色，绿色，蓝色和透明值元素。</p>

<p>你可能会奇怪为什么需要四个数字来描述 3D 空间中的一个位置。第四个顶点位置元素，w，是一个数学上的便利，使我们能以一种统一的方式描述 3D 转换 (旋转，平移，缩放)。这个细节在本文的示例代码并没有体现。</p>

<p>为了使用 Metal 绘制顶点数据，我们需要将它放入缓冲区。缓冲区是被 CPU 和 GPU 共享的简单的无结构的内存块:</p>

<p>```objc
vertexBuffer = [device newBufferWithBytes:quadVertexData</p>

<pre><code>                                   length:sizeof(quadVertexData)
                                  options:MTLResourceOptionCPUCacheModeDefault];
</code></pre>

<p>```</p>

<p>我们将使用另一个缓冲区来存储用来旋转正方形的旋转矩阵。与预先提供数据不同，这里只是通过创建规定长度的缓冲区来创建一个空间。</p>

<p>```objc
uniformBuffer = [device newBufferWithLength:sizeof(Uniforms)</p>

<pre><code>                                    options:MTLResourceOptionCPUCacheModeDefault];
</code></pre>

<p>```</p>

<h3>动画</h3>

<p>为了在屏幕上旋转正方形，我们需要把转换顶点作为顶点着色器的一部分。这需要更新每一帧的统一缓冲区。我们运用三角学知识，从当前旋转角度生成一个旋转矩阵，将它复制到统一缓冲区。</p>

<p><code>Uniforms</code> 结构体只有一个成员，该成员是一个保存了旋转矩阵的 4x4 的矩阵。矩阵类型 <code>matrix_float4x4</code> 来自于苹果的 SIMD 库，该库是一个类型的集合，它们可以从 <a href="http://en.wikipedia.org/wiki/SIMD">数据并行操作</a> 中获益:</p>

<p>```objc
typedef struct
{</p>

<pre><code>matrix_float4x4 rotation_matrix;
</code></pre>

<p>} Uniforms;
```</p>

<p>为了将旋转矩阵复制到统一缓冲区中，我们取得它的内容的指针并将矩阵 <code>memcpy</code> 进去:</p>

<p><code>objc
Uniforms uniforms;
uniforms.rotation_matrix = rotation_matrix_2d(rotationAngle);
void *bufferPointer = [uniformBuffer contents];
memcpy(bufferPointer, &amp;uniforms, sizeof(Uniforms));
</code></p>

<h3>准备绘制</h3>

<p>为了在 Metal layer 上绘制，首先我们需要从 layer 中获得一个 &lsquo;drawable&rsquo; 对象。这个可绘制对象管理着一组适合渲染的纹理:</p>

<p><code>objc
id&lt;CAMetalDrawable&gt; drawable = [metalLayer nextDrawable];
</code></p>

<p>接下来我们创建一个渲染路径描述器，它描述了在渲染之前和完成之后 Metal 应该执行的不同动作。下面我们展示了一个渲染路径，它将首先把帧缓冲区清除为纯白色，然后执行绘制指令，最后将结果存储到帧缓冲区来展示:</p>

<p><code>objc
MTLRenderPassDescriptor *renderPassDescriptor = [MTLRenderPassDescriptor renderPassDescriptor];
renderPassDescriptor.colorAttachments[0].texture = drawable.texture;
renderPassDescriptor.colorAttachments[0].loadAction = MTLLoadActionClear;
renderPassDescriptor.colorAttachments[0].clearColor = MTLClearColorMake(1, 1, 1, 1);
renderPassDescriptor.colorAttachments[0].storeAction = MTLStoreActionStore;
</code></p>

<h3>发布绘制指令</h3>

<p>要放入设备的命令队列的命令必须被编码到命令缓冲区里。命令缓冲区是一个或多个命令的集合，可以以一种 GPU 了解的紧凑的方式执行和编码。</p>

<p><code>objc
id&lt;MTLCommandBuffer&gt; commandBuffer = [self.commandQueue commandBuffer];
</code></p>

<p>为了真正编码渲染命令，我们还需要另一个知道如何将我们的绘制指令转换为 GPU 懂得的语言的对象。这个对象叫做命令编码器。我们将上面创建的渲染路径描述器作为参数传入，就可以向命令缓冲区请求一个编码器:</p>

<p><code>objc
id&lt;MTLRenderCommandEncoder&gt; renderEncoder = [commandBuffer renderCommandEncoderWithDescriptor:renderPassDescriptor];
</code></p>

<p>在绘制指令之前，我们使用预编译的管道状态设置渲染命令编码器并建立缓冲区，该缓冲区将作为顶点着色器的参数:</p>

<p><code>objc
[renderEncoder setRenderPipelineState:pipelineState];
[renderEncoder setVertexBuffer:vertexBuffer offset:0 atIndex:0];
[renderEncoder setVertexBuffer:uniformBuffer offset:0 atIndex:1];
</code></p>

<p>为了真正的绘制几何图形，我们告诉 Metal 要绘制的形状 (三角形) 和缓冲区中顶点的数量 (本例中 6 个):</p>

<p><code>objc
[renderEncoder drawPrimitives:MTLPrimitiveTypeTriangle vertexStart:0 vertexCount:6];
</code></p>

<p>最后，执行 <code>endEncoding</code> 通知编码器发布绘制指令完成。</p>

<p><code>objc
[renderEncoder endEncoding];
</code></p>

<h3>展示帧缓冲区</h3>

<p>现在我们的绘制指令已经被编码并准备就绪，我们需要通知命令缓冲区应该将结果在屏幕上显示出来。调用  <code>presentDrawable</code>，使用当前从 Metal layer 中获得的 drawable 对象作为参数:</p>

<p><code>objc
[commandBuffer presentDrawable:drawable];
</code></p>

<p>执行 <code>commit</code> 告诉缓冲区已经准备好安排并执行:</p>

<p><code>objc
[commandBuffer commit];
</code></p>

<p>就这么多！</p>

<h2>Metal 着色语言</h2>

<p>虽然 Metal 和 <a href="https://developer.apple.com/swift/">Swift</a> 是在 <a href="https://www.apple.com/apple-events/june-2014/">WWDC keynote</a> 上被一同发表的，但着色语言是基于 <a href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11</a> 的，有一些有限制的特性和增加的关键字。</p>

<h3>Metal 着色语言实践</h3>

<p>为了在着色器里使用顶点数据，我们定义了一个对应 Objective-C 中顶点数据的结构体：</p>

<p>```glsl
typedef struct
{</p>

<pre><code>float4 position;
float4 color;
</code></pre>

<p>} VertexIn;
```</p>

<p>我们还需要一个类似的结构体来描述从顶点着色器传入片段着色器的顶点类型。然而，在本例中，我们必须区分 (通过使用 <code>[[position]]</code> 属性) 哪一个结构体成员应该被看做是顶点位置:</p>

<p><code>glsl
typedef struct {
 float4 position [[position]];
 float4 color;
} VertexOut;
</code></p>

<p>顶点函数在顶点数据中每个顶点被执行一次。它接收顶点列表的一个指针，和一个包含旋转矩阵的统一数据的引用。第三个参数是一个索引，用来告诉函数当前操作的是哪个顶点。</p>

<p>注意顶点函数的参数后面紧跟着标明它们用途的属性。在缓冲区参数中，参数中的索引对应着我们在渲染命令编码器中设置缓冲区时指定的索引。Metal 就是这样来区分哪个参数对应哪个缓冲区。</p>

<p>在顶点函数中，我们用顶点的位置乘以旋转矩阵。我们构建矩阵的方式决定了效果是围绕中心旋转正方形。接着我们将这个转换过的位置传入输出顶点。顶点颜色则从输入参数中直接复制。</p>

<p>```glsl
vertex VertexOut vertex_function(device VertexIn *vertices [[buffer(0)]],</p>

<pre><code>                                 constant Uniforms &amp;uniforms [[buffer(1)]],
                                 uint vid [[vertex_id]])
</code></pre>

<p>{</p>

<pre><code>VertexOut out;
out.position = uniforms.rotation_matrix * vertices[vid].position;
out.color = vertices[vid].color;
return out;
</code></pre>

<p>}
```</p>

<p>片段函数每个像素就会被执行一次。Metal 在 <a href="http://fgiesen.wordpress.com/2013/02/08/triangle-rasterization-in-practice/">rasterization</a> 过程中会通过在每个顶点中指定的位置和颜色参数中添加来生成参数。在这个简单的片段函数中，我们只是简单的返回了 Metal 添加的颜色。这会成为屏幕像素的颜色:</p>

<p>```objc
fragment float4 fragment_function(VertexOut in [[stage_in]])
{</p>

<pre><code>return in.color;
</code></pre>

<p>}
```</p>

<h2>为什么不干脆扩展 OPENGL?</h2>

<p>苹果是 OpenGL 架构审查委员会的成员，并且历史上也在 iOS 上提供过它们自己的 GL 扩展。但从内部改变 OpenGL 看起来是个困难的任务，因为它有着不同的设计目标。实际上，它必须有广泛的硬件兼容性以运行在很多不同的设备上。虽然 OpenGL 还在持续发展，但速度缓慢。</p>

<p>而 Metal 则本来就是只为了苹果的平台而创建的。即使基于协议的 API 最初看起来不太常见，但和其它框架配合的很好。Metal 是用 Objective-C 编写的，基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html">Foundation</a>，使用 GCD 在 CPU 和 GPU 之间保持同步。它是更先进的 GPU 管道的抽象，而 OpenGL 想达到这些的话只能完全重写。</p>

<h2>Mac 上的 Metal?</h2>

<p>OS X 上支持 Metal 也是迟早的事。API 本身并不局限于 iPhone 和 iPad 使用的 ARM 架构的处理器。Metal 的大多数优点都可以移植到先进的 GPU 上。另外，iPhone 和 iPad 的 CPU 和 GPU 是共享内存的，无需复制就可以交换数据。这一代的 Mac 电脑并未提供共享内存，但这只是时间问题。或许，API 会被调整为支持使用了专门内存的架构，或者 Metal 只会运行在下一代的 Mac 电脑上。</p>

<h2>总结</h2>

<p>本文中我们尝试给出公正并有所帮助的关于 Metal 框架的介绍。</p>

<p>当然，大多数的游戏开发者并不会直接使用 Metal。然而，顶层的游戏引擎已经从中获益，并且开发者无需直接使用 API 就可以从最新的技术中得到好处。另外，对于那些想要发挥硬件全部性能的开发者来说，Metal 或许可以让他们在游戏中创建出与众不同而华丽的效果，或者进行更快的并行计算，从而得到竞争优势。</p>

<h2>资源</h2>

<ul>
<li><a href="https://developer.apple.com/Library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html">Metal Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/Introduction/Introduction.html">Metal Shading Language Guide</a></li>
<li><a href="http://metalbyexample.com">Metal by Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 URL Scheme 完全指南]]></title>
    <link href="http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes/"/>
    <updated>2014-05-21T11:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://iosdevelopertips.com/cocoa/launching-your-own-application-via-a-custom-url-scheme.html">The Complete Tutorial on iOS/iPhone Custom URL Schemes</a>，转载请注明出处。</p>

<p><strong>注意</strong>: <em>自从自定义 URL 的引入，本文始终是我博客中阅读量最大的文章。虽然大多数都相同，但仍然有一些细微差别的变化。本文是原帖的重写版，更新为最新的 iOS 和 Xcode 版本。</em></p>

<p>iPhone / iOS SDK 最酷的特性之一就是应用将其自身"绑定"到一个自定义 URL scheme 上，该 scheme 用于从浏览器或其他应用中启动本应用。</p>

<h2>注册自定义 URL Scheme</h2>

<p>注册自定义 URL Scheme 的第一步是创建 URL Scheme &mdash; 在 Xcode Project Navigator 中找到并点击工程 info.plist 文件。当该文件显示在右边窗口，在列表上点击鼠标右键，选择 <em>Add Row</em>:</p>

<p>向下滚动弹出的列表并选择 <em>URL types</em>。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-01.gif" alt="iOS Custom URL Scheme" /></p>

<p>点击左边剪头打开列表，可以看到 <em>Item 0</em>，一个字典实体。展开 <em>Item 0</em>，可以看到 <em>URL Identifier</em>，一个字符串对象。该字符串是你自定义的 URL scheme 的名字。建议采用反转域名的方法保证该名字的唯一性，比如 <em>com.yourCompany.yourApp</em>。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-02.gif" alt="urlScheme2a" /></p>

<p>点击 <em>Item 0</em> 新增一行，从下拉列表中选择 <em>URL Schemes</em>，敲击键盘回车键完成插入。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-03.gif" alt="iOS Custom URL Scheme" /></p>

<p>注意 URL Schemes 是一个数组，允许应用定义多个 URL schemes。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-04.gif" alt="iOS Custom URL Scheme" /></p>

<p>展开该数据并点击 <em>Item 0</em>。你将在这里定义自定义 URL scheme 的名字。只需要名字，不要在后面追加 :// &mdash; 比如，如果你输入 iOSDevApp，你的自定义 url 就是 iOSDevApp://</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-05.gif" alt="iOS Custom URL Scheme" /></p>

<p>此时，整个定义如下图:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-06.gif" alt="iOS Custom URL Scheme" /></p>

<p>虽然我赞同 Xcode 使用描述性的名字的目的，不过看到创建的实际的 key 也是非常有用的。这里有一个方便的技巧，右键点击 plist 并选择 <em>Show Raw Keys/Values</em>，就能看到以下效果:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-07.png" alt="iOS Custom URL Scheme" /></p>

<p>还有另一种有用的输出格式，XML，因为可以非常容易的看到字典和原始数组及其包括的实体的结构。点击 plist 并选择 <em>Open As &ndash; Source Code</em>:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-08.gif" alt="iPhone Custom URL Scheme" /></p>

<!--more-->


<h2>从 Safari 中调用自定义 URL Scheme</h2>

<p>定义了 URL scheme，我们可以运行一个快速测试来验证应用是否如我们所期望的被调用。在这之前，我创建了一个准 UI 以辨别带有自定义 URL 的应用。该应用只有一个 UILabel，带有文本 &ldquo;App With Custom URL"。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-09.png" alt="iOS App with Custom URL" /></p>

<p>使用模拟器调用应用的步骤:</p>

<ul>
<li>在 Xcode 中运行应用</li>
<li>一旦应用被安装，自定义 URL scheme 就会被注册</li>
<li>通过模拟器的硬件菜单中选择 Home 来关闭应用</li>
<li>启动 Safari</li>
<li>在浏览器地址栏输入之前定义的 URL scheme(如下)</li>
</ul>


<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-10.png" alt="Call Custom URL Scheme from Safari" /></p>

<p>此时 Safari 将会关闭，应用会被带回到前台。祝贺你刚刚使用自定义 URL scheme 调用了一个 iPhone 应用。</p>

<h2>从另一个 iPhone 应用中调用自定义 URL Scheme</h2>

<p>让我们看看如何从另一个应用中调用自定义 URL scheme。我又创建了一个非常简单的 iPhone 应用，它只有一个 UILabel 和一个 UIButton &mdash; 前者显示了一段信息，告诉你这个应用将要通过自定义 URL scheme 来调用另一个应用，按钮则开始这个行为。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-11.png" alt="iPhone app that call Custom URL Scheme" /></p>

<p>buttonPressed 方法中的代码处理 URL 调用:</p>

<p>```objc
&ndash; (void)buttonPressed:(UIButton <em>)button
{
  NSString </em>customURL = @&ldquo;iOSDevTips://&rdquo;;</p>

<p>  if ([[UIApplication sharedApplication]</p>

<pre><code>canOpenURL:[NSURL URLWithString:customURL]])
</code></pre>

<p>  {</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]];
</code></pre>

<p>  }
  else
  {</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"URL error"
                      message:[NSString stringWithFormat:
                        @"No custom URL defined for %@", customURL]
                      delegate:self cancelButtonTitle:@"Ok" 
                      otherButtonTitles:nil];
[alert show];
</code></pre>

<p>  }  <br/>
}
```</p>

<p>第 5 行代码检查自定义 URL 是否被定义，如果定义了，则使用 shared application 实例来打开 URL (第 8 行)。openURL: 方法启动应用并将 URL 传入应用。在此过程中，当前的应用被退出。</p>

<h2>通过自定义 URL Scheme 向应用传递参数</h2>

<p>有时你需要通过自定义 URL 向应用中传递参数。让我们看看该如何完成这个工作。</p>

<p>NSURL 作为从一个应用调用另一个的基础，遵循 <a href="https://tools.ietf.org/html/rfc1808">RFC 1808</a> (Relative Uniform Resource Locators) 标准。 因此你所熟悉的基于网页内容的 URL 格式在这里也适用。</p>

<p>在自定义了 URL scheme 的应用中，app delegate 必须实现以下方法:</p>

<p><code>objc
- (BOOL)application:(UIApplication *)application
  openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
  annotation:(id)annotation
</code></p>

<p>从一个应用传递参数到另一个的诀窍是通过 URL。例如，假设我们使用以下的 URL scheme，想传递一个名为 &ldquo;token"的参数和一个标识注册状态的标志，我们可以像这样创建一个 URL:</p>

<p><code>objc
NSString *customURL = @"iOSDevTips://?token=123abct&amp;registered=1";
</code></p>

<p>在 web 开发中，字符串 <em>?token=123abct&amp;registered=1</em> 被称作查询询串(query string).</p>

<p>在被调用(设置了自定义 URL)的应用的 app delegate 中，获取参数的代码如下:</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application openURL:(NSURL </em>)url</p>

<pre><code>    sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
</code></pre>

<p>{
  NSLog(@&ldquo;Calling Application Bundle ID: %@&rdquo;, sourceApplication);
  NSLog(@&ldquo;URL scheme:%@&rdquo;, [url scheme]);
  NSLog(@&ldquo;URL query: %@&rdquo;, [url query]);</p>

<p>  return YES;
}
```</p>

<p>以上代码在应用被调用时的输出为:</p>

<p><code>
Calling Application Bundle ID: com.3Sixty.CallCustomURL
URL scheme:iOSDevTips
URL query: token=123abct&amp;registered=1
</code></p>

<p>注意 &ldquo;Calling Application Bundle ID"，你可以用这个来确保只有你定义的应用可以与你的应用直接交互。</p>

<p>让我们改变一下代码，来验证发起调用的应用的 Bundle ID 是否合法:</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application openURL:(NSURL </em>)url</p>

<pre><code>    sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
</code></pre>

<p>{
  // Check the calling application Bundle ID
  if ([sourceApplication isEqualToString:@&ldquo;com.3Sixty.CallCustomURL&rdquo;])
  {</p>

<pre><code>NSLog(@"Calling Application Bundle ID: %@", sourceApplication);
NSLog(@"URL scheme:%@", [url scheme]);
NSLog(@"URL query: %@", [url query]);

return YES;
</code></pre>

<p>  }
  else</p>

<pre><code>return NO;
</code></pre>

<p>}
```</p>

<p>有一点要特别注意，你不能阻止其他应用通过自定义 URL scheme 调用你的应用，然而你可以跳过后续的操作并返回 NO，就像上面的代码那样。也就是说，如果你想阻止其它应用调用你的应用，创建一个与众不同的 URL scheme。尽管这不能保证你的应用不会被调用，但至少大大降低了这种可能性。</p>

<h2>自定义 URL Scheme 示例工程</h2>

<p>我意识到按照本文的每一步做下来还是有一点复杂的。我做好了两个非常基础的 iOS 应用，一个自定义了 URL scheme，另一个则去调用它，并传递了一个比较短的参数列表(query string)。这些是体验自定义 URL 的很好的入门点。</p>

<ul>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app with Custom URL scheme</a></li>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app to call custom URL scheme</a></li>
</ul>


<h2>其它资源</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html#//apple_ref/doc/uid/TP40007246">How to Properly Validate URL Parameters</a>
<a href="https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899">URL Scheme Reference Docs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon 来了]]></title>
    <link href="http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon/"/>
    <updated>2014-05-01T22:36:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.cocoanetics.com/2013/11/can-you-smell-the-ibeacon/">Can you Smell the iBeacon?</a>，转载请注明出处。</p>

<p>虽然我们还未看到任何实际生活中的使用案例，但 iBeacon 绝对是 iOS 7 带来的最热门的新话题之一。</p>

<p>上周我收到了我的 <a href="https://preorder.estimote.com/">Developer Preview Kit from Estimote</a>，为了将其收入我正在写作的新书中，我开始研究 iBeacon。下面是我的发现。</p>

<p>为了理解两种操作模式的不同之处，有两个词你应该知道:</p>

<ul>
<li><strong>Monitoring</strong> &ndash; 涉及小功率区域监测，接收 didEnterRegion: 和 didExitRegion: 代理消息。</li>
<li><strong>Ranging</strong> &ndash; 意味着大功率活动，此时你能从各个 iBeacon 收到信号强度并能够估计此刻与它们的距离。</li>
</ul>


<p>iOS 7 之前苹果给我们提供了监测设备将要进入或离开某一个特定区域的能力，其核心是 <code>CLRegion</code>。该技术围绕着地理位置和进入或退出该位置时将要发生的事情。更好的是，如果你在 info.plist 中指定了接收后台位置更新，那么系统可以在区域边界处激活你的应用。</p>

<p>iOS 7 增加了继承自 CLRegion 的 <code>CLBeaconRegion</code>。只要有 iBeacon 被 iOS 检测到，即使信号可能很弱，你就被定义为位于区域之内。这让测试过程令人发疯，因为即使我把我所有的 Estmote beacons 用铝箔包裹起来， iOS 仍然认为我位于该区域内。</p>

<p>一个 iBeacon 通过 3 个值被识别: proximityUUID, Major 和 Minor。第一个是 UUID，后两者是两个 16 位二进制整数。你可以构建 3 个级别的 CLBeaconRegion: 只有 UUID，UUID + Major，UUID + Major + Minor。例如你可能想用一个 UUID 对应整个公司，Major 对应各个店铺。Minor 则可以用来指定每个店铺中的各个货架。</p>

<!--more-->


<h2>做广告吧</h2>

<p>普通的 BTLE (Bluetooth Low Energy) 外设宣传多重服务，iBeacon 不同。iBeacon 自己使用广告信息并且不需要真正的蓝牙链接，因为所有所需信息已存在于 iBeacon 广告中。</p>

<p>以一个简略的例子开始</p>

<p>```objc
@implementation ViewController
{
   CBPeripheralManager *<em>peripheralManager;
   BOOL </em>isAdvertising;
}</p>

<ul>
<li><p>(void)_startAdvertising
{
 NSUUID *estimoteUUID = [[NSUUID alloc] initWithUUIDString:@&ldquo;B9407F30-F5F8-466E-AFF9-25556B57FE6D&rdquo;];</p>

<p> CLBeaconRegion <em>region = [[CLBeaconRegion alloc] initWithProximityUUID:estimoteUUID
                                                                  major:2
                                                                  minor:1
                                                             identifier:@&ldquo;SimEstimote&rdquo;];
 NSDictionary </em>beaconPeripheralData = [region peripheralDataWithMeasuredPower:nil];</p>

<p> [_peripheralManager startAdvertising:beaconPeripheralData];
}</p></li>
<li><p>(void)<em>updateEmitterForDesiredState
{
 if (</em>peripheralManager.state == CBPeripheralManagerStatePoweredOn)
 {
    // only issue commands when powered on</p>

<pre><code>if (_isAdvertising)
{
   if (!_peripheralManager.isAdvertising)
   {
      [self _startAdvertising];
   }
}
else
{
   if (_peripheralManager.isAdvertising)
   {
      [_peripheralManager stopAdvertising];
   }
}
</code></pre>

<p> }
}</p></li>
</ul>


<h1>pragma mark &ndash; CBPeripheralManagerDelegate</h1>

<ul>
<li>(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
{
 [self _updateEmitterForDesiredState];
}</li>
</ul>


<h1>pragma mark &ndash; Actions</h1>

<ul>
<li><p>(IBAction)advertisingSwitch:(UISwitch *)sender
{
 _isAdvertising = sender.isOn;</p>

<p> [self _updateEmitterForDesiredState];
}</p></li>
</ul>


<p>@end
```</p>

<p>这个例子有一个 UISwitch 来切换 soft-beacon。这里有一些陷阱。首先它用了若干毫秒来开启蓝牙系统。只有在蓝牙启动时才能使用 <code>CBPeripheralManager</code>。它一这么做你就会收到 peripheralManagerDidUpdateState: 代理回调，如果蓝牙电源此时处于开启状态，你就可以开始广播 beacon。</p>

<p>停止 iBeacon 要简单的多，只需要一个命令。如果 <code>CBPeripheralManager</code> 电源被关闭，则所有的广告也会停止。当应用进入后台而你又没有告诉 iOS 保持蓝牙服务继续运行时就会导致这种情况发生。没记错的话，所有的服务在应用回到前台时会恢复。</p>

<h2>Estimote</h2>

<p>用何种类型的设备来执行 iBeacon 的功能并无结论，你可以让任何 iOS 设备 (>= iPhone 4S) 和 Mac (>= late 2011) 的蓝牙芯片作为 iBeacon。也有一些硬件公司提供专用的硬件。</p>

<p>Beacon 硬件的初衷是你让你并不需要在墙上粘一个真的 iOS 设备。不是每个人都能在店铺的每一个角落都放上 iPad。标准 iBeacon 硬件的价格是 99 美金 3个。我用这个价格买了 3 个 Estimote beacon。</p>

<p><img src="/images/posts/2014-05-01-can-you-smell-the-ibeacon-01.jpg" alt="Estimote Developer Preview Kit" /></p>

<p>Estimote 提供了非常友好的拆箱体验。除了 3 个不同颜色的 iBeacon，还有 1 个按钮，1 张贴纸，1 张 Estimote CEO 和联合创始人 Jakub Krzych 的名片，还有一些警告信息来告知你这些 beacon 目前是手工组装的因此可能存在固件 bug。</p>

<p>收到 beacon 后你要做的第一件事是下载 Estimote 的演示应用，它可以让你像上文描述的那样尝试 Monitoring 和 Ranging。它还允许你链接各个 Estimote 设备来观察它们的电量，固件版本，以及 UUID， Major 和 Minor 的设置值。</p>

<p>此时我很惊讶的得知 Estimote 使用了"烧入"的 UUID。官方声明说这是有意的设计，用来阻止来自越狱设备的黑客和位置欺骗。</p>

<p>UUID 在应用内很明显，也被公布于几个博客中:</p>

<p><code>
B9407F30-F5F8-466E-AFF9-25556B57FE6D
</code></p>

<p>这也是我上面的例子中使用的 UUID，其实是创建了一个模拟的 Estimote beacon。</p>

<p>Estimote beacon 被完全包裹于橡胶之中因此并没有像 USB 之类的物理硬件接口。所有的设置通过蓝牙和 Estimote 暴露的内部服务来完成。推测未来版本的 <a href="https://github.com/Estimote/iOS-SDK">official Estimote SDK</a> 会针对担心自己 beacon 安全的人推出 UUID 加密方法。</p>

<p>他们还建议你使用他们包装的 Core Location 和 Core Bluetooth 来代替原生的 iOS 方法。对于系统也提供的功能，我个人比较反感使用第三方 SDK。对于你和你的邻居使用相同的 UUID 所造成的潜在问题的最佳解决方案是使用随机的 Major 值结合 UUID 来监测。一旦范围被发现，你要做额外的检查 &mdash; 可能针对于地理位置 &mdash; 是否你确实在你自己的店铺里。</p>

<h2>监测 iBeacon 区域</h2>

<p>如果你已经有了一个 Estimote 或按照上面创建了一个 soft-beacon，下一步就是监测这个区域。下面是一个可行的示例，目的是当你穿过区域边界时，更新文本标签并发出一个本地通知</p>

<p>```objc
@implementation AppDelegate
{
   CLLocationManager *<em>locationManager;
   BOOL </em>isInsideRegion; // flag to prevent duplicate sending of notification
}</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)options
{
 // create a location manager
 _locationManager = [[CLLocationManager alloc] init];</p>

<p> // set delegate, not the angle brackets
 _locationManager.delegate = self;</p>

<p> NSUUID <em>estimoteUUID = [[NSUUID alloc] initWithUUIDString:@&ldquo;B9407F30-F5F8-466E-AFF9-25556B57FE6D&rdquo;];
 CLBeaconRegion </em>region = [[CLBeaconRegion alloc] initWithProximityUUID:estimoteUUID
                                                             identifier:@&ldquo;Estimote Range&rdquo;];</p>

<p> // launch app when display is turned on and inside region
 region.notifyEntryStateOnDisplay = YES;</p>

<p> if ([CLLocationManager isMonitoringAvailableForClass:[CLBeaconRegion class]])
 {
    [_locationManager startMonitoringForRegion:region];</p>

<pre><code>// get status update right away for UI
[_locationManager requestStateForRegion:region];
</code></pre>

<p> }
 else
 {
    NSLog(@&ldquo;This device does not support monitoring beacon regions&rdquo;);
 }</p>

<p>  // Override point for customization after application launch.
  return YES;
}</p></li>
<li><p>(void)<em>sendEnterLocalNotification
{
 if (!</em>isInsideRegion)
 {
    UILocalNotification *notice = [[UILocalNotification alloc] init];</p>

<pre><code>notice.alertBody = @"Inside Estimote beacon region!";
notice.alertAction = @"Open";

[[UIApplication sharedApplication] scheduleLocalNotification:notice];
</code></pre>

<p> }</p>

<p> _isInsideRegion = YES;
}</p></li>
<li><p>(void)<em>sendExitLocalNotification
{
 if (</em>isInsideRegion)
 {
    UILocalNotification *notice = [[UILocalNotification alloc] init];</p>

<pre><code>notice.alertBody = @"Left Estimote beacon region!";
notice.alertAction = @"Open";

[[UIApplication sharedApplication] scheduleLocalNotification:notice];
</code></pre>

<p> }</p>

<p> _isInsideRegion = NO;
}</p></li>
<li><p>(void)_updateUIForState:(CLRegionState)state
{
 ViewController <em>vc = (ViewController </em>)self.window.rootViewController;</p>

<p> if (state == CLRegionStateInside)
 {
    vc.label.text = @&ldquo;Inside&rdquo;;
 }
 else if (state == CLRegionStateOutside)
 {
    vc.label.text = @&ldquo;Outside&rdquo;;
 }
 else
 {
    vc.label.text = @&ldquo;Unknown&rdquo;;
 }
}</p></li>
</ul>


<h1>pragma mark &ndash; CLLocationManagerDelegate</h1>

<ul>
<li><p>(void)locationManager:(CLLocationManager <em>)manager
    didDetermineState:(CLRegionState)state forRegion:(CLRegion </em>)region
{
 // always update UI
 [self _updateUIForState:state];</p>

<p> if ([UIApplication sharedApplication].applicationState == UIApplicationStateActive)
 {
    // don&rsquo;t send any notifications
    return;
 }</p>

<p> if (state == CLRegionStateInside)
 {
    [self <em>sendEnterLocalNotification];
 }
 else
 {
    [self </em>sendExitLocalNotification];
 }
}</p></li>
</ul>


<p>@end
```</p>

<p>本质上，你只是创建了一个 <code>CLBeaconRegion</code> 并让 <code>CLLocationManager</code> 对象去监听它。对于某些设备 beacon 监听会不可用，比如缺少 BT4 芯片，所以你需要通过 <code>isMonitoringAvailableForClass:</code> 来查询。</p>

<p>注意 didDetermineState: 在穿越区域边界时和 requestStateForRegion: 方法后都会被调用。所以你可以在这里做关于监听的工作并实现 didEnterRegion` 和 didExitRegion: 来保证不会过分干扰用户。</p>

<p>剩下的代码用来在应用在后台运行时发送本地通知，并避免对同一状态连续发送多个相同消息。</p>

<p>在我测试时，当我在 iPad 上打开第一个例子中的 soft beacon，我总是会立刻收到 didEnterRegion: 消息。关闭 beacon 后会延迟 43 秒收到 didExit 消息。所以 iOS 在内部做了一些过滤来避免实时触发。</p>

<h2>后台</h2>

<p>你会发现上面的代码在应用在前台运行时运行的非常好，但是当应用进入后台后不会继续发送/监听。</p>

<p>为了在后台监听区域，你需要将 info.plist 中的 &ldquo;Location updates&rdquo; 后台模式开启。"Acts as Bluetooth LE accessory" 则用来使 soft beacon 持久。Xcode 为此提供了很友好的 UI。</p>

<p><img src="/images/posts/2014-05-01-can-you-smell-the-ibeacon-02.png" alt="Enabling iBeacon background modes" /></p>

<p>这里做出的改变最终会体现在 info.plist 文件中的 <code>UIBackgroundModes</code> 下。</p>

<p>增加配件设置要求用户授权蓝牙文件共享。注意用户可能拒绝或者在隐私设置中关闭授权。</p>

<p>集成了兼容 BT4 芯片的 Mac 可以发射 soft-beacon。CoreBluetooth 从 OS X 10.9 开始也可以在 Mac 上使用。2011 年以后生产的 Mac 通常含有该芯片。唯一缺少的是 CLBeaconRegion，不过如果你自己构建用来广播 iBeacon 的字典就可以解决这个问题。至此，你所需要了解的最后一件事是 CoreBluetooth.framework 隐藏在 IOBluetooth.framework 中。</p>

<p><a href="http://twitter.com/mttrb">Matthew Robinson</a> 创建了 <a href="https://github.com/mttrb/BeaconOSX">BeaconOSX sample</a> 来做这件事。</p>

<h2>竞争</h2>

<p>至写作此文时苹果并未发布官方的 iBeancon 规范。当我询问苹果相关负责人，他告诉我当他们发布时会告知我。所以只能寄希望于它们最终会这么做。与此同时，一些聪明人仍旧跑在前面并且<a href="http://developer.radiusnetworks.com/2013/10/01/reverse-engineering-the-ibeacon-profile.html">对 iBeacon 进行逆向工程</a>。</p>

<p>几个 iBeacon 硬件已经面世，Estimote 很快就会感受到来自他们的竞争。我粗略的搜索后发现的其他公司有:</p>

<ul>
<li><strong>RedBearLab</strong> 出售 Arduino 插件板(也叫做 &ldquo;shield&rdquo;)，售价 $29，有一个 <a href="http://redbearlab.com/ibeacon/">iBeacon profile</a></li>
<li><strong>Kontakt.io</strong> 出售运行于可人工替换的普通电池上的 beacon，售价 $99 3个，$149 5个， $279 10个。</li>
<li><strong>GeoHopper</strong> 以 USB 供电的作为 iBeacon 的微型插头: 售价 $39.99 1个，$89.99 3个，192.99 5个。</li>
<li>你还可以[用 Raspberry Pi 和 Bluetooth LE 适配器自己做一个]，设备价值 $40 左右，适配器 $10 左右。</li>
</ul>


<p>以上公司中，Estimote 似乎服务最好。</p>

<p>USB 供电和可更换电池并不是十分必要，低功耗的 BTLE 据说可以维持 2 年。防水橡胶外套和内置的贴纸可以让你很容易的将它粘贴到任何地方而不必害怕它被偷走和损害。</p>

<p>但是竞争从未停止，更多的公司一如既往的进入这个热门领域，下一年的价格一定会降低一半甚至更多。希望 Estimote 在价格上保持竞争力，并且当可以在生产线量产 beacon 的时候进一步降低价格。</p>

<p>只有两个不那么积极的消息。我个人认为自定义 SDK 不应该被当做 USP 使用来锁定用户，并且他们也不打算支持自定义的 UUID，当然也许是出于安全方面的考虑。也许它们最终也会明白过来。目前这些东西可以很容易的工作，"包裹"中其余的东西也非常有价值。</p>

<h2>结论</h2>

<p>没什么能阻止我们将 iBeacon 技术发扬光大，使应用和服务留意用户需求。要是真有什么的话，可能是担心苹果可能会更新仍然保密的 iBeacon 广告包来包含其它值。不过我提到的所有的硬件设备也可以升级来调整广告值。</p>

<p>唯一的问题是想象力的缺乏以及缓慢的卖家和合作方市场的低采用率。iBeacon 承诺会让进入传统的实体商店再次变得有趣。如此一来，任何这种公司会被很好的宣传以快速采用 iBeacon，以此方法将顾客重新勾住和拉回实体店。</p>

<p>小型商店可以在他们用于 POS 系统的 Mac 或 iPad 上运行一个 iBeacon，避免额外话费。这允许基于 Passbook 的优惠券或当靠近收银台时会员卡自动弹出。</p>

<p>你知道有哪些现实生活中 iBeacon 的创新使用? 或者在阅读本文时有新想法？请在评论里让我们知道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精通iCloud文档存储]]></title>
    <link href="http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store/"/>
    <updated>2014-04-25T22:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-10/icloud-document-store.html">Mastering the iCloud Document Store</a>，转载请注明出处。</p>

<p>即便在推出 3 年后，iCloud 文档存储依然是一个充满神秘、误解和抱怨的话题。iCloud 同步经常被批评不可靠且速度慢。虽然在 iCloud 的早期有一些严重的 bug，开发者们还是不得不学习有关文件同步的课程。文件同步事关重大，为应用开发带来了新方向 &mdash; 一个经常被低估的方向，比如进行同步服务相关的合作时，对于处理文件异步更改的需要。</p>

<p>本文会介绍几个创建支持 iCloud 的应用时可能会遇到的一些绊脚石。因为本文只会给出一些粗略的概述，所以如果你对 iCloud 文档存储还不熟悉，我们强烈建议你先阅读 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<!--more-->


<h2>文档存储简介</h2>

<p>iCloud 文档存储的核心思想非常简单: 每个应用都有至少通往一个"魔法文件夹"的入口，该文件夹可以存储文件并且随后在所有注册了同一个 iCloud 帐号的设备间同步。</p>

<p>与其他基于文件系统的同步服务相比，iCloud 文档存储得益于与 OS X 和 iOS 的深度整合。很多系统框架已经被扩展以支持 iCloud。像 <code>NSDocument</code> 和 <code>UIDocument</code> 这样的类被按照可以处理外部变化来进行设计。版本存储和 <code>NSFileVersion</code> 处理同步冲突。Spotlight 被用来提供同步元数据，比如文件传输进度或者云端文档可用性。</p>

<p>写一个简单的基于文档并开启了 iCloud 的 OS X 应用并不需要费多大力气。实际上你并不需要关心任何 iCloud 内部的工作，<code>NSDocument</code> 无偿的做了几乎每件事情: 协调文档的 iCloud 访问，自动观察外部变化，触发下载，处理冲突。它甚至提供了一个简单的 UI 界面来管理云文档。你需要做的所有事情就是创建一个 <code>NSDocument</code> 子类并实现读取和写入文档内容所需要的方法。</p>

<p><img src="/images/posts/2014-04-25-mastering-the-icloud-document-store-01.png" alt="NSDocument provides a simple user interface for managing the synchronized documents of an app." /></p>

<p>然而，一旦脱离预设的路径，你就需要了解的更多。例如，默认打开面板提供的单层文件夹以外的任何操作都需要手动完成。可能你的应用需要管理除了文档内容以外的文档，比如像 Mail，iPhoto 或者 <a href="http://www.ulyssesapp.com/">Ulysses</a> (我们自己的app) 中做的那样。这种时候，你不能依赖于 <code>NSDocument</code>，而需要自己实现它的功能。但为此你需要对 iCloud 提供的锁和通知机制有一个深入的了解。</p>

<p>开发支持 iCloud 的 iOS 应用同样需要更多的工作和知识: 虽然 <code>UIDocument</code> 仍然管理 iCloud 文件访问和处理同步冲突，但缺乏管理文档和文件夹的图形界面。因为性能和存储空间的原因，iOS 也不会自动从云端下载新文档。你需要使用 Spotlight 来检索最近变化的目录并手动触发下载。</p>

<h2>什么是开放性容器 (Ubiquity Container)</h2>

<p>任何符合 App Store 条件的应用都可以使用 iCloud 文档存储。设置正确的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/iCloudFundametals.html#//apple_ref/doc/uid/TP40012094-CH6-SW13">授权</a>后，就获得了一个或多个所谓的"开放性容器"的访问权限。这是苹果用来称呼"一个被 iCloud 管理和同步的目录"的别称。每一个开放性容器限定在一个 app id 内，由此让每个用户在每个应用中有一份共享的存储仓库。有多个应用的开发者可以指定同一个团队的多个 app id，由此可以访问多个容器。</p>

<p><code>NSFileManager</code> 通过 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/URLForUbiquityContainerIdentifier:">URLForUbiquityContainerIdentifier:</a> 提供每一个容器的 URL。在 OS X 系统，可以通过打开 <code>~/Library/Mobile Documents</code> 目录来查看所有可用的开放性容器。</p>

<p><img src="/images/posts/2014-04-25-mastering-the-icloud-document-store-02.png" alt="The contents of ”~/Library/Mobile Documents.“ It contains a separate folder for each ubiquity container of each application." /></p>

<p>通常每个开放性容器有两个并发进程访问。首先，有一个应用呈现和操作容器内的文档。第二，有一个主要通过开放性守护 (Ubiquity Daemon <em>ubd</em>) 体现的 iCloud 架构。iCloud 架构等待应用对文档的更改并将其上传至苹果云服务器。同时也等待从 iCloud 上收到的更改并相应修改容器的内容。</p>

<p>由于两个进程完全独立于彼此工作，因此需某种形式的仲裁来避免资源竞争或丢失容器内的文件更新的问题。应用需要使用名为 <a href="https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileCoordinators/FileCoordinators.html#//apple_ref/doc/uid/TP40010672-CH11-SW1"><em>文件协调 file coordination</em></a> 的概念来确保对于每一个独立文件的访问权。该访问权由 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFileCoordinator_class/Reference/Reference.html"><code>NSFileCoordinator</code></a> 类提供。概括来说，它为每个文件提供了一个简单的 读-写 锁。这个锁由一个通知机制扩展，该机制用于用于改善访问同一个文件的不同进程间的合作。</p>

<p>这个通知机制相比于简单的文件锁来说是有巨大的好处，并且提供了无缝的用户体验。iCloud 可能会在任何时间把文档用一个来自其他设备的新版本覆盖。如果一个应用当前正在显示同一个文档，它必须从磁盘加载新版本并向用户展示更新过的内容。更新过程中，应用可能需要锁住用户界面一段时间并随后在此打开。甚至可能发生更坏的情况: 应用可能保留着未保存的内容，这些内容需要<em>首先</em>保存到磁盘上以便检查同步冲突。最后，在网络条件良好的时候 iCloud 会上传文件最近的版本。因此必须能够要求应用立刻保存所有未保存的变更。</p>

<p>为了实现这个过程，文件协调伴随着另一套名为 <em>文件展示 (file presentation)</em> 的机制。无论什么时候应用打开并向用户展示一个文件，这被称为 <em>展示文档</em>，并且应该注册一个实现了 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html"><code>NSFilePresenter</code></a> 协议的对象。只要另一个进程通过一个文件协调访问文件，文件展示者 (file presenter) 就会收到关于该文件的通知。这些通知被作为方法调用传递，这些方法在展示者指定的一个操作队列(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfp/NSFilePresenter/presentedItemOperationQueue"><code>presentedItemOperationQueue</code></a>)中异步执行。</p>

<p>例如，在任何其他线程被允许开始一个读取操作前，文件展示者被要求保存任何未保存的变化。这些操作通过分发一个 block 到它的展示队列来执行 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a> 方法来完成。展示者需要保存文件并通过执行作为参数传入的 block 来确认通知。除了改变通知，文件展示者还用来通知应用同步冲突。一旦一个文件的冲突版本被下载，一个新的文件版本被加入到版本存储里。所有的展示者通过 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/presentedItemDidGainVersion:"><code>presentedItemDidGainVersion:</code></a> 被通知有一个新版本被创建。该回调接收一个引用了潜在冲突的 <code>NSFileVersion</code> 实例。</p>

<p>文件展示者还可以被用来监视文件夹内容。例如，一旦 iCloud 改变文件夹内容，如创建，删除或者移动文件，应用应该被通知到以便更新它的文档展示。为此，应用可以对展示的目录注册一个实现了 <code>NSFilePresenter</code> 协议的实例。一个目录的文件展示者会收到任何文件夹或其中文件或子文件夹的改变的通知。比如一个文件夹内的文件被修改，展示者会收到一个引用了该文件的 URL 的 <code>presentedSubitemDidChangeAtURL:</code> 通知。</p>

<p>因为带宽和电池寿命在移动设备上更加有限，iOS 不会自动从 iCloud 下载新文件。而是由应用手动决定何时来触发下载新文件到开放性容器中。为了持续告知应用哪些文件可用及其同步状态，iCloud 还会同步开放性容器内的文件元信息。应用可以通过 <code>NSMetadataQuery</code> 或访问 <code>NSURL</code> 的开放资源属性查询这些元信息。无论何时应用想要访问一个文件，它一定会通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 来触发下载行为。</p>

<h2>深入 iCloud</h2>

<p>在继续解释如何实现文件协调和观察之前，现在我们将深入一些过去几年里碰到的一些常见问题。再一次的，确保你已经阅读并理解了 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<p>虽然这些文件机制的描述让它们的使用看起来简单明了，但其实其中有很多隐藏的陷阱。这些陷阱中有些来自于底层框架的 bug。因为 iCloud 同步延伸到操作系统中相当多的层面，人们只能寄希望于苹果能够小心的修复这些 bug。实际上，苹果看起来宁愿废弃坏掉的 API 而不是修复它们。</p>

<p>即便如此，我们的经验告诉我们使用 iCloud 是非常非常容易犯错误的。异步，协作，基于锁特性的文件协调和文件展示互相牵连，并不容易掌握。下面，我们将介绍整合 iCloud 文档同步时的一些主要规则，并以这种形式分享我们的经验。</p>

<h3>只在需要时使用 Presenters</h3>

<p>文件展示者代价高昂。仅当你的应用需要立即应对或干预文件访问的时候，才应该使用它。</p>

<p>如果你的应用正在展示类似文档编辑器这样的东西给用户，文件展示足以胜任。这时，在其他进程写入该文件的时候也许需要锁住编辑器，或者还需要保存未保存的改变。然而，如果只是临时访问并且通知也可能会被延迟处理，就不应该使用文件展示。例如，当创建文件索引或缩略图，查看文件更改日期并使用简单的文件协调可能会更高效。另外，如果你正展示一个字典树的内容，在树的根节点注册 <em>一个</em> 展示者或用 <code>NSMetadataQuery</code> 来延迟获取改变通知会可能会非常高效。</p>

<p>是什么让文件展示代价如此高昂？它需要很多的进程间通信: 每个文件上注册的展示者在其他进程获取文件的访问权时都被要求释放该文件。比如另一个进程尝试读取一个文件，该文件的展示者会被要求保存所有未保存的内容 (<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a>)。它们还会被要求释放文件给读取者(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/relinquishPresentedItemToReader:"><code>relinquishPresentedItemToReader:</code></a>)，例如文件被读取时暂时锁住编辑器。</p>

<p>这些通知每一个都需要分发，加工并由各自的接收者确认。并且因为只有实现的进程知道哪些通知会被处理，所以即使展示者没有实现任何方法，进程间也会为每一个可能的通知进行通信。</p>

<p>另外，每个步骤都需要在读取进程，展示进程和文件协调守护进程 (<code>filecoordinationd</code>) 间的多重上下文的切换。结果就导致了一个简单的文件访问很快就变成耗费资源的操作。</p>

<p>除此之外，如果太多的展示者被注册，文件协调守护进程可能会删除重要的系统资源。对于每一个展示者，都需要打开并监听每一个它所描述的路径上的文件夹。尤其在 OS X Lion 和 iOS 5 上，这些资源是非常稀少的，过度的使用很容易导致文件协调守护进程的锁死或崩溃。</p>

<p>基于这些原因，我们强烈建议不要在目录树的每一个节点上增加文件展示者，只根据需要使用最少的文件展示者。</p>

<h3>只在需要时使用协调</h3>

<p>虽然文件协调要比文件展示节约资源，但它仍然给你的应用和整个系统增加额外的负担。</p>

<p>每当你的应用正在协调一个文件，其他同时想要访问同一个文件的进程可能需要等待。因此你不该在协调文件时执行过于耗时的任务。如果你这么做了，比如存储了大文件，你可以考虑将它存储到一个临时文件夹，随后在协调访问时使用硬连接。注意每一个协调的访问都可能会触发另一个进程上的文件展示者 &mdash; 该展示者可能需要时间在你的访问之前更新文件。始终考虑使用诸如 <code>NSFileCoordinatorReadingWithoutChanges</code> 这样的标识，除非需要读取文件的最新版本。</p>

<p>虽然你的应用的开放性容器可能不会被其他应用访问，过分的文件协调仍然可能成为 iCloud 的一个问题，执行太多的协调请求会造成类似 <code>ubd</code> 的进程的<a href="http://en.wikipedia.org/wiki/Resource_starvation">资源饥饿</a>问题。在应用启动阶段，<code>ubd</code> 似乎会扫描开放性容器内的所有文件。如果你的应用在程序启动阶段也在执行相同的扫描。两个进程会经常冲突，从而可能导致协调的高开销。这时考虑更优化的解决方案是明智的。例如扫描目录内容时，单独的文件内容访问权限是根本不需要的。把协调工作延迟到文件内容真正被展示的时候再进行会是不错的选择。</p>

<p>最后，绝对不要协调一个还没有被下载的文件。文件协调会触发对该文件的下载。不幸的是，协调将会一直等待直到下载完成，这有可能会导致应用被锁住很长一段时间。访问一个文件之前，应用应该先检查文件下载状态。你可以通过查询 URL 的 <code>NSURLUbiquitousItemDownloadingStatusKey</code> 的值或使用 <code>NSMetadataQuery</code> 做到这一点。</p>

<h3>协调方法的几个备注</h3>

<p>阅读 <code>NSFileCoordinator</code> 的文档，你可能注意到每个方法都有一个冗长而复杂的描述。虽然 API 文档通常是非常可靠的，但由于同其他协调器和文件展示者交互的多样性，以及文件夹和文件锁的语法多样性，都造成了很高的复杂度。有一些很容易忽略的细节和问题贯穿这些长长的描述:</p>

<ol>
<li>认真选择协调选项。它们真的对文件协调器和文件展示者有着影响。比如，如果没有采用 <code>NSFileCoordinatorWritingForDeleting</code> 标识，文件展示者将无法通过 <code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 对文件删除操作做出影响。如果移动目录时不使用 <code>NSFileCoordinatorWritingForMoving</code>，则移动操作将不会等待其子项目上正在执行的协调操作进行完成。</li>
<li>始终认为协调调用可能会失败并返回错误。因为文件协调同 iCloud 交互，如果被协调的文件不能被下载，协调调用会失败并产生一条错误信息，并且你实际的文件操作可能不会被执行。如果没有正确的实现错误处理方法，你的应用可能不会注意到这样的问题。</li>
<li>在进入协调 block 之后检查文件状态。协调请求之后，也许很长时间已经过去了。这时，应用操作文件的前提条件可能已经失效。你想写入的信息直到重新获得锁之前有可能都是脏数据。也可能在你等待获得写入权限的时候文件已经被删除。这时你可能会无意中再次创建已经被删除的文件。</li>
</ol>


<h3>通知死锁</h3>

<p>实现 <code>NSFilePresenter</code> 的通知处理方法需要特别注意。类似 <code>relinquishPresentedItemToReader:</code> 这样的通知处理方法必须被确认及告知其他进程该文件已经对访问准备就绪。这一般通过执行作为参数传入通知处理方法的确认 block 来完成。确认 block 被调用之前，其他进程不得不等待，了解这一点是尤为重要的。如果确认因为通知处理的缓慢而被延迟，协调进程也许会被搁置。如果一直没有被执行，则可能会永远被挂起。</p>

<p>不幸的是，需要被确认的通知也会被其他完全独立的通知拖慢。为了确保通知以正确的顺序执行，<code>presentedItemOperationQueue</code> 一般被设置为一个顺序执行队列。但是一个顺序队列就意味着处理速度慢的通知会延缓随后的通知。尤其是它们会延缓需要确认的通知，在那之前，所有的进程都将等待。</p>

<p>例如，假设一个 <code>presentedItemDidChange</code> 通知首先进入队列。该回调漫长的处理过程将会延缓其他随后进入队列的通知，比如 <code>relinquishPresentedItemToReader:</code>。因此，该通知的确认也会被延迟，从而也导致等待它的进程被延缓。</p>

<p>综上所述，在展示队列里的时候 <em>永远不要</em> 执行文件协调。实际上，即使简单的不需要任何确认的通知 (比如 <code>presentedItemDidChange</code>) 也会导致死锁。设想两个文件展示者同时在展示同一个文件。两个展示者都通过执行协调的读取操作来处理 <code>presentedItemDidChange</code> 通知。如果文件发生改变，通知被发送到两个展示者并且二者都在同一个文件上执行协调的读取操作。因此，两个展示者都通过入队一个  <code>relinquishPresentedItemToReader:</code> 请求对方释放文件并等待对方确认。不幸的是，两个展示者无法确认通知，因为它们都因为永久的等待对方确认的协调请求而阻塞了它们的展示队列。我们在 <a href="https://github.com/hydrixos/DeadlockExample">GitHub</a> 上提供了一个小例子展示这种死锁。</p>

<h3>通知缺陷</h3>

<p>从通知中得出正确结论并不容易。文件展示中存在的 bug 造成了有些通知处理器<em>从未被执行</em>。这里初步介绍一些已知的不太规律的通知:</p>

<ol>
<li>除了 <code>presentedSubitemDidChangeAtURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code>，所有的子项目通知要么不被调用，要么以一种难以预测的方式被调用。绝对不要依赖它们 &mdash; 实际上，<code>presentedSubitemDidAppearAtURL:</code> 和 <code>accommodatePresentedSubitemDeletionAtURL:completionHandler:</code> 从不会被调用。</li>
<li>只有通过使用了 <code>NSFileCoordinatorWritingForDeleting</code> 的文件协调来删除文件，<code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 才会工作。否则，你会连一个 change 的通知都收不到。</li>
<li>只有文件展示者执行 <code>itemAtURL:didMoveToURL:</code> 时，<code>presentedItemDidMoveToURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code> 才会被调用。否则项目不会收到任何有用的通知。子项目仍旧会分别针对旧的和新的 URL 收到 <code>presentedSubitemDidChange</code> 通知。</li>
<li>即使文件被正确移动，<code>presentedSubitemAtURL:didMoveToURL:</code> 通知也被发送，你仍然会针对旧的和新的 URL 收到两个额外的 <code>presentedSubitemDidChangeAtURL:</code> 通知。要做好准备好处理这个。</li>
</ol>


<p>一般来说，你必须注意通知可能会失效。也不应该依赖于任何特定的通知顺序。例如，当描述一个目录树时，你不能期望父文件夹的通知会先于或晚于其中子项目的通知。</p>

<h3>注意 URL 变化</h3>

<p>在文件协调和文件展示者传递参照着相同文件的不同的 URL 时，有几种你需要应对的情况。你绝不应该使用 <code>isEqual:</code> 比较 URL，因为两个不同的 URL 可能关联同一个文件。应该始终在比较之前标准化它们。这一点在 iOS 上尤为重要，在 iOS 中开放性容器存储在 <code>/var/mobile/Library/Mobile Documents/</code> 中，这个文件夹是 <code>/private/var/mobile/Library/Mobile Documents/</code> 的符号链接。你会收到带有指向同一个文件，基于 <em>两种路径变体</em> 的 URL 的展示者通知。如果你对 iCloud 和本地文档使用文件协调代码，这个问题在 OS X 上也会发生。</p>

<p>除此之外，还有几个关于大小写不敏感的文件系统的问题。<em>如果</em>文件系统要求，应该始终确保你使用大小写不敏感的文件名比较。文件协调 block 和展示者通知可能传递使用不同大小写的相同的 URL 变体。实际上，这是使用文件协调器重命名时的重要问题。为了搞懂这个问题，你需要回顾文件实际上是如何被重命名的:</p>

<p>```objc
[coordinator coordinateWritingItemAtURL:sourceURL</p>

<pre><code>                            options:NSFileCoordinatorWritingForMoving 
                   writingItemAtURL:destURL 
                            options:0 
                              error:NULL 
                         byAccessor:^(NSURL *oldURL, NSURL *newURL) 
</code></pre>

<p>{</p>

<pre><code>[NSFileManager.defaultManager moveItemAtURL:oldURL toURL:newURL error:NULL];
[coordinator itemAtURL:oldURL didMoveToURL:newURL];
</code></pre>

<p>}];
```</p>

<p>假设 <code>sourceURL</code> 指向一个名为 <code>~/Desktop/my text</code> 的文件，<code>destURL</code> 使用了大写字母的新文件名 <code>~/Desktop/My Text</code>。协调 block 被有意设计成传入两个 URL 的最新版本，以兼容等待文件访问时发生的移动操作。现在，不幸的，当改变文件名的大小写，文件协调所执行的 URL 校验将会发现新旧两个 URL 都存在一个有效文件，而新的 URL 是小写 <code>~/Desktop/my text</code> 的变体。访问 block 将会接收到同样的 <em>小写</em> URL 作为 <code>oldURL</code> 和 <code>newURL</code>，导致移动操作失败。</p>

<h3>请求下载</h3>

<p>在 iOS 中，触发从 iCloud 的下载是应用的责任。可以通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 方法触发下载。如果你的应用设计成自动下载文件 (也就是不由用户触发)，你应该始终在一个顺序后台队列中执行这些下载请求。换句话说，每一个单独的下载请求涉及到相当多的进程间通信并可能会很耗时。另一方面，同时触发太多的下载有时会过载 <em>ubd</em> 守护进程。一个普遍的错误就是使用 <code>NSMetadataQuery</code> 等待 iCloud 中的新文件然后自动触发下载它们。因为查询结果总是在主队列中传递并且可能包含一打的更新信息，直接触发下载会阻塞应用很长一段时间。</p>

<p>为了查询某个文件的下载或者上传状态，你可以使用 <code>NSURL</code> 的资源值。在 iOS 7 / OS X 10.9 之前，一个文件的下载状态通过 <code>NSURLUbiquitousItemIsDownloadedKey</code> 来确认。根据头文件文档，这个资源值从未正确生效过，所以在 iOS 7 和 Mavericks 中被废弃了。现在苹果建议使用 <code>NSURLUbiquitousItemDownloadingStatusKey</code>。在老系统上，你应该使用 <code>NSMetadataQuery</code> 查询 <code>NSMetadataUbiquitousItemIsDownloadedKey</code> 来获得正确的下载状态。</p>

<h2>综合考虑</h2>

<p>为你的应用增加 iCloud 支持并不只是你增加的另一个功能，而是一个对应用设计和实现有着深远影响的决定。它既影响着你的数据模型也影响着 UI。所以不要低估支持 iCloud 所需要做出的努力。</p>

<p>最重要的，增加 iCloud 会引入一个新的异步层。应用必须能够在任何时候处理文档和元数据的变化。这些变化上的通知可能会在不同线程上收到，这就需要在你的整个应用中添加同步机制来对这些通知进行适当的处理。你需要注意那些对于用户文档完整性有重大影响的关键代码中的问题，比如丢失更新，竞争和死锁等。</p>

<p>始终注意 iCloud 的同步保证是非常脆弱的。你只能假设文件和包是自动同步的。但你不能期望多个同时被修改的文件也会被立刻同步。比如，如果你的应用分开存储元信息和实际的文件的话，你一定要能够应对元信息会先于或晚于实际文件被下载的情况。</p>

<p>使用 iCloud 文档同步同时也意味着你正在做一个发布的应用。你的文档会在运行着不同版本的不同设备上。你可能想要使你文件格式的不同版本向前兼容。起码，你必须确保你的应用在面对其他不同设备上安装的新版本应用创建的文件时不会崩溃或发生错误。用户未必会立刻更新所有的设备，所以预先准备好这个问题。</p>

<p>最后，你的 UI 需要反映同步行为。即使这会抹杀掉一些神奇之处。尤其在 iOS 上，连接失败和缓慢的文件转换是现实状况。你的用户应该被通知关于文档的同步状态。你应该考虑展示文件是在被上传还是在下载，以告知用户他们的文档现在是否可用。使用大文件时，你可能需要显示文件传输进度，你的 UI 应该优雅一些; 如果 iCloud 不能及时给你某个文档，你的应用应该响应，并且让用户重试或至少放弃操作。</p>

<h2>调试</h2>

<p>因为涉及到多系统服务和外部服务，调试 iCloud 问题非常困难。Xcode 5 提供的 iCloud 调试功能非常有限并且大多数时候只会告诉你 iCloud 是否已经同步。幸运的是，还有一些差不多是官方的方法来调试 iCloud 文档存储。</p>

<h3>在 OS X 上调试</h3>

<p>有时你可能经历过 iCould 停止同步某个文件或干脆完全停止工作。实际上，这在文件协调器内使用断点或在一个文件操作进行期间杀掉一个进程时很容易发生。甚至如果你的应用在某个关键点崩溃后也会发生。通常来说，重启或者注销后重新登录 iCloud 都不能修复这个问题。</p>

<p>为了修复这些锁定，一个命令行工具会非常有好处: <code>ubcontrol</code>。这个工具是 10.7 以后版本 OS X 的一部分。使用命令 <code>ubcontrol -x</code>，你能够重置文档同步的本地状态。它通过重置一些私有数据库和缓存，重启所有涉及到的系统守护进程，来复原熄火的同步。同时它也会存储一些报告分析信息到 <code>~/Library/Application Support/Ubiquity-backups</code>。</p>

<p>虽然已经有日志文件被写入 <code>~/Library/Logs/Ubiquity</code> 中，你也还可以通过 <code>ubcontrol -k 7</code> 来增加日志级别。在进行 iCloud 相关的错误报告时，苹果工程师经常会要求你这么做以便收集信息。</p>

<p>为了调试文件协调，你还可以从文件协调守护进程中直接取回锁状态信息。这使你能够得知在应用中或多进程间可能遇到的文件协调死锁。为了访问这个信息，你需要在终端中执行以下命令:</p>

<p><code>objc
sudo heap filecoordinationd -addresses NSFileAccessArbiter
sudo lldb -n filecoordinationd
po [&lt;address&gt; valueForKey: @"rootNode"]
</code></p>

<p>第一个命令会返回一个文件协调守护进程的内部单例对象的地址。随后，你关联 <em>lldb</em> 到运行的守护进程上。通过使用第一步取回的地址，你将会得到一个所有活动的锁和文件展示者的状态的概览。调试命令会展示当前正在被展示或协调的整个文件树。例如，如果 TextEdit 正在展示一个名为 <code>example.txt</code> 的文件，你会得到以下跟踪信息:</p>

<p>```
example.txt</p>

<pre><code>&lt;NSFileAccessNode 0x…&gt; parent: 0x…, name: "example.txt"
presenters:
    &lt;NSFilePresenterProxy …&gt; client: TextEdit …&gt;
    location: 0x7f9f4060b940
access claims: &lt;none&gt;
progress subscribers: &lt;none&gt;
progress publishers: &lt;none&gt;
children: &lt;none&gt;****
</code></pre>

<p>```</p>

<p>如果你在文件协调进行时创建这种跟踪 (比如通过在文件协调 block 中设置断点)，你还会得到一个等待文件协调器的所有进程的列表。</p>

<p>如果通过 <em>lldb</em> 观察文件协调，你应该始终记得尽快执行 <code>detach</code> 命令。否则，全局根进程文件协调守护进程将一直等待，这会影响到系统中几乎所有的应用。</p>

<h3>在 iOS 上调试</h3>

<p>在 iOS 上，调试要更加复杂，因为你无法检查运行的系统进程，你也无法使用像 <code>ubcontrol</code> 的命令行工具。</p>

<p>iCloud 锁定在 iOS 上似乎更经常发生。重启应用或设备都无效。唯一有效的修复这种问题的方法是 <em>冷启动</em>。在冷启动过程中，iOS 似乎进行了 iClouds 的内部数据库重置。可以通过同时按下电源键和 home 键 10 秒钟冷启动设备。</p>

<p>为了在 iOS 上激活更详细的日志，在苹果 <a href="https://developer.apple.com/downloads">developer downloads page</a> 有一个专用的 iCloud 日志概述。如果搜索 &ldquo;Bug Reporter Logging Profiles (iOS)"，你将会找到一个叫做 "iCloud Logging Profile&rdquo; 移动设备概述。在你的 iOS 设备上安装该文件来激活更详细的日志。你可以用 iTunes 同步设备来访问这些日志.随后，你可以在 <code>Library/Logs/CrashReporter/Mobile Device/&lt;Device Name&gt;/DiagnosticLogs/Ubiquity</code> 文件夹找到它。如果想要关掉这种加强的日志输出，从设备删除描述文件即可。苹果建议你在激活或关闭概述前重启设备。</p>

<h3>在 iCloud Servers 上调试</h3>

<p>除了在你自己的设备上调试，考虑使用苹果服务上的调试服务可能也会有用。<a href="https://developer.icloud.com/">developer.icloud.com</a> 上有一个特殊的 web 应用，它允许你浏览存储在开放性容器内的所有信息和当前传输状态。</p>

<p>过去的几个月，苹果还提供了安全地在服务端对所有已连接设备进行 iCloud 重置的方法。更多信息可查看 <a href="http://support.apple.com/kb/HT5824">support document</a>。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: objc.io | Migrant]]></title>
  <link href="http://objcio.com/blog/categories/objc-dot-io/atom.xml" rel="self"/>
  <link href="http://objcio.com/"/>
  <updated>2014-03-15T20:39:58+08:00</updated>
  <id>http://objcio.com/</id>
  <author>
    <name><![CDATA[Migrant]]></name>
    <email><![CDATA[tomigrant@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="http://objcio.com/blog/2014/03/10/custom-controls/"/>
    <updated>2014-03-10T10:27:00+08:00</updated>
    <id>http://objcio.com/blog/2014/03/10/custom-controls</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-3/custom-controls.html">Custom Controls</a>，转载请注明出处。</p>

<p>本文将讨论一些自定义视图和控件的诀窍和技巧。我们先对UIKit已经提供给我们的控件做一个概览，介绍一些渲染技巧。随后我们会深入到视图和它们的所有者之间的通信策略，并简略探讨辅助功能，本地化和测试。</p>

<h2>视图层次概览</h2>

<p>看一下UIView的子视图，可以看到3个基本类:响应者，视图和控件。我们快速重温一下它们。</p>

<h3>UIResponder</h3>

<p><code>UIResponder</code>是<code>UIView</code>的父类。响应这能够处理触摸，手势，远程控制等事件。之所以它是一个单独的类而没有合并到<code>UIView</code>中，是因为<code>UIResponder</code>有更多的子类，最明显的就是<code>UIApplication</code>和<code>UIViewController</code>。通过重写<code>UIResponder</code>的方法，可以决定一个类是否可以成为第一响应者(例如当前输入焦点元素)。</p>

<p>当触摸或手势等交互行为发生，它们被发送给第一响应者(通常是一个视图)。如果第一响应者没有处理，则该行为沿着响应者链到达视图控制器，如果行为仍然没有被处理，则它继续传递给应用。如果想检测晃动手势，可以根据需要在这3层中的任意位置处理。</p>

<p><code>UIResponder</code>还允许自定义输入方法，通过<code>inputAccessoryView</code>向键盘添加辅助视图或使用<code>inputView</code>提供一个完全自定义的键盘。</p>

<h3>UIView</h3>

<p><code>UIView</code>的子类处理所有跟内容绘制有关的事情和触摸。只要写过"Hello, World"应用的人都知道视图，但我们重申一些技巧点:</p>

<p>一个普遍的错误概念是视图的区域是由它的frame定义的。实际上frame是一个派生属性，主要由center和bounds合成而来。不使用Auto Layout时，大多数人使用frame来定位改变视图的大小。作为警告，<a href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame">官方文档</a>特别详细说明了一个注意事项:</p>

<blockquote><p>If the transform property is not the identity transform, the value of this property is undefined and therefore should be ignored.</p></blockquote>

<p>另一个允许向视图添加交互的方法是使用手势识别器。注意它们并不工作在响应者上，而只在视图及其子类上工作。</p>

<h3>UIControl</h3>

<p><code>UIControl</code>建立在视图上，增加了更多的交互支持。最重要的是，它增加了target/action模式。看一下具体的子类，可以看到按钮，日期选择器，文本输入框，等等。创建交互控件时，你通常想要子类化一个<code>UIControl</code>。一些常见但并不是控件的类是工具栏按钮(虽然也支持target/action)和文本视图(这里需要你使用代理来获得通知)。</p>

<h2>渲染</h2>

<p>现在，我们接下去来到可见的部分:自定义渲染。正如Daniel在他的<a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html">文章</a>中提到的，你可能想避免在CPU上做渲染而将其丢给GPU。这里有一条经验:尽量避免<code>drawRect:</code>，而使用现有的视图构建自定义视图。</p>

<p>通常最快速的渲染方法是使用图片视图。例如，假设你想画一个带有边框的圆形头像，像下面图片中这样:</p>

<p><img src="/images/posts/2014-03-10-custom-controls.png" alt="" /></p>

<p>为了实现这个，我们用以下的代码创建了一个图片视图的子类:</p>

<p>```objc
// called from initializer
&ndash; (void)setupView
{</p>

<pre><code>self.clipsToBounds = YES;
self.layer.cornerRadius = self.bounds.size.width / 2;
self.layer.borderWidth = 3;
self.layer.borderColor = [UIColor darkGrayColor].CGColor;
</code></pre>

<p>}
```</p>

<p>我鼓励各位读者深入了解<code>CALayer</code>及其属性，因为你用它能实现的大多数事情会比用Core Graphics自己画要快。然而一如既往，剖析自己的代码是十分重要的。</p>

<p>把可拉伸的图片和图片视图一起使用也可以极大的提高效率。在<a href="http://robots.thoughtbot.com/post/33427366406/designing-for-ios-taming-uibutton">Taming UIButton</a>这个帖子中，Reda Lemeden探索了几种不同的绘图方法。在文章结尾处有一个很有价值的帖子:<a href="https://news.ycombinator.com/item?id=4645585">a comment by Andy Matuschak</a>，解释了可拉伸图片是这些技术中最快的。原因是可拉伸图片在CPU和GPU之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。</p>

<p>处理图片时，你也可以让GPU为你工作来代替使用Core Graphics。使用Core Image，你不必用CPU做任何的工作就可以在图片上建立复杂的效果。你可以直接在OpenGL上下文上直接渲染，所有的工作都在GPU上完成。</p>

<h3>自定义绘制</h3>

<p>如果决定了采用自定义绘制，有几种不同的选项可供选择。如果可能的话，看看是否可以生成一张图片并在内存和磁盘上缓存起来。如果内容是动态的，也许你可以使用Core Animation，如果还是行不通，使用Core Graphics。如果你真的想要接近底层，使用GLKit和原生OpenGL也不是那么难，但是需要做很多工作。</p>

<p>如果你真的选择了重写<code>drawRect:</code>，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，并且当视图的frame改变时并不会重新绘制。</p>

<h2>自定义交互</h2>

<p>正如之前所说的，自定义控件的时候，你几乎一定会扩展一个UIControl的子类。在你的子类里，可以使用目标-动作机制触发事件，如下面的例子:</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>为了响应触摸，你可能更倾向于使用手势识别。然而如果想要更接近底层，仍然可以重写<code>touchesBegan</code>，<code>touchesMoved</code>和<code>touchesEnded</code>方法来访问原始的触摸行为。但虽说如此，创建一个手势识别的子类来把手势处理相关的逻辑从你的视图或者视图控制器中分离出来，在很多情况下都是一种更合适的方式。</p>

<p>创建自定义控件时所面对的一个普遍的设计问题是向拥有它们的类中回传返回值。比如，假设你创建了一个绘制交互饼状图的自定义控件，想知道用户何时选择了其中一个部分。你可以用很多种不同的方法来解决这个问题，比如通过目标-动作模式，代理，block或者KVO，甚至通知。</p>

<h3>目标-动作</h3>

<p>老式的，通常也是最方便的方法是使用目标-动作。在用户选择后你可以在自定义的视图中做类似这样的事情:</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>如果有一个视图控制器在管理这个视图，需要:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addTarget:self 
                  action:@selector(updateSelection:)
        forControlEvents:UIControlEventValueChanged];
</code></pre>

<p>}</p>

<ul>
<li>(void)updateSelection:(id)sender
{
  NSLog(@&ldquo;%@&rdquo;, self.pieChart.selectedSector);
}
```</li>
</ul>


<p>这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持。</p>

<h3>代理</h3>

<p>如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。在我们的饼状图中，代码看起来大概是这样:</p>

<p><code>objc
[self.delegate pieChart:self didSelectSector:self.selectedSector];
</code></p>

<p>在视图控制器中，你要写如下代码:</p>

<p>```objc
@interface MyViewController <PieChartDelegate></p>

<p> &hellip;</p>

<ul>
<li><p>(void)setupPieChart
{
  self.pieChart.delegate = self;
}</p></li>
<li><p>(void)pieChart:(PieChart<em>)pieChart didSelectSector:(PieChartSector</em>)sector
{
  // Handle the sector
}
```</p></li>
</ul>


<p>当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。不过虽然大多数开发人员可以非常快速的实现自定义代理，但这种方式仍然有一些缺点:你有必要检查代理是否实现了你想要调用的方法(使用<code>respondsToSelector:</code>)，最重要的，通常你只有一个代理(或者需要创建一个代理数组)。也就是说，一旦视图所有者和视图之间的通信变得稍微复杂，我们几乎总是会采取这种模式。</p>

<h3>Block</h3>

<p>另一个选择是使用block。再一次用饼状图举例，代码看起来大概是这样:</p>

<p>```objc
@interface PieChart : UIControl</p>

<p>@property (nonatomic,copy) void(^selectionHandler)(PieChartSection* selectedSection);</p>

<p>@end
```</p>

<p>在选取行为的代码中，只需要执行它。在此之前检查一下block是否被赋值非常重要，因为执行一个未被赋值的block会使程序崩溃。</p>

<p>```objc
if (self.selectionHandler != NULL) {</p>

<pre><code>self.selectionHandler(self.selectedSection);
</code></pre>

<p>}
```</p>

<p>这种方法的好处是可以把相关的代码在视图控制器中整合:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>self.pieChart.selectionHandler = ^(PieChartSection* section) {
    // Do something with the section
}
</code></pre>

<p>}
```</p>

<p>就像代理，每个动作通常只有一个block。另一个重要的限制是不要形成引用循环。如果你的视图控制器持有饼状图的强引用，饼状图持有block，block又持有视图控制器，就形成了一个引用循环。只要在block中引用self就会造成这个错误。所以通常代码会以这样结束:</p>

<p>```objc
__weak id weakSelf = self;
self.pieChart.selectionHandler = ^(PieChartSection* section) {</p>

<pre><code>MyViewController* strongSelf = weakSelf;
[strongSelf handleSectionChange:section];
</code></pre>

<p>}
```</p>

<p>一旦block中的代码要失去控制(比如block中要处理的事情太多，导致block中的代码过多)，你还可以将它们抽离成独立的方法，而且你可能也已经使用了代理。</p>

<h3>KVO</h3>

<p>如果喜欢KVO，你也可以用它来观察。这有一点神奇而且没那么直接，但当应用中已经使用，它是很好的解耦的设计模式。在饼状图类中，编写代码:</p>

<p><code>objc
self.selectedSegment = theNewSelectedSegment;
</code></p>

<p>当使用合成属性，KVO会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addObserver:self forKeyPath:@"selectedSegment" options:0 context:NULL];
</code></pre>

<p>}</p>

<ul>
<li>(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context
{
  if(object == self.pieChart &amp;&amp; [keyPath isEqualToString:@&ldquo;selectedSegment&rdquo;]) {
      // Handle change
  }
}
```</li>
</ul>


<p>根据你的需要，在<code>viewWillDisappear:</code>或<code>dealloc</code>中，还需要移除观察者。对同一个对象设置多个观察者很容易造成混乱。有一些技术可以解决这个问题，比如<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>或者更轻量级的<a href="https://github.com/th-in-gs/THObserversAndBinders">THObserversAndBinders</a>。</p>

<h3>通知</h3>

<p>作为最后一个选择，如果你想要一个非常松散的耦合，可以使用通知来使其他对象得知变化。对于饼状图来说你几乎肯定不想这样，不过为了讲解的完整，这里介绍如何去做。在饼状图的的头文件中:</p>

<p><code>objc
extern NSString* const SelectedSegmentChangedNotification;
</code></p>

<p>在实现文件中:</p>

<p>```objc
NSString* const SelectedSegmentChangedNotification = @&ldquo;selectedSegmentChangedNotification&rdquo;;</p>

<p>&hellip;</p>

<ul>
<li>(void)notifyAboutChanges
{
  [[NSNotificationCenter defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:self];
}
```</li>
</ul>


<p>现在订阅通知，在视图控制器中：</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self 
                                       selector:@selector(segmentChanged:) 
                                           name:SelectedSegmentChangedNotification
                                          object:self.pieChart];
</code></pre>

<p>}</p>

<p>&hellip;</p>

<ul>
<li>(void)segmentChanged:(NSNotification*)note
{
}
```</li>
</ul>


<p>当添加了观察者，你可以不将饼状图作为参数<code>object</code>，而是传递<code>nil</code>，以接收所有饼状图对象发出的通知。就像KVO通知，你也需要在恰当的地方退订这些通知。</p>

<p>这项技术的好处是完全的解耦。另一方面，你失去了类型安全，因为在回调中你得到的是一个通知对象，而不像代理，编译器无法检查通知发送者和接受者之间的类型是否匹配。</p>

<h2>辅助功能</h2>

<p>苹果官方提供的标准iOS控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。</p>

<p>这或许可以作为一整期的主题，但是如果你编写自定义视图，<a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/iPhoneAccessibility/Accessibility_on_iPhone/Accessibility_on_iPhone.html#//apple_ref/doc/uid/TP40008785-CH100-SW3">Accessibility Programming Guide</a>说明了如何创建控件辅助功能。最为值得注意的是，如果有一个视图中有多个需要辅助功能的元素，但它们并不是该视图的子视图，你可以让视图实现<code>UIAccessibilityContainer</code>协议。对于每一个元素，返回一个描述它的<code>UIAccessibilityElement</code>对象。</p>

<h2>本地化</h2>

<p>创建自定义视图时，本地化也同样重要。如辅助功能一样，这个可以作为一整期的话题。本地化自定义视图的最直接工作就是字符串内容。如果使用<code>NSString</code>，你不必担心编码问题。如果在自定义视图中展示日期或数字，使用日期和数字格式化类来展示它们。使用<code>NSLocalizedString</code>本地化字符串。</p>

<p>另一个本地化过程中很有用的工具是Auto Layout。例如，有在英文中很短的词在德语中可能会很长。如果根据英文单词的长度对视图的尺寸做硬编码，那么当翻译成德文的时候几乎一定会遇上麻烦。通过使用Auto Layout，让标签控件自动调整为内容的尺寸，并向依赖元素添加一些其他的限制以确保重新设置尺寸，使这项工作变得非常简单。苹果为此提供了一个很好的<a href="http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/chapters/InternationalizeYourApp/InternationalizeYourApp/InternationalizeYourApp.html">introduction</a>。另外，对于类似希伯来语这种顺序从右到左的语言，如果你使用了leading和trailing属性，整个视图会自动按照从右到左的顺序展示，而不是硬编码的从左至右。</p>

<h2>测试</h2>

<p>最后，让我们考虑测试视图的问题。对于单元测试，你可以使用Xcode自带的工具或者其它第三方框架。另外，可以使用UIAutomation或者其它基于它的工具。为此，你的视图完全支持辅助功能是必要的。UIAutomation并未充分得到利用的一个功能是截图;你可以用它<a href="http://jeffkreeftmeijer.com/2011/comparing-images-and-creating-image-diffs/">自动对比</a>视图和设计以确保两者每一个像素都分毫不差。(另一个无关的功能:你还可以使用它来为应用<a href="http://www.smallte.ch/blog-read_en_29001.html">自动生成截图</a>，这在你有多个多国语言的应用时特别有用)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础集合类]]></title>
    <link href="http://objcio.com/blog/2014/01/20/the-foundation-collection-classes/"/>
    <updated>2014-01-20T17:41:00+08:00</updated>
    <id>http://objcio.com/blog/2014/01/20/the-foundation-collection-classes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-7/collections.html">The Foundation Collection Classes</a>，转载请注明出处。</p>

<h2>NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个Mac/iOS应用的基本组成部分。在本文中，我们将对"老类"(<code>NSArray</code>, <code>NSSet</code>)和"新类"(<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>)进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示:本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行多个、复杂的测试。这些结果的目的是给出一个快速和主要的运行时统计。所有的测试基于iPhone 5s，使用Xcode 5.1b1和iOS 7.1b1，64位的程序。编译选项设置为-Ofast的发布构建。Vectorize loops和unroll loops(默认设置)均设置为关闭。</p>

<!--more-->


<h2>大O符号</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>描述。它定义了一个函数的 <em>极限特征</em> ，通常被用于描绘其算法效率。O定义了函数增长率的上限。通过查看通常使用的O符号和所需要的操作数来查看差异的大小。</p>

<p><img src="/images/posts/2014-01-20-the-foundation-collection-classes-01.png" alt="" /></p>

<p>例如，如果用算法复杂度为O(n<sup>2</sup>)的算法对一个有50个元素的数组排序，需要2500步的操作。而且，还有内部的系统开销和方法调用 &mdash; 所以是2500个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的算法通常需要O(n*log n)的时间</a>。</p>

<h2>可变性</h2>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性:就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么?<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种突变异常的风险。你的API <em>绝不</em> 应该暴露可变集合。</p>

<p>当然从不可变到可变再变回来会有一定的代价 &mdash; 对象必须被拷贝两次，所有集合内的对象将被retain/release。有时在内部使用一个可变的集合而在出口返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同，苹果没有提供一个线程安全的可变集合，<code>NSCache</code>是例外 &mdash; 但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你的确想要高于集合级别的同步。想象一段代码，作用是检查字典中一个key是否存在，并根据检查结果决定设置一个新的key或者返回某些值 &mdash; 你通常需要把多个操作归类，这时线程安全的可变变体并不能帮助你。</p>

<p>这里有一些同步的，线程安全的可变集合有效的使用案例，只需要用几行代码，通过子类和组合的方法建立诸如<a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a>或<a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些更新式的集合类，如<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，或者某个你想要不常见的可变类的场景。</p>

<h2>NSArray</h2>

<p><code>NSArray</code>作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的<code>[NSArray arrayWithObjects:..., nil]</code>简短得多的快速语法糖符号<code>@[...]</code>。</p>

<p><code>NSArray</code>实现了<code>objectAtIndexedSubscript:</code>，因为我们可以使用类C的语法<code>array[0]</code>来代替原来的<code>[array objectAtIndex:0]</code>。</p>

<h2>性能特征</h2>

<p>关于<code>NSArray</code>的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证O(1)的访问时间 &mdash; 正如你在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h">CFArray.h CoreFoundation header</a>中的关于算法复杂度的注解中可以读到的:</p>

<blockquote><p>The access time for a value in the array is guaranteed to be at worst O(lg N) for any implementation, current and future, but will often be O(1) (constant time). Linear search operations similarly have a worst case complexity of O(Nlg N), though typically the bounds will be tighter, and so on. Insertion or deletion operations will typically be linear in the number of values in the array, but may be O(Nlg N) clearly in the worst case in some implementations. There are no favored positions within the array for performance; that is, it is not necessarily faster to access values with low indices, or to insert or delete values with high indices, or whatever.</p></blockquote>

<p>在测量的时候，<code>NSArray</code>产生了一些<a href="http://ridiculousfish.com/blog/posts/array.html">有趣的额外的性能特征</a>。在数组的开头和结尾插入/删除元素通常是一个O(1)操作，而随机的插入/删除通常是 O(N)的。</p>

<h2>有用的方法</h2>

<p><code>NSArray</code>的大多数方法使用<code>isEqual:</code>来检查对象间的关系(例如<code>containsObject:</code>)。有一个特别的方法<code>indexOfObjectIdenticalTo:</code>用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。</p>

<p>在iOS 7中，我们最终得到了与<code>lastObject</code>对应的公开的<code>firstObject</code>方法，对于空数组，这两个方法都会返回<code>nil</code> &mdash; 而常规的访问方法会抛出一个<code>NSRangeException</code>异常。</p>

<p>关于构造(可变)数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为nil的数组创建一个可变数组，通常会这么写:</p>

<p>```objc
NSMutableArray *mutableObjects = [array mutableCopy];
if (!mutableObjects) {</p>

<pre><code>mutableObjects = [NSMutableArray array];
</code></pre>

<p>}
```</p>

<p>或者通过更简洁的<a href="http://en.wikipedia.org/wiki/%3F:">三元运算符</a>:</p>

<p><code>objc
NSMutableArray *mutableObjects = [array mutableCopy] ?: [NSMutableArray array];
</code></p>

<p>更好的解决方案是使用<code>arrayWithArray:</code>，即使原数组为nil，该方法也会返回一个数组对象:</p>

<p><code>objc
NSMutableArray *mutableObjects = [NSMutableArray arrayWithArray:array];
</code></p>

<p>这两个操作在效率上几乎相等。使用<code>copy</code>会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。<strong>提醒:</strong>不要使用<code>[@[] mutableCopy]</code>。经典的<code>[NSMutableArray array]</code>可读性更好。</p>

<p>翻转一个数组非常简单:<code>array.reverseObjectEnumerator.allObjects</code>。我们使用系统提供的<code>reverseObjectEnumerator</code>，每一个<code>NSEnumerator</code>都实现了<code>allObjects</code>，该方法返回一个新数组。虽然没有原生的<code>randomObjectEnumerator</code>方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用<a href="https://github.com/mattt/TTTRandomizedEnumerator/blob/master/TTTRandomizedEnumerator/TTTRandomizedEnumerator.m">一些出色的开源代码</a>。</p>

<h2>数组排序</h2>

<p>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，<code>sortedArrayUsingSelector:</code>是第一选择:</p>

<p><code>objc
NSArray *array = @[@"John Appleseed", @"Tim Cook", @"Hair Force One", @"Michael Jurewitz"];
NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(localizedCaseInsensitiveCompare:)];
</code></p>

<p>下面的代码对存储数字的内容同样很好，因为<code>NSNumber</code>实现了<code>compare:</code>:</p>

<p><code>objc
NSArray *numbers = @[@9, @5, @11, @3, @1];
NSArray *sortedNumbers = [numbers sortedArrayUsingSelector:@selector(compare:)];
</code></p>

<p>如果想更可控，可以使用基于函数指针的排序方法:</p>

<p>```objc
&ndash; (NSData <em>)sortedArrayHint;
&ndash; (NSArray </em>)sortedArrayUsingFunction:(NSInteger (<em>)(id, id, void </em>))comparator</p>

<pre><code>                          context:(void *)context;
</code></pre>

<ul>
<li>(NSArray <em>)sortedArrayUsingFunction:(NSInteger (</em>)(id, id, void <em>))comparator
                            context:(void </em>)context hint:(NSData *)hint;
```</li>
</ul>


<p>苹果增加了一个方法来加速使用<code>sortedArrayHint</code>的排序。</p>

<blockquote><p>The hinted sort is most efficient when you have a large array (N entries) that you sort once and then change only slightly (P additions and deletions, where P is much smaller than N). You can reuse the work you did in the original sort by conceptually doing a merge sort between the N “old” items and the P “new” items. To obtain an appropriate hint, you use sortedArrayHint when the original array has been sorted, and keep hold of it until you need it (when you want to re-sort the array after it has been modified).</p></blockquote>

<p>因为block的引入，也出现了一些基于block的排序方法:</p>

<p>```objc
&ndash; (NSArray <em>)sortedArrayUsingComparator:(NSComparator)cmptr;
&ndash; (NSArray </em>)sortedArrayWithOptions:(NSSortOptions)opts</p>

<pre><code>                usingComparator:(NSComparator)cmptr;
</code></pre>

<p>```</p>

<p>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于selector的方式是最快的。<a href="https://github.com/steipete/PSTFoundationBenchmark">你可以在GitHub上找到测试用的源代码</a>:</p>

<p><code>
Sorting 1000000 elements. selector: 4947.90[ms] function: 5618.93[ms] block: 5082.98[ms].
</code></p>

<h2>二分查找</h2>

<p><code>NSArray</code>从iOS 4/Snow Leopard开始内置了<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a></p>

<p>```objc
typedef NS_OPTIONS(NSUInteger, NSBinarySearchingOptions) {</p>

<pre><code>    NSBinarySearchingFirstEqual     = (1UL &lt;&lt; 8),
    NSBinarySearchingLastEqual      = (1UL &lt;&lt; 9),
    NSBinarySearchingInsertionIndex = (1UL &lt;&lt; 10),
</code></pre>

<p>};</p>

<ul>
<li>(NSUInteger)indexOfObject:(id)obj
            inSortedRange:(NSRange)r
                  options:(NSBinarySearchingOptions)opts
          usingComparator:(NSComparator)cmp;
```</li>
</ul>


<p>为什么要使用这个方法?类似<code>containsObject:</code>和<code>indexOfObject:</code>这样的方法从0索引开始搜索每个对象直到找到目标 &mdash; 不需要数组被排序而且是O(n)的效率特性。换句话说，二分查找需要数组事先被排序，但只需要O(log n)的时间。因此，对于1,000,000的记录，二分查找法最多只需要21次比较，而传统的线性查找则平均需要5000,000次的比较。</p>

<p>这是个简单的衡量二分查找有多快的数据:</p>

<p><code>
Time to search for 1000 entries within 1000000 objects. Linear: 54130.38[ms]. Binary: 7.62[ms]
</code></p>

<p>作为比较，查找<code>NSOrderedSet</code>中的指定索引花费0.23毫秒 &mdash; 即使跟二分查找相比也快了30多倍。</p>

<p>记住排序的开销也是昂贵的。苹果使用复杂度为O(n*log n)的归并排序，所以如果执行过<code>indexOfObject:</code>一次，就没有必要使用二分查找了。</p>

<p>通过指定<code>NSBinarySearchingInsertionIndex</code>，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>

<h2>枚举和高阶消息</h2>

<p>作为参照，我们来看一个普通的使用场景。从一个数组中过滤出另一个数组。测试了多个枚举方法和API特性:</p>

<p><code>``objc
// First variant, using</code>indexesOfObjectsWithOptions:passingTest:`.
NSIndexSet *indexes = [randomArray indexesOfObjectsWithOptions:NSEnumerationConcurrent</p>

<pre><code>                                               passingTest:^BOOL(id obj, NSUInteger idx, BOOL *stop) {
return testObj(obj);
</code></pre>

<p>}];
NSArray *filteredArray = [randomArray objectsAtIndexes:indexes];</p>

<p>// Filtering using predicates (block-based or text)  <br/>
NSArray <em>filteredArray2 = [randomArray filteredArrayUsingPredicate:[NSPredicate predicateWithBlock:^BOOL(id obj, NSDictionary </em>bindings) {</p>

<pre><code>return testObj(obj);
</code></pre>

<p>}]];</p>

<p>// Block-based enumeration
NSMutableArray <em>mutableArray = [NSMutableArray array];
[randomArray enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}];</p>

<p>// Classic enumeration
NSMutableArray *mutableArray = [NSMutableArray array];
for (id obj in randomArray) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}</p>

<p>// Using NSEnumerator, old school.
NSMutableArray <em>mutableArray = [NSMutableArray array];
NSEnumerator </em>enumerator = [randomArray objectEnumerator];
id obj = nil;
while ((obj = [enumerator nextObject]) != nil) {</p>

<pre><code>if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}</p>

<p>// Using objectAtIndex: (via subscripting)
NSMutableArray *mutableArray = [NSMutableArray array];
for (NSUInteger idx = 0; idx &lt; randomArray.count; idx++) {</p>

<pre><code>id obj = randomArray[idx];
if (testObj(obj)) {
    [mutableArray addObject:obj];
}
</code></pre>

<p>}
```</p>

<!--
Enumeration Method / Time [ms]  | 10.000.000 elements | 10.000 elements
:------------------------------ | ------------------: | --------------:
`indexesOfObjects:`, concurrent |             1844.73 |            2.25
`NSFastEnumeration` (for in)    |             3223.45 |            3.21
`indexesOfObjects:`             |             4221.23 |            3.36
`enumerateObjectsUsingBlock:`    |             5459.43 |            5.43
`objectAtIndex:`                |             5282.67 |            5.53
`NSEnumerator`                  |             5566.92 |            5.75
`filteredArrayUsingPredicate:`  |             6466.95 |            6.31
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Enumeration Method / Time [ms]  </th>
<th align="right"> 10.000.000 elements </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>indexesOfObjects:</code>, concurrent </td>
<td align="right"> 1844.73             </td>
<td align="right">            2.25 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code> (for in)    </td>
<td align="right"> 3223.45             </td>
<td align="right">            3.21 </td>
</tr>
<tr>
<td align="left"> <code>indexesOfObjects:</code>              </td>
<td align="right">             4221.23 </td>
<td align="right">            3.36 </td>
</tr>
<tr>
<td align="left"> <code>enumerateObjectsUsingBlock:</code>    </td>
<td align="right">             5459.43 </td>
<td align="right">            5.43 </td>
</tr>
<tr>
<td align="left"> <code>objectAtIndex:</code>                </td>
<td align="right">             5282.67 </td>
<td align="right">            5.53 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumerator</code>                  </td>
<td align="right">             5566.92 </td>
<td align="right">            5.75 </td>
</tr>
<tr>
<td align="left"> <code>filteredArrayUsingPredicate:</code>  </td>
<td align="right">             6466.95 </td>
<td align="right">            6.31 </td>
</tr>
</tbody>
</table>


<p>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>

<p><code>indexesOfObjectsWithOptions:passingTest:</code>必须每次都执行一次block因此比传统的使用<code>NSFastEnumeration</code>技术的基于for循环的枚举要稍微低效一些。然后如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎2倍。iPhone 5s是双核的，所以这说得通。这里并没有体现出来的是<code>NSEnumerationConcurrent</code>只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至<code>NSEnumerationConcurrent</code>上额外的线程管理实际上会使结果变得更慢。</p>

<p>最大的输家是<code>filteredArrayUsingPredicate:</code>。<code>NSPredicate</code>需要在这里提及是因为，人们可以写出<a href="http://nshipster.com/nspredicate/">非常复杂的表达式</a>，尤其是用不基于block的变体。使用Core Data的用户应该会很熟悉。</p>

<p>为了比较的完整，我们也加入了<code>NSEnumerator</code>作为比较 &mdash; 虽然没有任何理由再使用它了。然而它竟出人意料的快(比基于<code>NSPredicate</code>的查找要快)，它的运行时消耗无疑比快速枚举更多 &mdash; 现在它只用于向后兼容。甚至没有优化过的<code>objectAtIndex:</code>都要更快些。</p>

<h2>NSFastEnumeration</h2>

<p>在OSX 10.5和iOS的最初版本中，苹果增加了<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html"><code>NSFastEnumeration</code></a>。在此之前，只有每次返回一个元素的<code>NSEnumeration</code>，每次迭代都有运行时开销。而快速枚举，苹果通过<code>countByEnumeratingWithState:objects:count:</code>返回一个数据块。该数据块被解析成<code>ids</code>类型的C数组。这就是更快的速度的原因;迭代一个C数组更快，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的<a href="https://developer.apple.com/library/ios/samplecode/FastEnumerationSample/Introduction/Intro.html">FastEnumerationSample</a>是一个不错的开始，还有一篇<a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash的文章</a>也很不错。</p>

<h2>应该用arrayWithCapacity:吗?</h2>

<p>初始化<code>NSArray</code>的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 &mdash; 测量的时间几乎相等，且在统计不确定性的范围内。有消息透漏说实际上苹果并没有使用这个特性。然而使用<code>arrayWithCapacity:</code>仍然有用，在文档不清晰的代码中，它可以帮助理解代码:</p>

<p><code>
Adding 10.000.000 elements to NSArray. no count 1067.35[ms] with count: 1083.13[ms].
</code></p>

<h2>子类化注意事项</h2>

<p>很少有理由去子类化基础集合类。大多数时候，使用CoreFoundation级别的类并且自定义回调函数定制自定义行为是更好的解决方案。</p>

<p>创建一个大小写不敏感的字典，一种方法是子类化<code>NSDictionary</code>并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一个不同的<code>CFDictionaryKeyCallBacks</code>集，你可以提供自定义的<code>hash</code>和<code>isEqual:</code>回调。你可以在<a href="https://gist.github.com/steipete/7739473">这里</a>找到一个例子。这种方法的优美之处(感谢<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridging</a>)在于它仍然是一个简单的字典，可以被任何使用<code>NSDictionary</code>作为参数的API接受。</p>

<p>子类作用的一个例子是有序字典的用例。.NET提供了一个<code>SortedDictionary</code>，Java有<code>TreeMap</code>，C++有<code>std::map</code>。虽然你 <em>可以</em> 使用C++的STL容器，但却无法使它自动的<code>retain/release</code>，这会使使用起来笨重的多。因为<code>NSDictionary</code>是一个<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">类簇</a>，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，<a href="https://github.com/nicklockwood/OrderedDictionary/blob/master/OrderedDictionary/OrderedDictionary.m">这里</a>有一个真实的有序字典的例子。</p>

<h2>NSDictionary</h2>

<p>一个字典存储任意的对象键值对。 由于历史原因，初始化方法使用相反的对象到值的方法，<code>[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]</code>，而新的快捷语法则从key开始，<code>@{key : value, ...}</code>。</p>

<p><code>NSDictionary</code>中的键是被拷贝的并且需要是恒定的。如果在一个键在被用于在字典中放入一个值后被改变，那么这个值可能就会变得无法获取了。一个有趣的细节，在<code>NSDictionary</code>中键是被拷贝的，而在使用一个toll-free桥接的<code>CFDictionary</code>时却只被retain。CoreFoundation类没有通用对象的拷贝方法，因此这时拷贝是不可能的(*)。这只适用于使用<code>CFDictionarySetValue()</code>的时候。如果通过<code>setObject:forKey</code>使用toll-free桥接的<code>CFDictionary</code>，苹果增加了额外处理逻辑来使键被拷贝。反过来这个结论则不成立 &mdash; 转换为<code>CFDictionary</code>的<code>NSDictionary</code>对象，对其使用<code>CFDictionarySetValue()</code>方法会调用回<code>setObject:forKey</code>并拷贝键。</p>

<p>(*)有一个现成的键的回调函数<code>kCFCopyStringDictionaryKeyCallBacks</code>会拷贝字符串，因为<code>CFStringCreateCopy()</code>会调用<code>[NSObject copy]</code>，我们可以使用这个回调来创建一个拷贝键的<code>CFDictionary</code>。</p>

<h2>性能特征</h2>

<p>苹果在定义计算复杂度时显得相当安静。关于它的唯一注释可以在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h"><code>CFDictionary</code>的头文件</a>中找到:</p>

<blockquote><p>The access time for a value in the dictionary is guaranteed to be at worst O(N) for any implementation, current and future, but will often be O(1) (constant time). Insertion or deletion operations will typically be constant time as well, but are O(N*N) in the worst case in some implementations. Access of values through a key is faster than accessing values directly (if there are any such operations). Dictionaries will tend to use significantly more memory than a array with the same number of values.</p></blockquote>

<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>

<h2>枚举和高阶消息</h2>

<p>过滤字典有几个不同的方法:</p>

<p>```objc
// Using keysOfEntriesWithOptions:passingTest:,optionally concurrent
NSSet *matchingKeys = [randomDict keysOfEntriesWithOptions:NSEnumerationConcurrent</p>

<pre><code>                                           passingTest:^BOOL(id key, id obj, BOOL *stop) 
</code></pre>

<p>{</p>

<pre><code>return testObj(obj);
</code></pre>

<p>}];
NSArray <em>keys = matchingKeys.allObjects;
NSArray </em>values = [randomDict objectsForKeys:keys notFoundMarker:NSNull.null];
__unused NSDictionary *filteredDictionary = [NSDictionary dictionaryWithObjects:values</p>

<pre><code>                                                                    forKeys:keys];    
</code></pre>

<p>// Block-based enumeration.
NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];
[randomDict enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL </em>stop) {</p>

<pre><code>if (testObj(obj)) {
    mutableDictionary[key] = obj;
}
</code></pre>

<p>}];</p>

<p>// NSFastEnumeration
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
for (id key in randomDict) {</p>

<pre><code>id obj = randomDict[key];
if (testObj(obj)) {
    mutableDictionary[key] = obj;
}
</code></pre>

<p>}</p>

<p> // NSEnumeration
 NSMutableDictionary <em>mutableDictionary = [NSMutableDictionary dictionary];
 NSEnumerator </em>enumerator = [randomDict keyEnumerator];
 id key = nil;
 while ((key = [enumerator nextObject]) != nil) {</p>

<pre><code>   id obj = randomDict[key];
   if (testObj(obj)) {
       mutableDictionary[key] = obj;
   }
</code></pre>

<p> }</p>

<p>// C-based array enumeration via getObjects:andKeys:
NSMutableDictionary *mutableDictionary = [NSMutableDictionary dictionary];
id <strong>unsafe_unretained objects[numberOfEntries];
id </strong>unsafe_unretained keys[numberOfEntries];
[randomDict getObjects:objects andKeys:keys];
for (int i = 0; i &lt; numberOfEntries; i++) {</p>

<pre><code>id obj = objects[i];
id key = keys[i];
if (testObj(obj)) {
   mutableDictionary[key] = obj;
}
</code></pre>

<p> }
```</p>

<!--
Filtering/Enumeration Method / Time [ms] | 50.000 elements | 1.000.000 elements
:--------------------------------------- | --------------: | -----------------:
`keysOfEntriesWithOptions:`, concurrent  |           16.65 |             425.24
`getObjects:andKeys:`                    |           30.33 |            798.49*
`keysOfEntriesWithOptions:`              |           30.59 |             856.93
`enumerateKeysAndObjectsUsingBlock:`     |           36.33 |             882.93
`NSFastEnumeration`                      |           41.20 |            1043.42
`NSEnumeration`                          |           42.21 |            1113.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Filtering/Enumeration Method / Time [ms] </th>
<th align="right"> 50.000 elements </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>, concurrent  </td>
<td align="right">           16.65 </td>
<td align="right">             425.24 </td>
</tr>
<tr>
<td align="left"> <code>getObjects:andKeys:</code>                    </td>
<td align="right">           30.33 </td>
<td align="right">            798.49* </td>
</tr>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>              </td>
<td align="right">           30.59 </td>
<td align="right">             856.93 </td>
</tr>
<tr>
<td align="left"> <code>enumerateKeysAndObjectsUsingBlock:</code>     </td>
<td align="right">           36.33 </td>
<td align="right">             882.93 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code>                      </td>
<td align="right">           41.20 </td>
<td align="right">            1043.42 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumeration</code>                          </td>
<td align="right">           42.21 </td>
<td align="right">            1113.08 </td>
</tr>
</tbody>
</table>


<p>(*)使用<code>getObjects:andKeys:</code>时需要注意。在上面的代码例子中，我们使用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">可变长度数组</a>的C99特性(通常，数组的数量需要是一个固定值)。在栈上分配了内存，虽然有限但是更方便一点。上面的代码在有数量较大的元素的时候会崩溃掉，所以使用基于<code>malloc/calloc</code>的分配(和<code>free</code>)以确保安全。</p>

<p>为什么这次<code>NSFastEnumeration</code>这么慢?迭代字典通常需要键和值;快速枚举只能枚举键，我们必须每次都自己获取值。使用基于block的<code>enumerateKeysAndObjectsUsingBlock:</code>更高效，因为值可以更高效的被提前获取。</p>

<p>这个测试的胜利者又是并发迭代<code>keysOfEntriesWithOptions:passingTest:</code>和<code>objectsForKeys:notFoundMarker:</code>。代码稍微多了一点，但是可以用category进行漂亮的封装。</p>

<h2>应该用dictionaryWithCapacity:吗?</h2>

<p>到现在你应该已经知道该如何测试了，简单的回答是<strong>不</strong>，<code>count</code>参数没有改变任何事情:</p>

<p><code>
Adding 10000000 elements to NSDictionary. no count 10786.60[ms] with count: 10798.40[ms].
</code></p>

<h2>排序</h2>

<p>关于字典排序没有太多可说的。你只能将键排序为一个新对象，因此你可以使用任何正规的<code>NSArray</code>的排序方法:</p>

<p>```objc
&ndash; (NSArray <em>)keysSortedByValueUsingSelector:(SEL)comparator;
&ndash; (NSArray </em>)keysSortedByValueUsingComparator:(NSComparator)cmptr;
&ndash; (NSArray *)keysSortedByValueWithOptions:(NSSortOptions)opts</p>

<pre><code>                      usingComparator:(NSComparator)cmptr;
</code></pre>

<p>```</p>

<h2>共享键</h2>

<p>从iOS 6和OS X 10.8开始，字典可以使用一个事先生成好的键集，使用<code>sharedKeySetForKeys:</code>从一个数组中创建键集，用<code>dictionaryWithSharedKeySet:</code>创建字典。共享键集会复用对象，以节省内存。根据<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-FoundationOlderNotes/">Foundation Release Notes</a>，<code>sharedKeySetForKeys:</code>中会计算一个最小最完美的哈希值，这个哈希值丢弃了字典查找过程中探索循环的需要，因此使键的访问更快。</p>

<p>这在JSON解析的时候是完美的使用场景，虽然在我们有限的测试中无法看到苹果在<code>NSJSONSerialization</code>中使用。(使用共享键集创建的字典是<code>NSSharedKeyDictionary</code>的子类;标准的字典是<code>__NSDictionaryI</code>/<code>__NSDictionaryM</code>，I/M表明可变性;toll-free桥接的字典是<code>_NSCFDictionary</code>类，既是可变也是不可变的。)</p>

<p><strong>有趣的细节</strong>:共享键字典<strong>始终是可变的</strong>，即使对它们执行了"copy"命令后。这个行为文档中并没有说明，但很容易被测试:</p>

<p><code>objc
id sharedKeySet = [NSDictionary sharedKeySetForKeys:@[@1, @2, @3]]; // returns NSSharedKeySet
NSMutableDictionary *test = [NSMutableDictionary dictionaryWithSharedKeySet:sharedKeySet];
test[@4] = @"First element (not in the shared key set, but will work as well)";
NSDictionary *immutable = [test copy];
NSParameterAssert(immutable == 1);
((NSMutableDictionary *)immutable)[@5] = @"Adding objects to an immutable collection should throw an exception.";
NSParameterAssert(immutable == 2);
</code></p>

<h2>NSSet</h2>

<p><code>NSSet</code>和它的可变变体<code>NSMutableSet</code>是无序对象集合。检查一个对象是否存在通常是一个O(1)的操作，使得比<code>NSArray</code>快很多。<code>NSSet</code>只在被使用的哈希方法平衡的情况下能高效的工作;如果所有的对象都在同一个哈希筐内，<code>NSSet</code>在查找对象是否存在时并不比<code>NSArray</code>快多少。</p>

<p><code>NSSet</code>还有变体<code>NSCountedSet</code>，non-toll-free计数变体<code>CFBag</code>/<code>CFMutableBag</code>。</p>

<p><code>NSSet</code>会retain它其中的对象，但是根据set的规定，对象应该是不可变的。添加一个对象到set中随后改变它会导致一些奇怪的问题并破坏set的状态。</p>

<p><code>NSSet</code>的方法比<code>NSArray</code>少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有<code>allObjects</code>，将对象转化为<code>NSArray</code>，<code>anyObject</code>则返回任意的对象，如果set为空，则返回nil。</p>

<h2>Set操作</h2>

<p><code>NSMutableSet</code>有几个很强大的方法，例如<code>intersectSet:</code>，<code>minusSet:</code>和<code>unionSet:</code>。</p>

<p><img src="/images/posts/2014-01-20-the-foundation-collection-classes-02.png" alt="" /></p>

<h2>应该用setWithCapacity:吗?</h2>

<p>我们再一次测试当创建set时给定容量大小是否会有显著的速度差异:</p>

<p><code>
Adding 1.000.000 elements to NSSet. no count 2928.49[ms] with count: 2947.52[ms].
</code></p>

<p>在统计不确定性的前提下，结果没有显著差异。有一份证据表明<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">至少在上一运行时版本中，有很多的性能上的影响</a>。</p>

<h2>NSSet性能特征</h2>

<p>苹果在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFSet.h">CFSet头文件</a>中没有提供任何关于算法复杂度的注释:</p>

<!--
Class / Time [ms]               | 1.000.000 elements
:------------------------------ | -----------------:
`NSMutableSet`, adding          |            2504.38
`NSMutableArray`, adding        |            1413.38
`NSMutableSet`, random access   |               4.40
`NSMutableArray`, random access |               7.95
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding          </td>
<td align="right">            2504.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">            1413.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access   </td>
<td align="right">               4.40 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">               7.95 </td>
</tr>
</tbody>
</table>


<p>这个检测非常符合我们的预期:<code>NSSet</code>在每一个被添加的对象上执行<code>hash</code>和<code>isEqual:</code>方法并管理一个哈希筐，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是<code>anyObject</code>。</p>

<p>这里没有必要包含<code>containsObject:</code>的测试，set要快几个数量级，毕竟这是它的特点。</p>

<h2>NSOrderedSet</h2>

<p><code>NSOrderedSet</code>在iOS 5和Mac OS X 10.7中第一次被引入，除了CoreData，几乎没有直接使用它的API。看上去它综合了<code>NSArray</code>和<code>NSSet</code>两者的好处，对象查找，对象唯一性，和快速随机访问。</p>

<p><code>NSOrderedSet</code>有着优秀的API方法，使得它可以很便利的与其他set或者有序set对象合作。合并，交集，差集，就像<code>NSSet</code>支持的那样。它有<code>NSArray</code>中的大多数排序方法，除了比较陈旧的基于函数的排序方法和二分查找。毕竟<code>containsObject:</code>非常快，所以没有必要再用二分查找了。</p>

<p><code>array</code>和<code>set</code>方法分别返回一个<code>NSArray</code>和<code>NSSet</code>，但是。这些对象表面上是对象，像不可变对象那样，在有序set被更新的时候，它们会更新自己。当你打算在多个线程上迭代这些对象并发生了突变异常的时候，了解这一点是有好处的。本质上，这些类使用的是<code>__NSOrderedSetSetProxy</code>和<code>__NSOrderedSetArrayProxy</code>。</p>

<p>附注:如果你想知道为什么<code>NSOrderedSet</code>不是<code>NSSet</code>的子类，<a href="http://nshipster.com/nsorderedset/">NSHipster上有一篇非常好的文章解释了可变/不可变类簇的缺点</a>。</p>

<h2>NSOrderedSet性能特征</h2>

<p>如果你看到这份测试，你会看到<code>NSOrderedSet</code>代价高昂，天下没有免费的午餐:</p>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMutableOrderedSet`, adding        |            3190.52
`NSMutableSet`, adding               |            2511.96
`NSMutableArray`, adding             |            1423.26
`NSMutableOrderedSet`, random access |              10.74
`NSMutableSet`, random access        |               4.47
`NSMutableArray`, random access      |               8.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, adding        </td>
<td align="right">            3190.52 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding               </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding             </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, random access </td>
<td align="right">              10.74 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access        </td>
<td align="right">               4.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access      </td>
<td align="right">               8.08 </td>
</tr>
</tbody>
</table>


<p>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>

<p><code>NSOrderedSet</code>比<code>NSSet</code>和<code>NSArray</code>占用更多的内存，因为它需要一起维护哈希值和索引。</p>

<h2>NSHashTable</h2>

<p><code>NSHashTable</code>效仿了<code>NSSet</code>，但在对象/内存处理时更加的灵活。可以通过自定义<code>CFSet</code>的回调获得<code>NSHashTable</code>的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除 &mdash; 一些手动添加到<code>NSSet</code>的时候非常恶心的事情。它是默认可变的 &mdash; 没有相应的不可变类。</p>

<p><code>NSHashTable</code>有ObjC和原始的C API，C API可以用来存储任意对象。苹果在10.5 Leopard系统中引入了这个类，但是直到最近的iOS 6中才被加入。足够有趣的是它们只移植了 ObjC API;更多强大的C API没有包括在iOS中。</p>

<p><code>NSHashTable</code>可以通过<code>initWithPointerFunctions:capacity:</code>进行大量的设置 &mdash; 我们只选取使用<code>hashTableWithOptions:</code>最普遍的使用场景。最有用的选项有它自己的方便的构造函数<code>weakObjectsHashTable</code>。</p>

<h2>NSPointerFunctions</h2>

<p>这些指针函数可以被用在<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>中，定义了对存储在这个集合中的对象的获取和保留行为。这里是最有用的选项。完整列表参见<code>NSPointerFunctions.h</code>。</p>

<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>

<p><code>NSPointerFunctionsStrongMemory</code>创建了一个retain/release对象的集合，非常像常规的<code>NSSet</code>或<code>NSArray</code>。</p>

<p><code>NSPointerFunctionsWeakMemory</code>使用等价的<code>__weak</code>来存储对象并自动移除被销毁的对象。</p>

<p><code>NSPointerFunctionsCopyIn</code>在对象被加入到集合前拷贝它们。</p>

<p><code>NSPointerFunctionsObjectPersonality</code>使用对象的<code>hash</code>和<code>isEqual:</code>(默认)。</p>

<p><code>NSPointerFunctionsObjectPointerPersonality</code>对于<code>isEqual:</code>和<code>hash</code>使用直接的指针比较。</p>

<h2>NSHashTable性能特征</h2>

<!--
Class / Time [ms]                 | 1.000.000 elements
:-------------------------------- | -----------------:
`NSHashTable`, adding             |            2511.96
`NSMutableSet`, adding            |            1423.26
`NSHashTable`, random access      |               3.13
`NSMutableSet`, random access     |               4.39
`NSHashTable`, containsObject     |               6.56
`NSMutableSet`, containsObject    |               6.77
`NSHashTable`, NSFastEnumeration  |              39.03
`NSMutableSet`, NSFastEnumeration |              30.43
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                 </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSHashTable</code>, adding             </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding            </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, random access      </td>
<td align="right">               3.13 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access     </td>
<td align="right">               4.39 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, containsObject     </td>
<td align="right">               6.56 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, containsObject    </td>
<td align="right">               6.77 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, NSFastEnumeration  </td>
<td align="right">              39.03 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, NSFastEnumeration </td>
<td align="right">              30.43 </td>
</tr>
</tbody>
</table>


<p>如果你只是需要<code>NSSet</code>的特性，请坚持使用<code>NSSet</code>。<code>NSHashTable</code>在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>

<h2>NSMapTable</h2>

<p><code>NSMapTable</code>和<code>NSHashTable</code>相似，但是效仿的是<code>NSDictionary</code>。因此，我们可以通过<code>mapTableWithKeyOptions:valueOptions:</code>分别控制键和值的对象获取/保留行为。存储弱引用是<code>NSMapTable</code>最有用的特性，这里有4个方便的构造函数:</p>

<ul>
<li><code>strongToStrongObjectsMapTable</code></li>
<li><code>weakToStrongObjectsMapTable</code></li>
<li><code>strongToWeakObjectsMapTable</code></li>
<li><code>weakToWeakObjectsMapTable</code></li>
</ul>


<p>注意，除了使用<code>NSPointerFunctionsCopyIn</code>，任何的默认行为都会retain(或弱引用)键对象而不会拷贝它，与<code>CFDictionary</code>的行为相同而与<code>NSDictionary</code>不同。当你需要一个字典，它的键没有实现<code>NSCopying</code>协议，比如<code>UIView</code>，的时候非常有用。</p>

<p>如果你好奇为什么苹果"忘记"为<code>NSMapTable</code>增加下标，你现在知道了。下标访问需要一个<code>id&lt;NSCopying&gt;</code>作为key，对<code>NSMapTable</code>来说这不是强制的。如果不通过一个非法的API协议或者移除<code>NSCopying</code>协议来削弱全局下标，是没有办法给它增加下标的。</p>

<p>你可以通过<code>dictionaryRepresentation</code>把内容转换为普通的<code>NSDictionary</code>。不像<code>NSOrderedSet</code>，这个方法返回一个常规的字典而不是一个代理。</p>

<h2>NSMapTable性能特征</h2>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMapTable`, adding                 |            2958.48
`NSMutableDictionary`, adding        |            2522.47
`NSMapTable`, random access          |              13.25
`NSMutableDictionary`, random access |               9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMapTable</code>, adding                 </td>
<td align="right">            2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding        </td>
<td align="right">            2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMapTable</code>, random access          </td>
<td align="right">              13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access </td>
<td align="right">               9.18 </td>
</tr>
</tbody>
</table>


<p><code>NSMapTable</code>只比<code>NSDictionary</code>略微慢一点。如果你需要一个不retain键的字典，放弃<code>CFDictionary</code>使用它吧。</p>

<h2>NSPointerArray</h2>

<p><code>NSPointerArray</code>类是一个稀疏数组，工作起来与<code>NSMutableArray</code>相似，但可以存储<code>NULL</code>值，并且<code>count</code>方法会反应这些空点。可以用<code>NSPointerFunctions</code>对其进行各种设置，也有应对常见的使用场景的快捷构造函数<code>strongObjectsPointerArray</code>和<code>weakObjectsPointerArray</code>。</p>

<p>在能使用<code>insertPointer:atIndex:</code>之前，我们需要通过直接设置<code>count</code>属性来申请空间，否则会产生一个异常。另一种选择是使用<code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>

<p>你可以通过<code>allObjects</code>将一个<code>NSPointerArray</code>转换成常规的<code>NSArray</code>。这时所有的<code>NULL</code>值会被去掉，只有真正存在的对象被加入到数组 &mdash; 因此数组的对象索引很有可能会跟指针数组的不同。注意:如果向指针数组中存入任何非对象的东西，试图执行<code>allObjects</code>都会造成<code>EXC_BAD_ACCESS</code>崩溃，因为它会一个一个的retain"对象"。</p>

<p>从调试的角度讲，<code>NSPointerArray</code>没有受到太多欢迎。<code>description</code>方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行<code>[pointerArray allObjects]</code>，当然，如果存在<code>NULL</code>的话会改变索引。</p>

<h2>NSPointerArray性能特征</h2>

<p>在性能方面，<code>NSPointerArray</code>真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用<code>NSNull</code>作为空标记的<code>NSMutableArray</code>和使用了<code>NSPointerFunctionsStrongMemory</code>设置的<code>NSPointerArray</code>(这样对象会被适当的retain)。在一个有10,000个元素的数组中，我们每隔十个插入一个字符串"Entry %d"。此测试包括了用<code>NSNull</code>作为<code>null</code>填充的<code>NSMutableArray</code>。对于<code>NSPointerArray</code>，我们使用<code>setCount:</code>来代替:</p>

<!--
Class / Time [ms]               | 10.000 elements
:------------------------------ | --------------:
`NSMutableArray`, adding        |         2958.48
`NSPointerArray`, adding        |         2522.47
`NSMutableArray`, random access |           13.25
`NSPointerArray`, random access |            9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">         2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, adding        </td>
<td align="right">         2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">           13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, random access </td>
<td align="right">            9.18 </td>
</tr>
</tbody>
</table>


<p>注意<code>NSPointerArray</code>需要的时间比<code>NSMutableArray</code>多了超过<strong>250x (!) </strong>。这非常奇怪和意外。跟踪内存比较困难，似乎<code>NSPointerArray</code>更高效，但是因为我们使用同一个<code>NSNull</code>标记空对象，所以除了指针不该有更多的消耗。</p>

<h2>NSCache</h2>

<p><code>NSCache</code>是一个非常奇怪的集合。在iOS 4/Snow Leopard中加入，默认为可变并且<strong>线程安全</strong>的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的"成本"清理自己。与<code>NSDictionary</code>相比，键是被retain而不是被拷贝的。</p>

<p><code>NSCache</code>的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样比被回收更快填满内存的大对象不是个好主意。(这是在<a href="http://pspdfkit.com/">PSPDFKit</a>中很多跟内存有关的crash的原因，在使用自定义的基于LRU的链表的缓存代码之前，我们起初使用<code>NSCache</code>存储事先渲染的图片。)</p>

<p><code>NSCache</code>可以设置撑自动回收实现了<code>NSDiscardableContent</code>协议的对象。实现该属性的一个比较流行的类是同时间加入的<code>NSPurgeableData</code>，但是<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">在OS X 10.9之前，是非线程安全的(没有信息表明这是否也影响到iOS或者是否在iOS 7中被修复了)</a>。</p>

<h2>NSCache性能</h2>

<p>那么<code>NSCache</code>如何承受<code>NSMutableDictionary</code>的考验?加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类(<a href="https://gist.github.com/steipete/5928916">PSPDFThreadSafeMutableDictionary</a>)，它通过<code>OSSpinLock</code>实现同步的访问。</p>

<!--
Class / Time [ms]                                 | 1.000.000 elements | iOS 7x64 Simulator | iPad Mini iOS 6
:------------------------------------------------ | -----------------: | -----------------: | --------------:
`NSMutableDictionary`, adding                     |             195.35 |              51.90 |          921.02
`PSPDFThreadSafeMutableDictionary`, adding        |             248.95 |              57.03 |         1043.79
`NSCache`, adding                                 |             557.68 |             395.92 |         1754.59
`NSMutableDictionary`, random access              |               6.82 |               2.31 |           23.70
`PSPDFThreadSafeMutableDictionary`, random access |               9.09 |               2.80 |           32.33
`NSCache`, random access                          |               9.01 |          **29.06** |           53.25
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                                 </th>
<th align="right"> 1.000.000 elements </th>
<th align="right"> iOS 7x64 Simulator </th>
<th align="right"> iPad Mini iOS 6 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding                     </td>
<td align="right">             195.35 </td>
<td align="right">              51.90 </td>
<td align="right">          921.02 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, adding        </td>
<td align="right">             248.95 </td>
<td align="right">              57.03 </td>
<td align="right">         1043.79 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, adding                                 </td>
<td align="right">             557.68 </td>
<td align="right">             395.92 </td>
<td align="right">         1754.59 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access              </td>
<td align="right">               6.82 </td>
<td align="right">               2.31 </td>
<td align="right">           23.70 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, random access </td>
<td align="right">               9.09 </td>
<td align="right">               2.80 </td>
<td align="right">           32.33 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, random access                          </td>
<td align="right">               9.01 </td>
<td align="right">          <strong>29.06</strong> </td>
<td align="right">           53.25 </td>
</tr>
</tbody>
</table>


<p><code>NSCache</code>表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为<code>NSCache</code>维持着一个可选的决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎10倍。无论对32或64位的系统都是。而且看起来已经在iOS 7中优化过并且受益于64位运行时环境。当在老的设备上测试时，使用<code>NSCache</code>的性能消耗尤为明显。</p>

<p>iOS 6(32 bit)和iOS 7(64 bit)的区别也很明显，因为64位运行时使用<a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">标签指针</a>，因此我们的<code>@(idx)</code>封装要更为高效。</p>

<h2>NSIndexSet</h2>

<p>有些使用场景下<code>NSIndexSet</code>(和它的可变变体，<code>NSMutableIndexSet</code>)真的非常出色，对它的使用贯穿在Foundation中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如set这个名字已经暗示的那样，每一个<code>NSUInteger</code>要么在索引set中要么不在。如果你需要存储任意唯一的整数，最好使用<code>NSArray</code>。</p>

<p>如何把一个整数数组转换伟<code>NSIndexSet</code>:</p>

<p>```objc
NSIndexSet <em>PSPDFIndexSetFromArray(NSArray </em>array) {</p>

<pre><code>NSMutableIndexSet *indexSet = [NSMutableIndexSet indexSet];
for (NSNumber *number in array) {
    [indexSet addIndex:[number unsignedIntegerValue]];
}
return [indexSet copy];
</code></pre>

<p>}
```</p>

<p>如果不使用block，从索引set中拿到所有的索引有点麻烦，<code>getIndexes:maxCount:inIndexRange:</code>是最快的方法，其次是使用<code>firstIndex</code>并迭代直到<code>indexGreaterThanIndex:</code>返回<code>NSNotFound</code>。随着block的到来，使用<code>NSIndexSet</code>工作变得方便的多:</p>

<p>```objc
NSArray <em>PSPDFArrayFromIndexSet(NSIndexSet </em>indexSet) {</p>

<pre><code>NSMutableArray *indexesArray = [NSMutableArray arrayWithCapacity:indexSet.count];
[indexSet enumerateIndexesUsingBlock:^(NSUInteger idx, BOOL *stop) {
   [indexesArray addObject:@(idx)];
}];
return [indexesArray copy];
</code></pre>

<p>}
```</p>

<h2>NSIndexSet性能</h2>

<p>Core Foundation中没有和<code>NSIndexSet</code>相当的类，苹果也没有对性能做出任何承诺。<code>NSIndexSet</code>和<code>NSSet</code>之间的比较也相对的不公平，因为常规的set需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的<code>NSUintegers</code>，并且在两个循环中都会执行<code>unsignedIntegerValue</code>:</p>

<!--
Class / Time [ms]           | #1.000 | #10.000 | #1.000.000 | #10.000.000 | #1.000.000, iPad Mini
:-------------------------- | -----: | ------: | ---------: | ----------: | --------------------:
`NSIndexSet`, adding        |   0.28 |    4.58 |      98.60 |     9396.72 |                179.27
`NSSet`, adding             |   0.30 |    2.60 |       8.03 |       91.93 |                 37.43
`NSIndexSet`, random access |   0.10 |    1.00 |       3.51 |       58.67 |                 13.44
`NSSet`, random access      |   0.17 |    1.32 |       3.56 |       34.42 |                 18.60
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]           </th>
<th align="right"> #1.000 </th>
<th align="right"> #10.000 </th>
<th align="right"> #1.000.000 </th>
<th align="right"> #10.000.000 </th>
<th align="right"> #1.000.000, iPad Mini </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSIndexSet</code>, adding        </td>
<td align="right">   0.28 </td>
<td align="right">    4.58 </td>
<td align="right">      98.60 </td>
<td align="right">     9396.72 </td>
<td align="right">                179.27 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, adding             </td>
<td align="right">   0.30 </td>
<td align="right">    2.60 </td>
<td align="right">       8.03 </td>
<td align="right">       91.93 </td>
<td align="right">                 37.43 </td>
</tr>
<tr>
<td align="left"> <code>NSIndexSet</code>, random access </td>
<td align="right">   0.10 </td>
<td align="right">    1.00 </td>
<td align="right">       3.51 </td>
<td align="right">       58.67 </td>
<td align="right">                 13.44 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, random access      </td>
<td align="right">   0.17 </td>
<td align="right">    1.32 </td>
<td align="right">       3.56 </td>
<td align="right">       34.42 </td>
<td align="right">                 18.60 </td>
</tr>
</tbody>
</table>


<p>我们看到在一百万左右对象的时候，<code>NSIndexSet</code>开始变得比<code>NSSet</code>慢，但只是因为新的运行时和标签指针。在iOS 6上运行相同的测试表明，甚至在更高数量级实体的条件下，<code>NSIndexSet</code>更快。实际上，在大多数应用中，你不会添加太多的整数到索引set中。还有一点这里没有测试，就是<code>NSIndexSet</code>跟<code>NSSet</code>比无疑有更好的内存优化。</p>

<h2>结论</h2>

<p>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但是有用的类，尤其是<code>NSCountedSet</code>，<a href="http://nshipster.com/cfbag/">CFBag</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFTreeRef/Reference/reference.html">CFTree</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBitVectorRef/Reference/reference.html">CFBitVector</a>和<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBinaryHeapRef/Reference/reference.html">CFBinaryHeap</a>。</p>
]]></content>
  </entry>
  
</feed>

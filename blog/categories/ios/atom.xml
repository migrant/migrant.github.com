<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | Migrant]]></title>
  <link href="http://objcio.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://objcio.com/"/>
  <updated>2014-05-21T11:33:45+08:00</updated>
  <id>http://objcio.com/</id>
  <author>
    <name><![CDATA[Migrant]]></name>
    <email><![CDATA[tomigrant@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[自定义 URL Scheme 完全指南]]></title>
    <link href="http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes/"/>
    <updated>2014-05-21T11:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://iosdevelopertips.com/cocoa/launching-your-own-application-via-a-custom-url-scheme.html">The Complete Tutorial on iOS/iPhone Custom URL Schemes</a>，转载请注明出处。</p>

<p><strong>注意</strong>: <em>自从自定义 URL 的引入，本文始终是我博客中阅读量最大的文章。虽然大多数都相同，但仍然有一些细微差别的变化。本文是原帖的重写版，更新为最新的 iOS 和 Xcode 版本。</em></p>

<p>iPhone / iOS SDK 最酷的特性之一就是应用将其自身"绑定"到一个自定义 URL scheme 上，该 scheme 用于从浏览器或其他应用中启动本应用。</p>

<h2>注册自定义 URL Scheme</h2>

<p>注册自定义 URL Scheme 的第一步是创建 URL Scheme &mdash; 在 Xcode Project Navigator 中找到并点击工程 info.plist 文件。当该文件显示在右边窗口，在列表上点击鼠标右键，选择 <em>Add Row</em>:</p>

<p>向下滚动弹出的列表并选择 <em>URL types</em>。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-01.gif" alt="iOS Custom URL Scheme" /></p>

<p>点击左边剪头打开列表，可以看到 <em>Item 0</em>，一个字典实体。展开 <em>Item 0</em>，可以看到 <em>URL Identifier</em>，一个字符串对象。该字符串是你自定义的 URL scheme 的名字。建议采用反转域名的方法保证该名字的唯一性，比如 <em>com.yourCompany.yourApp</em>。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-02.gif" alt="urlScheme2a" /></p>

<p>点击 <em>Item 0</em> 新增一行，从下拉列表中选择 <em>URL Schemes</em>，敲击键盘回车键完成插入。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-03.gif" alt="iOS Custom URL Scheme" /></p>

<p>注意 URL Schemes 是一个数组，允许应用定义多个 URL schemes。</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-04.gif" alt="iOS Custom URL Scheme" /></p>

<p>展开该数据并点击 <em>Item 0</em>。你将在这里定义自定义 URL scheme 的名字。只需要名字，不要在后面追加 :// &mdash; 比如，如果你输入 iOSDevApp，你的自定义 url 就是 iOSDevApp://</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-05.gif" alt="iOS Custom URL Scheme" /></p>

<p>此时，整个定义如下图:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-06.gif" alt="iOS Custom URL Scheme" /></p>

<p>虽然我赞同 Xcode 使用描述性的名字的目的，不过看到创建的实际的 key 也是非常有用的。这里有一个方便的技巧，右键点击 plist 并选择 <em>Show Raw Keys/Values</em>，就能看到以下效果:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-07.png" alt="iOS Custom URL Scheme" /></p>

<p>还有另一种有用的输出格式，XML，因为可以非常容易的看到字典和原始数组及其包括的实体的结构。点击 plist 并选择 <em>Open As &ndash; Source Code</em>:</p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-08.gif" alt="iPhone Custom URL Scheme" /></p>

<!--more-->


<h2>从 Safari 中调用自定义 URL Scheme</h2>

<p>定义了 URL scheme，我们可以运行一个快速测试来验证应用是否如我们所期望的被调用。在这之前，我创建了一个准 UI 以辨别带有自定义 URL 的应用。该应用只有一个 UILabel，带有文本 &ldquo;App With Custom URL"。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-09.png" alt="iOS App with Custom URL" /></p>

<p>使用模拟器调用应用的步骤:</p>

<ul>
<li>在 Xcode 中运行应用</li>
<li>一旦应用被安装，自定义 URL scheme 就会被注册</li>
<li>通过模拟器的硬件菜单中选择 Home 来关闭应用</li>
<li>启动 Safari</li>
<li>在浏览器地址栏输入之前定义的 URL scheme(如下)</li>
</ul>


<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-10.png" alt="Call Custom URL Scheme from Safari" /></p>

<p>此时 Safari 将会关闭，应用会被带回到前台。祝贺你刚刚使用自定义 URL scheme 调用了一个 iPhone 应用。</p>

<h2>从另一个 iPhone 应用中调用自定义 URL Scheme</h2>

<p>让我们看看如何从另一个应用中调用自定义 URL scheme。我又创建了一个非常简单的 iPhone 应用，它只有一个 UILabel 和一个 UIButton &mdash; 前者显示了一段信息，告诉你这个应用将要通过自定义 URL scheme 来调用另一个应用，按钮则开始这个行为。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-11.png" alt="iPhone app that call Custom URL Scheme" /></p>

<p>buttonPressed 方法中的代码处理 URL 调用:</p>

<p>```objc
&ndash; (void)buttonPressed:(UIButton <em>)button
{
  NSString </em>customURL = @&ldquo;iOSDevTips://&rdquo;;</p>

<p>  if ([[UIApplication sharedApplication]</p>

<pre><code>canOpenURL:[NSURL URLWithString:customURL]])
</code></pre>

<p>  {</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]];
</code></pre>

<p>  }
  else
  {</p>

<pre><code>UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"URL error"
                      message:[NSString stringWithFormat:
                        @"No custom URL defined for %@", customURL]
                      delegate:self cancelButtonTitle:@"Ok" 
                      otherButtonTitles:nil];
[alert show];
</code></pre>

<p>  }  <br/>
}
```</p>

<p>第 5 行代码检查自定义 URL 是否被定义，如果定义了，则使用 shared application 实例来打开 URL (第 8 行)。openURL: 方法启动应用并将 URL 传入应用。在此过程中，当前的应用被退出。</p>

<h2>通过自定义 URL Scheme 向应用传递参数</h2>

<p>有时你需要通过自定义 URL 向应用中传递参数。让我们看看该如何完成这个工作。</p>

<p>NSURL 作为从一个应用调用另一个的基础，遵循 <a href="https://tools.ietf.org/html/rfc1808">RFC 1808</a> (Relative Uniform Resource Locators) 标准。 因此你所熟悉的基于网页内容的 URL 格式在这里也适用。</p>

<p>在自定义了 URL scheme 的应用中，app delegate 必须实现以下方法:</p>

<p><code>objc
- (BOOL)application:(UIApplication *)application
  openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
  annotation:(id)annotation
</code></p>

<p>从一个应用传递参数到另一个的诀窍是通过 URL。例如，假设我们使用以下的 URL scheme，想传递一个名为 &ldquo;token"的参数和一个标识注册状态的标志，我们可以像这样创建一个 URL:</p>

<p><code>objc
NSString *customURL = @"iOSDevTips://?token=123abct&amp;registered=1";
</code></p>

<p>在 web 开发中，字符串 <em>?token=123abct&amp;registered=1</em> 被称作查询询串(query string).</p>

<p>在被调用(设置了自定义 URL)的应用的 app delegate 中，获取参数的代码如下:</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application openURL:(NSURL </em>)url</p>

<pre><code>    sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
</code></pre>

<p>{
  NSLog(@&ldquo;Calling Application Bundle ID: %@&rdquo;, sourceApplication);
  NSLog(@&ldquo;URL scheme:%@&rdquo;, [url scheme]);
  NSLog(@&ldquo;URL query: %@&rdquo;, [url query]);</p>

<p>  return YES;
}
```</p>

<p>以上代码在应用被调用时的输出为:</p>

<p><code>
Calling Application Bundle ID: com.3Sixty.CallCustomURL
URL scheme:iOSDevTips
URL query: token=123abct&amp;registered=1
</code></p>

<p>注意 &ldquo;Calling Application Bundle ID"，你可以用这个来确保只有你定义的应用可以与你的应用直接交互。</p>

<p>让我们改变一下代码，来验证发起调用的应用的 Bundle ID 是否合法:</p>

<p>```objc
&ndash; (BOOL)application:(UIApplication <em>)application openURL:(NSURL </em>)url</p>

<pre><code>    sourceApplication:(NSString *)sourceApplication annotation:(id)annotation
</code></pre>

<p>{
  // Check the calling application Bundle ID
  if ([sourceApplication isEqualToString:@&ldquo;com.3Sixty.CallCustomURL&rdquo;])
  {</p>

<pre><code>NSLog(@"Calling Application Bundle ID: %@", sourceApplication);
NSLog(@"URL scheme:%@", [url scheme]);
NSLog(@"URL query: %@", [url query]);

return YES;
</code></pre>

<p>  }
  else</p>

<pre><code>return NO;
</code></pre>

<p>}
```</p>

<p>有一点要特别注意，你不能阻止其他应用通过自定义 URL scheme 调用你的应用，然而你可以跳过后续的操作并返回 NO，就像上面的代码那样。也就是说，如果你想阻止其它应用调用你的应用，创建一个与众不同的 URL scheme。尽管这不能保证你的应用不会被调用，但至少大大降低了这种可能性。</p>

<h2>自定义 URL Scheme 示例工程</h2>

<p>我意识到按照本文的每一步做下来还是有一点复杂的。我做好了两个非常基础的 iOS 应用，一个自定义了 URL scheme，另一个则去调用它，并传递了一个比较短的参数列表(query string)。这些是体验自定义 URL 的很好的入门点。</p>

<ul>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app with Custom URL scheme</a></li>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app to call custom URL scheme</a></li>
</ul>


<h2>其它资源</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html#//apple_ref/doc/uid/TP40007246">How to Properly Validate URL Parameters</a>
<a href="https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899">URL Scheme Reference Docs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon 来了]]></title>
    <link href="http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon/"/>
    <updated>2014-05-01T22:36:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.cocoanetics.com/2013/11/can-you-smell-the-ibeacon/">Can you Smell the iBeacon?</a>，转载请注明出处。</p>

<p>虽然我们还未看到任何实际生活中的使用案例，但 iBeacon 绝对是 iOS 7 带来的最热门的新话题之一。</p>

<p>上周我收到了我的 <a href="https://preorder.estimote.com/">Developer Preview Kit from Estimote</a>，为了将其收入我正在写作的新书中，我开始研究 iBeacon。下面是我的发现。</p>

<p>为了理解两种操作模式的不同之处，有两个词你应该知道:</p>

<ul>
<li><strong>Monitoring</strong> &ndash; 涉及小功率区域监测，接收 didEnterRegion: 和 didExitRegion: 代理消息。</li>
<li><strong>Ranging</strong> &ndash; 意味着大功率活动，此时你能从各个 iBeacon 收到信号强度并能够估计此刻与它们的距离。</li>
</ul>


<p>iOS 7 之前苹果给我们提供了监测设备将要进入或离开某一个特定区域的能力，其核心是 <code>CLRegion</code>。该技术围绕着地理位置和进入或退出该位置时将要发生的事情。更好的是，如果你在 info.plist 中指定了接收后台位置更新，那么系统可以在区域边界处激活你的应用。</p>

<p>iOS 7 增加了继承自 CLRegion 的 <code>CLBeaconRegion</code>。只要有 iBeacon 被 iOS 检测到，即使信号可能很弱，你就被定义为位于区域之内。这让测试过程令人发疯，因为即使我把我所有的 Estmote beacons 用铝箔包裹起来， iOS 仍然认为我位于该区域内。</p>

<p>一个 iBeacon 通过 3 个值被识别: proximityUUID, Major 和 Minor。第一个是 UUID，后两者是两个 16 位二进制整数。你可以构建 3 个级别的 CLBeaconRegion: 只有 UUID，UUID + Major，UUID + Major + Minor。例如你可能想用一个 UUID 对应整个公司，Major 对应各个店铺。Minor 则可以用来指定每个店铺中的各个货架。</p>

<!--more-->


<h2>做广告吧</h2>

<p>普通的 BTLE (Bluetooth Low Energy) 外设宣传多重服务，iBeacon 不同。iBeacon 自己使用广告信息并且不需要真正的蓝牙链接，因为所有所需信息已存在于 iBeacon 广告中。</p>

<p>以一个简略的例子开始</p>

<p>```objc
@implementation ViewController
{
   CBPeripheralManager *<em>peripheralManager;
   BOOL </em>isAdvertising;
}</p>

<ul>
<li><p>(void)_startAdvertising
{
 NSUUID *estimoteUUID = [[NSUUID alloc] initWithUUIDString:@&ldquo;B9407F30-F5F8-466E-AFF9-25556B57FE6D&rdquo;];</p>

<p> CLBeaconRegion <em>region = [[CLBeaconRegion alloc] initWithProximityUUID:estimoteUUID
                                                                  major:2
                                                                  minor:1
                                                             identifier:@&ldquo;SimEstimote&rdquo;];
 NSDictionary </em>beaconPeripheralData = [region peripheralDataWithMeasuredPower:nil];</p>

<p> [_peripheralManager startAdvertising:beaconPeripheralData];
}</p></li>
<li><p>(void)<em>updateEmitterForDesiredState
{
 if (</em>peripheralManager.state == CBPeripheralManagerStatePoweredOn)
 {
    // only issue commands when powered on</p>

<pre><code>if (_isAdvertising)
{
   if (!_peripheralManager.isAdvertising)
   {
      [self _startAdvertising];
   }
}
else
{
   if (_peripheralManager.isAdvertising)
   {
      [_peripheralManager stopAdvertising];
   }
}
</code></pre>

<p> }
}</p></li>
</ul>


<h1>pragma mark &ndash; CBPeripheralManagerDelegate</h1>

<ul>
<li>(void)peripheralManagerDidUpdateState:(CBPeripheralManager *)peripheral
{
 [self _updateEmitterForDesiredState];
}</li>
</ul>


<h1>pragma mark &ndash; Actions</h1>

<ul>
<li><p>(IBAction)advertisingSwitch:(UISwitch *)sender
{
 _isAdvertising = sender.isOn;</p>

<p> [self _updateEmitterForDesiredState];
}</p></li>
</ul>


<p>@end
```</p>

<p>这个例子有一个 UISwitch 来切换 soft-beacon。这里有一些陷阱。首先它用了若干毫秒来开启蓝牙系统。只有在蓝牙启动时才能使用 <code>CBPeripheralManager</code>。它一这么做你就会收到 peripheralManagerDidUpdateState: 代理回调，如果蓝牙电源此时处于开启状态，你就可以开始广播 beacon。</p>

<p>停止 iBeacon 要简单的多，只需要一个命令。如果 <code>CBPeripheralManager</code> 电源被关闭，则所有的广告也会停止。当应用进入后台而你又没有告诉 iOS 保持蓝牙服务继续运行时就会导致这种情况发生。没记错的话，所有的服务在应用回到前台时会恢复。</p>

<h2>Estimote</h2>

<p>用何种类型的设备来执行 iBeacon 的功能并无结论，你可以让任何 iOS 设备 (>= iPhone 4S) 和 Mac (>= late 2011) 的蓝牙芯片作为 iBeacon。也有一些硬件公司提供专用的硬件。</p>

<p>Beacon 硬件的初衷是你让你并不需要在墙上粘一个真的 iOS 设备。不是每个人都能在店铺的每一个角落都放上 iPad。标准 iBeacon 硬件的价格是 99 美金 3个。我用这个价格买了 3 个 Estimote beacon。</p>

<p><img src="/images/posts/2014-05-01-can-you-smell-the-ibeacon-01.jpg" alt="Estimote Developer Preview Kit" /></p>

<p>Estimote 提供了非常友好的拆箱体验。除了 3 个不同颜色的 iBeacon，还有 1 个按钮，1 张贴纸，1 张 Estimote CEO 和联合创始人 Jakub Krzych 的名片，还有一些警告信息来告知你这些 beacon 目前是手工组装的因此可能存在固件 bug。</p>

<p>收到 beacon 后你要做的第一件事是下载 Estimote 的演示应用，它可以让你像上文描述的那样尝试 Monitoring 和 Ranging。它还允许你链接各个 Estimote 设备来观察它们的电量，固件版本，以及 UUID， Major 和 Minor 的设置值。</p>

<p>此时我很惊讶的得知 Estimote 使用了"烧入"的 UUID。官方声明说这是有意的设计，用来阻止来自越狱设备的黑客和位置欺骗。</p>

<p>UUID 在应用内很明显，也被公布于几个博客中:</p>

<p><code>
B9407F30-F5F8-466E-AFF9-25556B57FE6D
</code></p>

<p>这也是我上面的例子中使用的 UUID，其实是创建了一个模拟的 Estimote beacon。</p>

<p>Estimote beacon 被完全包裹于橡胶之中因此并没有像 USB 之类的物理硬件接口。所有的设置通过蓝牙和 Estimote 暴露的内部服务来完成。推测未来版本的 <a href="https://github.com/Estimote/iOS-SDK">official Estimote SDK</a> 会针对担心自己 beacon 安全的人推出 UUID 加密方法。</p>

<p>他们还建议你使用他们包装的 Core Location 和 Core Bluetooth 来代替原生的 iOS 方法。对于系统也提供的功能，我个人比较反感使用第三方 SDK。对于你和你的邻居使用相同的 UUID 所造成的潜在问题的最佳解决方案是使用随机的 Major 值结合 UUID 来监测。一旦范围被发现，你要做额外的检查 &mdash; 可能针对于地理位置 &mdash; 是否你确实在你自己的店铺里。</p>

<h2>监测 iBeacon 区域</h2>

<p>如果你已经有了一个 Estimote 或按照上面创建了一个 soft-beacon，下一步就是监测这个区域。下面是一个可行的示例，目的是当你穿过区域边界时，更新文本标签并发出一个本地通知</p>

<p>```objc
@implementation AppDelegate
{
   CLLocationManager *<em>locationManager;
   BOOL </em>isInsideRegion; // flag to prevent duplicate sending of notification
}</p>

<ul>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)options
{
 // create a location manager
 _locationManager = [[CLLocationManager alloc] init];</p>

<p> // set delegate, not the angle brackets
 _locationManager.delegate = self;</p>

<p> NSUUID <em>estimoteUUID = [[NSUUID alloc] initWithUUIDString:@&ldquo;B9407F30-F5F8-466E-AFF9-25556B57FE6D&rdquo;];
 CLBeaconRegion </em>region = [[CLBeaconRegion alloc] initWithProximityUUID:estimoteUUID
                                                             identifier:@&ldquo;Estimote Range&rdquo;];</p>

<p> // launch app when display is turned on and inside region
 region.notifyEntryStateOnDisplay = YES;</p>

<p> if ([CLLocationManager isMonitoringAvailableForClass:[CLBeaconRegion class]])
 {
    [_locationManager startMonitoringForRegion:region];</p>

<pre><code>// get status update right away for UI
[_locationManager requestStateForRegion:region];
</code></pre>

<p> }
 else
 {
    NSLog(@&ldquo;This device does not support monitoring beacon regions&rdquo;);
 }</p>

<p>  // Override point for customization after application launch.
  return YES;
}</p></li>
<li><p>(void)<em>sendEnterLocalNotification
{
 if (!</em>isInsideRegion)
 {
    UILocalNotification *notice = [[UILocalNotification alloc] init];</p>

<pre><code>notice.alertBody = @"Inside Estimote beacon region!";
notice.alertAction = @"Open";

[[UIApplication sharedApplication] scheduleLocalNotification:notice];
</code></pre>

<p> }</p>

<p> _isInsideRegion = YES;
}</p></li>
<li><p>(void)<em>sendExitLocalNotification
{
 if (</em>isInsideRegion)
 {
    UILocalNotification *notice = [[UILocalNotification alloc] init];</p>

<pre><code>notice.alertBody = @"Left Estimote beacon region!";
notice.alertAction = @"Open";

[[UIApplication sharedApplication] scheduleLocalNotification:notice];
</code></pre>

<p> }</p>

<p> _isInsideRegion = NO;
}</p></li>
<li><p>(void)_updateUIForState:(CLRegionState)state
{
 ViewController <em>vc = (ViewController </em>)self.window.rootViewController;</p>

<p> if (state == CLRegionStateInside)
 {
    vc.label.text = @&ldquo;Inside&rdquo;;
 }
 else if (state == CLRegionStateOutside)
 {
    vc.label.text = @&ldquo;Outside&rdquo;;
 }
 else
 {
    vc.label.text = @&ldquo;Unknown&rdquo;;
 }
}</p></li>
</ul>


<h1>pragma mark &ndash; CLLocationManagerDelegate</h1>

<ul>
<li><p>(void)locationManager:(CLLocationManager <em>)manager
    didDetermineState:(CLRegionState)state forRegion:(CLRegion </em>)region
{
 // always update UI
 [self _updateUIForState:state];</p>

<p> if ([UIApplication sharedApplication].applicationState == UIApplicationStateActive)
 {
    // don&rsquo;t send any notifications
    return;
 }</p>

<p> if (state == CLRegionStateInside)
 {
    [self <em>sendEnterLocalNotification];
 }
 else
 {
    [self </em>sendExitLocalNotification];
 }
}</p></li>
</ul>


<p>@end
```</p>

<p>本质上，你只是创建了一个 <code>CLBeaconRegion</code> 并让 <code>CLLocationManager</code> 对象去监听它。对于某些设备 beacon 监听会不可用，比如缺少 BT4 芯片，所以你需要通过 <code>isMonitoringAvailableForClass:</code> 来查询。</p>

<p>注意 didDetermineState: 在穿越区域边界时和 requestStateForRegion: 方法后都会被调用。所以你可以在这里做关于监听的工作并实现 didEnterRegion` 和 didExitRegion: 来保证不会过分干扰用户。</p>

<p>剩下的代码用来在应用在后台运行时发送本地通知，并避免对同一状态连续发送多个相同消息。</p>

<p>在我测试时，当我在 iPad 上打开第一个例子中的 soft beacon，我总是会立刻收到 didEnterRegion: 消息。关闭 beacon 后会延迟 43 秒收到 didExit 消息。所以 iOS 在内部做了一些过滤来避免实时触发。</p>

<h2>后台</h2>

<p>你会发现上面的代码在应用在前台运行时运行的非常好，但是当应用进入后台后不会继续发送/监听。</p>

<p>为了在后台监听区域，你需要将 info.plist 中的 &ldquo;Location updates&rdquo; 后台模式开启。"Acts as Bluetooth LE accessory" 则用来使 soft beacon 持久。Xcode 为此提供了很友好的 UI。</p>

<p><img src="/images/posts/2014-05-01-can-you-smell-the-ibeacon-02.png" alt="Enabling iBeacon background modes" /></p>

<p>这里做出的改变最终会体现在 info.plist 文件中的 <code>UIBackgroundModes</code> 下。</p>

<p>增加配件设置要求用户授权蓝牙文件共享。注意用户可能拒绝或者在隐私设置中关闭授权。</p>

<p>集成了兼容 BT4 芯片的 Mac 可以发射 soft-beacon。CoreBluetooth 从 OS X 10.9 开始也可以在 Mac 上使用。2011 年以后生产的 Mac 通常含有该芯片。唯一缺少的是 CLBeaconRegion，不过如果你自己构建用来广播 iBeacon 的字典就可以解决这个问题。至此，你所需要了解的最后一件事是 CoreBluetooth.framework 隐藏在 IOBluetooth.framework 中。</p>

<p><a href="http://twitter.com/mttrb">Matthew Robinson</a> 创建了 <a href="https://github.com/mttrb/BeaconOSX">BeaconOSX sample</a> 来做这件事。</p>

<h2>竞争</h2>

<p>至写作此文时苹果并未发布官方的 iBeancon 规范。当我询问苹果相关负责人，他告诉我当他们发布时会告知我。所以只能寄希望于它们最终会这么做。与此同时，一些聪明人仍旧跑在前面并且<a href="http://developer.radiusnetworks.com/2013/10/01/reverse-engineering-the-ibeacon-profile.html">对 iBeacon 进行逆向工程</a>。</p>

<p>几个 iBeacon 硬件已经面世，Estimote 很快就会感受到来自他们的竞争。我粗略的搜索后发现的其他公司有:</p>

<ul>
<li><strong>RedBearLab</strong> 出售 Arduino 插件板(也叫做 &ldquo;shield&rdquo;)，售价 $29，有一个 <a href="http://redbearlab.com/ibeacon/">iBeacon profile</a></li>
<li><strong>Kontakt.io</strong> 出售运行于可人工替换的普通电池上的 beacon，售价 $99 3个，$149 5个， $279 10个。</li>
<li><strong>GeoHopper</strong> 以 USB 供电的作为 iBeacon 的微型插头: 售价 $39.99 1个，$89.99 3个，192.99 5个。</li>
<li>你还可以[用 Raspberry Pi 和 Bluetooth LE 适配器自己做一个]，设备价值 $40 左右，适配器 $10 左右。</li>
</ul>


<p>以上公司中，Estimote 似乎服务最好。</p>

<p>USB 供电和可更换电池并不是十分必要，低功耗的 BTLE 据说可以维持 2 年。防水橡胶外套和内置的贴纸可以让你很容易的将它粘贴到任何地方而不必害怕它被偷走和损害。</p>

<p>但是竞争从未停止，更多的公司一如既往的进入这个热门领域，下一年的价格一定会降低一半甚至更多。希望 Estimote 在价格上保持竞争力，并且当可以在生产线量产 beacon 的时候进一步降低价格。</p>

<p>只有两个不那么积极的消息。我个人认为自定义 SDK 不应该被当做 USP 使用来锁定用户，并且他们也不打算支持自定义的 UUID，当然也许是出于安全方面的考虑。也许它们最终也会明白过来。目前这些东西可以很容易的工作，"包裹"中其余的东西也非常有价值。</p>

<h2>结论</h2>

<p>没什么能阻止我们将 iBeacon 技术发扬光大，使应用和服务留意用户需求。要是真有什么的话，可能是担心苹果可能会更新仍然保密的 iBeacon 广告包来包含其它值。不过我提到的所有的硬件设备也可以升级来调整广告值。</p>

<p>唯一的问题是想象力的缺乏以及缓慢的卖家和合作方市场的低采用率。iBeacon 承诺会让进入传统的实体商店再次变得有趣。如此一来，任何这种公司会被很好的宣传以快速采用 iBeacon，以此方法将顾客重新勾住和拉回实体店。</p>

<p>小型商店可以在他们用于 POS 系统的 Mac 或 iPad 上运行一个 iBeacon，避免额外话费。这允许基于 Passbook 的优惠券或当靠近收银台时会员卡自动弹出。</p>

<p>你知道有哪些现实生活中 iBeacon 的创新使用? 或者在阅读本文时有新想法？请在评论里让我们知道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精通iCloud文档存储]]></title>
    <link href="http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store/"/>
    <updated>2014-04-25T22:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-10/icloud-document-store.html">Mastering the iCloud Document Store</a>，转载请注明出处。</p>

<p>即便在推出 3 年后，iCloud 文档存储依然是一个充满神秘、误解和抱怨的话题。iCloud 同步经常被批评不可靠且速度慢。虽然在 iCloud 的早期有一些严重的 bug，开发者们还是不得不学习有关文件同步的课程。文件同步事关重大，为应用开发带来了新方向 &mdash; 一个经常被低估的方向，比如进行同步服务相关的合作时，对于处理文件异步更改的需要。</p>

<p>本文会介绍几个创建支持 iCloud 的应用时可能会遇到的一些绊脚石。因为本文只会给出一些粗略的概述，所以如果你对 iCloud 文档存储还不熟悉，我们强烈建议你先阅读 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<!--more-->


<h2>文档存储简介</h2>

<p>iCloud 文档存储的核心思想非常简单: 每个应用都有至少通往一个"魔法文件夹"的入口，该文件夹可以存储文件并且随后在所有注册了同一个 iCloud 帐号的设备间同步。</p>

<p>与其他基于文件系统的同步服务相比，iCloud 文档存储得益于与 OS X 和 iOS 的深度整合。很多系统框架已经被扩展以支持 iCloud。像 <code>NSDocument</code> 和 <code>UIDocument</code> 这样的类被按照可以处理外部变化来进行设计。版本存储和 <code>NSFileVersion</code> 处理同步冲突。Spotlight 被用来提供同步元数据，比如文件传输进度或者云端文档可用性。</p>

<p>写一个简单的基于文档并开启了 iCloud 的 OS X 应用并不需要费多大力气。实际上你并不需要关心任何 iCloud 内部的工作，<code>NSDocument</code> 无偿的做了几乎每件事情: 协调文档的 iCloud 访问，自动观察外部变化，触发下载，处理冲突。它甚至提供了一个简单的 UI 界面来管理云文档。你需要做的所有事情就是创建一个 <code>NSDocument</code> 子类并实现读取和写入文档内容所需要的方法。</p>

<p><img src="/images/posts/2014-04-25-mastering-the-icloud-document-store-01.png" alt="NSDocument provides a simple user interface for managing the synchronized documents of an app." /></p>

<p>然而，一旦脱离预设的路径，你就需要了解的更多。例如，默认打开面板提供的单层文件夹以外的任何操作都需要手动完成。可能你的应用需要管理除了文档内容以外的文档，比如像 Mail，iPhoto 或者 <a href="http://www.ulyssesapp.com/">Ulysses</a> (我们自己的app) 中做的那样。这种时候，你不能依赖于 <code>NSDocument</code>，而需要自己实现它的功能。但为此你需要对 iCloud 提供的锁和通知机制有一个深入的了解。</p>

<p>开发支持 iCloud 的 iOS 应用同样需要更多的工作和知识: 虽然 <code>UIDocument</code> 仍然管理 iCloud 文件访问和处理同步冲突，但缺乏管理文档和文件夹的图形界面。因为性能和存储空间的原因，iOS 也不会自动从云端下载新文档。你需要使用 Spotlight 来检索最近变化的目录并手动触发下载。</p>

<h2>什么是开放性容器 (Ubiquity Container)</h2>

<p>任何符合 App Store 条件的应用都可以使用 iCloud 文档存储。设置正确的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/iCloudFundametals.html#//apple_ref/doc/uid/TP40012094-CH6-SW13">授权</a>后，就获得了一个或多个所谓的"开放性容器"的访问权限。这是苹果用来称呼"一个被 iCloud 管理和同步的目录"的别称。每一个开放性容器限定在一个 app id 内，由此让每个用户在每个应用中有一份共享的存储仓库。有多个应用的开发者可以指定同一个团队的多个 app id，由此可以访问多个容器。</p>

<p><code>NSFileManager</code> 通过 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/URLForUbiquityContainerIdentifier:">URLForUbiquityContainerIdentifier:</a> 提供每一个容器的 URL。在 OS X 系统，可以通过打开 <code>~/Library/Mobile Documents</code> 目录来查看所有可用的开放性容器。</p>

<p><img src="/images/posts/2014-04-25-mastering-the-icloud-document-store-02.png" alt="The contents of ”~/Library/Mobile Documents.“ It contains a separate folder for each ubiquity container of each application." /></p>

<p>通常每个开放性容器有两个并发进程访问。首先，有一个应用呈现和操作容器内的文档。第二，有一个主要通过开放性守护 (Ubiquity Daemon <em>ubd</em>) 体现的 iCloud 架构。iCloud 架构等待应用对文档的更改并将其上传至苹果云服务器。同时也等待从 iCloud 上收到的更改并相应修改容器的内容。</p>

<p>由于两个进程完全独立于彼此工作，因此需某种形式的仲裁来避免资源竞争或丢失容器内的文件更新的问题。应用需要使用名为 <a href="https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileCoordinators/FileCoordinators.html#//apple_ref/doc/uid/TP40010672-CH11-SW1"><em>文件协调 file coordination</em></a> 的概念来确保对于每一个独立文件的访问权。该访问权由 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFileCoordinator_class/Reference/Reference.html"><code>NSFileCoordinator</code></a> 类提供。概括来说，它为每个文件提供了一个简单的 读-写 锁。这个锁由一个通知机制扩展，该机制用于用于改善访问同一个文件的不同进程间的合作。</p>

<p>这个通知机制相比于简单的文件锁来说是有巨大的好处，并且提供了无缝的用户体验。iCloud 可能会在任何时间把文档用一个来自其他设备的新版本覆盖。如果一个应用当前正在显示同一个文档，它必须从磁盘加载新版本并向用户展示更新过的内容。更新过程中，应用可能需要锁住用户界面一段时间并随后在此打开。甚至可能发生更坏的情况: 应用可能保留着未保存的内容，这些内容需要<em>首先</em>保存到磁盘上以便检查同步冲突。最后，在网络条件良好的时候 iCloud 会上传文件最近的版本。因此必须能够要求应用立刻保存所有未保存的变更。</p>

<p>为了实现这个过程，文件协调伴随着另一套名为 <em>文件展示 (file presentation)</em> 的机制。无论什么时候应用打开并向用户展示一个文件，这被称为 <em>展示文档</em>，并且应该注册一个实现了 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html"><code>NSFilePresenter</code></a> 协议的对象。只要另一个进程通过一个文件协调访问文件，文件展示者 (file presenter) 就会收到关于该文件的通知。这些通知被作为方法调用传递，这些方法在展示者指定的一个操作队列(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfp/NSFilePresenter/presentedItemOperationQueue"><code>presentedItemOperationQueue</code></a>)中异步执行。</p>

<p>例如，在任何其他线程被允许开始一个读取操作前，文件展示者被要求保存任何未保存的变化。这些操作通过分发一个 block 到它的展示队列来执行 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a> 方法来完成。展示者需要保存文件并通过执行作为参数传入的 block 来确认通知。除了改变通知，文件展示者还用来通知应用同步冲突。一旦一个文件的冲突版本被下载，一个新的文件版本被加入到版本存储里。所有的展示者通过 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/presentedItemDidGainVersion:"><code>presentedItemDidGainVersion:</code></a> 被通知有一个新版本被创建。该回调接收一个引用了潜在冲突的 <code>NSFileVersion</code> 实例。</p>

<p>文件展示者还可以被用来监视文件夹内容。例如，一旦 iCloud 改变文件夹内容，如创建，删除或者移动文件，应用应该被通知到以便更新它的文档展示。为此，应用可以对展示的目录注册一个实现了 <code>NSFilePresenter</code> 协议的实例。一个目录的文件展示者会收到任何文件夹或其中文件或子文件夹的改变的通知。比如一个文件夹内的文件被修改，展示者会收到一个引用了该文件的 URL 的 <code>presentedSubitemDidChangeAtURL:</code> 通知。</p>

<p>因为带宽和电池寿命在移动设备上更加有限，iOS 不会自动从 iCloud 下载新文件。而是由应用手动决定何时来触发下载新文件到开放性容器中。为了持续告知应用哪些文件可用及其同步状态，iCloud 还会同步开放性容器内的文件元信息。应用可以通过 <code>NSMetadataQuery</code> 或访问 <code>NSURL</code> 的开放资源属性查询这些元信息。无论何时应用想要访问一个文件，它一定会通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 来触发下载行为。</p>

<h2>深入 iCloud</h2>

<p>在继续解释如何实现文件协调和观察之前，现在我们将深入一些过去几年里碰到的一些常见问题。再一次的，确保你已经阅读并理解了 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<p>虽然这些文件机制的描述让它们的使用看起来简单明了，但其实其中有很多隐藏的陷阱。这些陷阱中有些来自于底层框架的 bug。因为 iCloud 同步延伸到操作系统中相当多的层面，人们只能寄希望于苹果能够小心的修复这些 bug。实际上，苹果看起来宁愿废弃坏掉的 API 而不是修复它们。</p>

<p>即便如此，我们的经验告诉我们使用 iCloud 是非常非常容易犯错误的。异步，协作，基于锁特性的文件协调和文件展示互相牵连，并不容易掌握。下面，我们将介绍整合 iCloud 文档同步时的一些主要规则，并以这种形式分享我们的经验。</p>

<h3>只在需要时使用 Presenters</h3>

<p>文件展示者代价高昂。仅当你的应用需要立即应对或干预文件访问的时候，才应该使用它。</p>

<p>如果你的应用正在展示类似文档编辑器这样的东西给用户，文件展示足以胜任。这时，在其他进程写入该文件的时候也许需要锁住编辑器，或者还需要保存未保存的改变。然而，如果只是临时访问并且通知也可能会被延迟处理，就不应该使用文件展示。例如，当创建文件索引或缩略图，查看文件更改日期并使用简单的文件协调可能会更高效。另外，如果你正展示一个字典树的内容，在树的根节点注册 <em>一个</em> 展示者或用 <code>NSMetadataQuery</code> 来延迟获取改变通知会可能会非常高效。</p>

<p>是什么让文件展示代价如此高昂？它需要很多的进程间通信: 每个文件上注册的展示者在其他进程获取文件的访问权时都被要求释放该文件。比如另一个进程尝试读取一个文件，该文件的展示者会被要求保存所有未保存的内容 (<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a>)。它们还会被要求释放文件给读取者(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/relinquishPresentedItemToReader:"><code>relinquishPresentedItemToReader:</code></a>)，例如文件被读取时暂时锁住编辑器。</p>

<p>这些通知每一个都需要分发，加工并由各自的接收者确认。并且因为只有实现的进程知道哪些通知会被处理，所以即使展示者没有实现任何方法，进程间也会为每一个可能的通知进行通信。</p>

<p>另外，每个步骤都需要在读取进程，展示进程和文件协调守护进程 (<code>filecoordinationd</code>) 间的多重上下文的切换。结果就导致了一个简单的文件访问很快就变成耗费资源的操作。</p>

<p>除此之外，如果太多的展示者被注册，文件协调守护进程可能会删除重要的系统资源。对于每一个展示者，都需要打开并监听每一个它所描述的路径上的文件夹。尤其在 OS X Lion 和 iOS 5 上，这些资源是非常稀少的，过度的使用很容易导致文件协调守护进程的锁死或崩溃。</p>

<p>基于这些原因，我们强烈建议不要在目录树的每一个节点上增加文件展示者，只根据需要使用最少的文件展示者。</p>

<h3>只在需要时使用协调</h3>

<p>虽然文件协调要比文件展示节约资源，但它仍然给你的应用和整个系统增加额外的负担。</p>

<p>每当你的应用正在协调一个文件，其他同时想要访问同一个文件的进程可能需要等待。因此你不该在协调文件时执行过于耗时的任务。如果你这么做了，比如存储了大文件，你可以考虑将它存储到一个临时文件夹，随后在协调访问时使用硬连接。注意每一个协调的访问都可能会触发另一个进程上的文件展示者 &mdash; 该展示者可能需要时间在你的访问之前更新文件。始终考虑使用诸如 <code>NSFileCoordinatorReadingWithoutChanges</code> 这样的标识，除非需要读取文件的最新版本。</p>

<p>虽然你的应用的开放性容器可能不会被其他应用访问，过分的文件协调仍然可能成为 iCloud 的一个问题，执行太多的协调请求会造成类似 <code>ubd</code> 的进程的<a href="http://en.wikipedia.org/wiki/Resource_starvation">资源饥饿</a>问题。在应用启动阶段，<code>ubd</code> 似乎会扫描开放性容器内的所有文件。如果你的应用在程序启动阶段也在执行相同的扫描。两个进程会经常冲突，从而可能导致协调的高开销。这时考虑更优化的解决方案是明智的。例如扫描目录内容时，单独的文件内容访问权限是根本不需要的。把协调工作延迟到文件内容真正被展示的时候再进行会是不错的选择。</p>

<p>最后，绝对不要协调一个还没有被下载的文件。文件协调会触发对该文件的下载。不幸的是，协调将会一直等待直到下载完成，这有可能会导致应用被锁住很长一段时间。访问一个文件之前，应用应该先检查文件下载状态。你可以通过查询 URL 的 <code>NSURLUbiquitousItemDownloadingStatusKey</code> 的值或使用 <code>NSMetadataQuery</code> 做到这一点。</p>

<h3>协调方法的几个备注</h3>

<p>阅读 <code>NSFileCoordinator</code> 的文档，你可能注意到每个方法都有一个冗长而复杂的描述。虽然 API 文档通常是非常可靠的，但由于同其他协调器和文件展示者交互的多样性，以及文件夹和文件锁的语法多样性，都造成了很高的复杂度。有一些很容易忽略的细节和问题贯穿这些长长的描述:</p>

<ol>
<li>认真选择协调选项。它们真的对文件协调器和文件展示者有着影响。比如，如果没有采用 <code>NSFileCoordinatorWritingForDeleting</code> 标识，文件展示者将无法通过 <code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 对文件删除操作做出影响。如果移动目录时不使用 <code>NSFileCoordinatorWritingForMoving</code>，则移动操作将不会等待其子项目上正在执行的协调操作进行完成。</li>
<li>始终认为协调调用可能会失败并返回错误。因为文件协调同 iCloud 交互，如果被协调的文件不能被下载，协调调用会失败并产生一条错误信息，并且你实际的文件操作可能不会被执行。如果没有正确的实现错误处理方法，你的应用可能不会注意到这样的问题。</li>
<li>在进入协调 block 之后检查文件状态。协调请求之后，也许很长时间已经过去了。这时，应用操作文件的前提条件可能已经失效。你想写入的信息直到重新获得锁之前有可能都是脏数据。也可能在你等待获得写入权限的时候文件已经被删除。这时你可能会无意中再次创建已经被删除的文件。</li>
</ol>


<h3>通知死锁</h3>

<p>实现 <code>NSFilePresenter</code> 的通知处理方法需要特别注意。类似 <code>relinquishPresentedItemToReader:</code> 这样的通知处理方法必须被确认及告知其他进程该文件已经对访问准备就绪。这一般通过执行作为参数传入通知处理方法的确认 block 来完成。确认 block 被调用之前，其他进程不得不等待，了解这一点是尤为重要的。如果确认因为通知处理的缓慢而被延迟，协调进程也许会被搁置。如果一直没有被执行，则可能会永远被挂起。</p>

<p>不幸的是，需要被确认的通知也会被其他完全独立的通知拖慢。为了确保通知以正确的顺序执行，<code>presentedItemOperationQueue</code> 一般被设置为一个顺序执行队列。但是一个顺序队列就意味着处理速度慢的通知会延缓随后的通知。尤其是它们会延缓需要确认的通知，在那之前，所有的进程都将等待。</p>

<p>例如，假设一个 <code>presentedItemDidChange</code> 通知首先进入队列。该回调漫长的处理过程将会延缓其他随后进入队列的通知，比如 <code>relinquishPresentedItemToReader:</code>。因此，该通知的确认也会被延迟，从而也导致等待它的进程被延缓。</p>

<p>综上所述，在展示队列里的时候 <em>永远不要</em> 执行文件协调。实际上，即使简单的不需要任何确认的通知 (比如 <code>presentedItemDidChange</code>) 也会导致死锁。设想两个文件展示者同时在展示同一个文件。两个展示者都通过执行协调的读取操作来处理 <code>presentedItemDidChange</code> 通知。如果文件发生改变，通知被发送到两个展示者并且二者都在同一个文件上执行协调的读取操作。因此，两个展示者都通过入队一个  <code>relinquishPresentedItemToReader:</code> 请求对方释放文件并等待对方确认。不幸的是，两个展示者无法确认通知，因为它们都因为永久的等待对方确认的协调请求而阻塞了它们的展示队列。我们在 <a href="https://github.com/hydrixos/DeadlockExample">GitHub</a> 上提供了一个小例子展示这种死锁。</p>

<h3>通知缺陷</h3>

<p>从通知中得出正确结论并不容易。文件展示中存在的 bug 造成了有些通知处理器<em>从未被执行</em>。这里初步介绍一些已知的不太规律的通知:</p>

<ol>
<li>除了 <code>presentedSubitemDidChangeAtURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code>，所有的子项目通知要么不被调用，要么以一种难以预测的方式被调用。绝对不要依赖它们 &mdash; 实际上，<code>presentedSubitemDidAppearAtURL:</code> 和 <code>accommodatePresentedSubitemDeletionAtURL:completionHandler:</code> 从不会被调用。</li>
<li>只有通过使用了 <code>NSFileCoordinatorWritingForDeleting</code> 的文件协调来删除文件，<code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 才会工作。否则，你会连一个 change 的通知都收不到。</li>
<li>只有文件展示者执行 <code>itemAtURL:didMoveToURL:</code> 时，<code>presentedItemDidMoveToURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code> 才会被调用。否则项目不会收到任何有用的通知。子项目仍旧会分别针对旧的和新的 URL 收到 <code>presentedSubitemDidChange</code> 通知。</li>
<li>即使文件被正确移动，<code>presentedSubitemAtURL:didMoveToURL:</code> 通知也被发送，你仍然会针对旧的和新的 URL 收到两个额外的 <code>presentedSubitemDidChangeAtURL:</code> 通知。要做好准备好处理这个。</li>
</ol>


<p>一般来说，你必须注意通知可能会失效。也不应该依赖于任何特定的通知顺序。例如，当描述一个目录树时，你不能期望父文件夹的通知会先于或晚于其中子项目的通知。</p>

<h3>注意 URL 变化</h3>

<p>在文件协调和文件展示者传递参照着相同文件的不同的 URL 时，有几种你需要应对的情况。你绝不应该使用 <code>isEqual:</code> 比较 URL，因为两个不同的 URL 可能关联同一个文件。应该始终在比较之前标准化它们。这一点在 iOS 上尤为重要，在 iOS 中开放性容器存储在 <code>/var/mobile/Library/Mobile Documents/</code> 中，这个文件夹是 <code>/private/var/mobile/Library/Mobile Documents/</code> 的符号链接。你会收到带有指向同一个文件，基于 <em>两种路径变体</em> 的 URL 的展示者通知。如果你对 iCloud 和本地文档使用文件协调代码，这个问题在 OS X 上也会发生。</p>

<p>除此之外，还有几个关于大小写不敏感的文件系统的问题。<em>如果</em>文件系统要求，应该始终确保你使用大小写不敏感的文件名比较。文件协调 block 和展示者通知可能传递使用不同大小写的相同的 URL 变体。实际上，这是使用文件协调器重命名时的重要问题。为了搞懂这个问题，你需要回顾文件实际上是如何被重命名的:</p>

<p>```objc
[coordinator coordinateWritingItemAtURL:sourceURL</p>

<pre><code>                            options:NSFileCoordinatorWritingForMoving 
                   writingItemAtURL:destURL 
                            options:0 
                              error:NULL 
                         byAccessor:^(NSURL *oldURL, NSURL *newURL) 
</code></pre>

<p>{</p>

<pre><code>[NSFileManager.defaultManager moveItemAtURL:oldURL toURL:newURL error:NULL];
[coordinator itemAtURL:oldURL didMoveToURL:newURL];
</code></pre>

<p>}];
```</p>

<p>假设 <code>sourceURL</code> 指向一个名为 <code>~/Desktop/my text</code> 的文件，<code>destURL</code> 使用了大写字母的新文件名 <code>~/Desktop/My Text</code>。协调 block 被有意设计成传入两个 URL 的最新版本，以兼容等待文件访问时发生的移动操作。现在，不幸的，当改变文件名的大小写，文件协调所执行的 URL 校验将会发现新旧两个 URL 都存在一个有效文件，而新的 URL 是小写 <code>~/Desktop/my text</code> 的变体。访问 block 将会接收到同样的 <em>小写</em> URL 作为 <code>oldURL</code> 和 <code>newURL</code>，导致移动操作失败。</p>

<h3>请求下载</h3>

<p>在 iOS 中，触发从 iCloud 的下载是应用的责任。可以通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 方法触发下载。如果你的应用设计成自动下载文件 (也就是不由用户触发)，你应该始终在一个顺序后台队列中执行这些下载请求。换句话说，每一个单独的下载请求涉及到相当多的进程间通信并可能会很耗时。另一方面，同时触发太多的下载有时会过载 <em>ubd</em> 守护进程。一个普遍的错误就是使用 <code>NSMetadataQuery</code> 等待 iCloud 中的新文件然后自动触发下载它们。因为查询结果总是在主队列中传递并且可能包含一打的更新信息，直接触发下载会阻塞应用很长一段时间。</p>

<p>为了查询某个文件的下载或者上传状态，你可以使用 <code>NSURL</code> 的资源值。在 iOS 7 / OS X 10.9 之前，一个文件的下载状态通过 <code>NSURLUbiquitousItemIsDownloadedKey</code> 来确认。根据头文件文档，这个资源值从未正确生效过，所以在 iOS 7 和 Mavericks 中被废弃了。现在苹果建议使用 <code>NSURLUbiquitousItemDownloadingStatusKey</code>。在老系统上，你应该使用 <code>NSMetadataQuery</code> 查询 <code>NSMetadataUbiquitousItemIsDownloadedKey</code> 来获得正确的下载状态。</p>

<h2>综合考虑</h2>

<p>为你的应用增加 iCloud 支持并不只是你增加的另一个功能，而是一个对应用设计和实现有着深远影响的决定。它既影响着你的数据模型也影响着 UI。所以不要低估支持 iCloud 所需要做出的努力。</p>

<p>最重要的，增加 iCloud 会引入一个新的异步层。应用必须能够在任何时候处理文档和元数据的变化。这些变化上的通知可能会在不同线程上收到，这就需要在你的整个应用中添加同步机制来对这些通知进行适当的处理。你需要注意那些对于用户文档完整性有重大影响的关键代码中的问题，比如丢失更新，竞争和死锁等。</p>

<p>始终注意 iCloud 的同步保证是非常脆弱的。你只能假设文件和包是自动同步的。但你不能期望多个同时被修改的文件也会被立刻同步。比如，如果你的应用分开存储元信息和实际的文件的话，你一定要能够应对元信息会先于或晚于实际文件被下载的情况。</p>

<p>使用 iCloud 文档同步同时也意味着你正在做一个发布的应用。你的文档会在运行着不同版本的不同设备上。你可能想要使你文件格式的不同版本向前兼容。起码，你必须确保你的应用在面对其他不同设备上安装的新版本应用创建的文件时不会崩溃或发生错误。用户未必会立刻更新所有的设备，所以预先准备好这个问题。</p>

<p>最后，你的 UI 需要反映同步行为。即使这会抹杀掉一些神奇之处。尤其在 iOS 上，连接失败和缓慢的文件转换是现实状况。你的用户应该被通知关于文档的同步状态。你应该考虑展示文件是在被上传还是在下载，以告知用户他们的文档现在是否可用。使用大文件时，你可能需要显示文件传输进度，你的 UI 应该优雅一些; 如果 iCloud 不能及时给你某个文档，你的应用应该响应，并且让用户重试或至少放弃操作。</p>

<h2>调试</h2>

<p>因为涉及到多系统服务和外部服务，调试 iCloud 问题非常困难。Xcode 5 提供的 iCloud 调试功能非常有限并且大多数时候只会告诉你 iCloud 是否已经同步。幸运的是，还有一些差不多是官方的方法来调试 iCloud 文档存储。</p>

<h3>在 OS X 上调试</h3>

<p>有时你可能经历过 iCould 停止同步某个文件或干脆完全停止工作。实际上，这在文件协调器内使用断点或在一个文件操作进行期间杀掉一个进程时很容易发生。甚至如果你的应用在某个关键点崩溃后也会发生。通常来说，重启或者注销后重新登录 iCloud 都不能修复这个问题。</p>

<p>为了修复这些锁定，一个命令行工具会非常有好处: <code>ubcontrol</code>。这个工具是 10.7 以后版本 OS X 的一部分。使用命令 <code>ubcontrol -x</code>，你能够重置文档同步的本地状态。它通过重置一些私有数据库和缓存，重启所有涉及到的系统守护进程，来复原熄火的同步。同时它也会存储一些报告分析信息到 <code>~/Library/Application Support/Ubiquity-backups</code>。</p>

<p>虽然已经有日志文件被写入 <code>~/Library/Logs/Ubiquity</code> 中，你也还可以通过 <code>ubcontrol -k 7</code> 来增加日志级别。在进行 iCloud 相关的错误报告时，苹果工程师经常会要求你这么做以便收集信息。</p>

<p>为了调试文件协调，你还可以从文件协调守护进程中直接取回锁状态信息。这使你能够得知在应用中或多进程间可能遇到的文件协调死锁。为了访问这个信息，你需要在终端中执行以下命令:</p>

<p><code>objc
sudo heap filecoordinationd -addresses NSFileAccessArbiter
sudo lldb -n filecoordinationd
po [&lt;address&gt; valueForKey: @"rootNode"]
</code></p>

<p>第一个命令会返回一个文件协调守护进程的内部单例对象的地址。随后，你关联 <em>lldb</em> 到运行的守护进程上。通过使用第一步取回的地址，你将会得到一个所有活动的锁和文件展示者的状态的概览。调试命令会展示当前正在被展示或协调的整个文件树。例如，如果 TextEdit 正在展示一个名为 <code>example.txt</code> 的文件，你会得到以下跟踪信息:</p>

<p>```
example.txt</p>

<pre><code>&lt;NSFileAccessNode 0x…&gt; parent: 0x…, name: "example.txt"
presenters:
    &lt;NSFilePresenterProxy …&gt; client: TextEdit …&gt;
    location: 0x7f9f4060b940
access claims: &lt;none&gt;
progress subscribers: &lt;none&gt;
progress publishers: &lt;none&gt;
children: &lt;none&gt;****
</code></pre>

<p>```</p>

<p>如果你在文件协调进行时创建这种跟踪 (比如通过在文件协调 block 中设置断点)，你还会得到一个等待文件协调器的所有进程的列表。</p>

<p>如果通过 <em>lldb</em> 观察文件协调，你应该始终记得尽快执行 <code>detach</code> 命令。否则，全局根进程文件协调守护进程将一直等待，这会影响到系统中几乎所有的应用。</p>

<h3>在 iOS 上调试</h3>

<p>在 iOS 上，调试要更加复杂，因为你无法检查运行的系统进程，你也无法使用像 <code>ubcontrol</code> 的命令行工具。</p>

<p>iCloud 锁定在 iOS 上似乎更经常发生。重启应用或设备都无效。唯一有效的修复这种问题的方法是 <em>冷启动</em>。在冷启动过程中，iOS 似乎进行了 iClouds 的内部数据库重置。可以通过同时按下电源键和 home 键 10 秒钟冷启动设备。</p>

<p>为了在 iOS 上激活更详细的日志，在苹果 <a href="https://developer.apple.com/downloads">developer downloads page</a> 有一个专用的 iCloud 日志概述。如果搜索 &ldquo;Bug Reporter Logging Profiles (iOS)"，你将会找到一个叫做 "iCloud Logging Profile&rdquo; 移动设备概述。在你的 iOS 设备上安装该文件来激活更详细的日志。你可以用 iTunes 同步设备来访问这些日志.随后，你可以在 <code>Library/Logs/CrashReporter/Mobile Device/&lt;Device Name&gt;/DiagnosticLogs/Ubiquity</code> 文件夹找到它。如果想要关掉这种加强的日志输出，从设备删除描述文件即可。苹果建议你在激活或关闭概述前重启设备。</p>

<h3>在 iCloud Servers 上调试</h3>

<p>除了在你自己的设备上调试，考虑使用苹果服务上的调试服务可能也会有用。<a href="https://developer.icloud.com/">developer.icloud.com</a> 上有一个特殊的 web 应用，它允许你浏览存储在开放性容器内的所有信息和当前传输状态。</p>

<p>过去的几个月，苹果还提供了安全地在服务端对所有已连接设备进行 iCloud 重置的方法。更多信息可查看 <a href="http://support.apple.com/kb/HT5824">support document</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="http://objcio.com/blog/2014/03/10/custom-controls/"/>
    <updated>2014-03-10T10:27:00+08:00</updated>
    <id>http://objcio.com/blog/2014/03/10/custom-controls</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-3/custom-controls.html">Custom Controls</a>，转载请注明出处。</p>

<p>本文将讨论一些自定义视图和控件的诀窍和技巧。我们先对UIKit已经提供给我们的控件做一个概览，介绍一些渲染技巧。随后我们会深入到视图和它们的所有者之间的通信策略，并简略探讨辅助功能，本地化和测试。</p>

<!--more-->


<h2>视图层次概览</h2>

<p>看一下UIView的子视图，可以看到3个基本类:响应者，视图和控件。我们快速重温一下它们。</p>

<h3>UIResponder</h3>

<p><code>UIResponder</code>是<code>UIView</code>的父类。响应这能够处理触摸，手势，远程控制等事件。之所以它是一个单独的类而没有合并到<code>UIView</code>中，是因为<code>UIResponder</code>有更多的子类，最明显的就是<code>UIApplication</code>和<code>UIViewController</code>。通过重写<code>UIResponder</code>的方法，可以决定一个类是否可以成为第一响应者(例如当前输入焦点元素)。</p>

<p>当触摸或手势等交互行为发生，它们被发送给第一响应者(通常是一个视图)。如果第一响应者没有处理，则该行为沿着响应者链到达视图控制器，如果行为仍然没有被处理，则它继续传递给应用。如果想检测晃动手势，可以根据需要在这3层中的任意位置处理。</p>

<p><code>UIResponder</code>还允许自定义输入方法，通过<code>inputAccessoryView</code>向键盘添加辅助视图或使用<code>inputView</code>提供一个完全自定义的键盘。</p>

<h3>UIView</h3>

<p><code>UIView</code>的子类处理所有跟内容绘制有关的事情和触摸。只要写过"Hello, World"应用的人都知道视图，但我们重申一些技巧点:</p>

<p>一个普遍的错误概念是视图的区域是由它的frame定义的。实际上frame是一个派生属性，主要由center和bounds合成而来。不使用Auto Layout时，大多数人使用frame来定位改变视图的大小。作为警告，<a href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame">官方文档</a>特别详细说明了一个注意事项:</p>

<blockquote><p>If the transform property is not the identity transform, the value of this property is undefined and therefore should be ignored.</p></blockquote>

<p>另一个允许向视图添加交互的方法是使用手势识别器。注意它们并不工作在响应者上，而只在视图及其子类上工作。</p>

<h3>UIControl</h3>

<p><code>UIControl</code>建立在视图上，增加了更多的交互支持。最重要的是，它增加了target/action模式。看一下具体的子类，可以看到按钮，日期选择器，文本输入框，等等。创建交互控件时，你通常想要子类化一个<code>UIControl</code>。一些常见但并不是控件的类是工具栏按钮(虽然也支持target/action)和文本视图(这里需要你使用代理来获得通知)。</p>

<h2>渲染</h2>

<p>现在，我们接下去来到可见的部分:自定义渲染。正如Daniel在他的<a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html">文章</a>中提到的，你可能想避免在CPU上做渲染而将其丢给GPU。这里有一条经验:尽量避免<code>drawRect:</code>，而使用现有的视图构建自定义视图。</p>

<p>通常最快速的渲染方法是使用图片视图。例如，假设你想画一个带有边框的圆形头像，像下面图片中这样:</p>

<p><img src="/images/posts/2014-03-10-custom-controls.png" alt="" /></p>

<p>为了实现这个，我们用以下的代码创建了一个图片视图的子类:</p>

<p>```objc
// called from initializer
&ndash; (void)setupView
{</p>

<pre><code>self.clipsToBounds = YES;
self.layer.cornerRadius = self.bounds.size.width / 2;
self.layer.borderWidth = 3;
self.layer.borderColor = [UIColor darkGrayColor].CGColor;
</code></pre>

<p>}
```</p>

<p>我鼓励各位读者深入了解<code>CALayer</code>及其属性，因为你用它能实现的大多数事情会比用Core Graphics自己画要快。然而一如既往，剖析自己的代码是十分重要的。</p>

<p>把可拉伸的图片和图片视图一起使用也可以极大的提高效率。在<a href="http://robots.thoughtbot.com/post/33427366406/designing-for-ios-taming-uibutton">Taming UIButton</a>这个帖子中，Reda Lemeden探索了几种不同的绘图方法。在文章结尾处有一个很有价值的帖子:<a href="https://news.ycombinator.com/item?id=4645585">a comment by Andy Matuschak</a>，解释了可拉伸图片是这些技术中最快的。原因是可拉伸图片在CPU和GPU之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。</p>

<p>处理图片时，你也可以让GPU为你工作来代替使用Core Graphics。使用Core Image，你不必用CPU做任何的工作就可以在图片上建立复杂的效果。你可以直接在OpenGL上下文上直接渲染，所有的工作都在GPU上完成。</p>

<h3>自定义绘制</h3>

<p>如果决定了采用自定义绘制，有几种不同的选项可供选择。如果可能的话，看看是否可以生成一张图片并在内存和磁盘上缓存起来。如果内容是动态的，也许你可以使用Core Animation，如果还是行不通，使用Core Graphics。如果你真的想要接近底层，使用GLKit和原生OpenGL也不是那么难，但是需要做很多工作。</p>

<p>如果你真的选择了重写<code>drawRect:</code>，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，并且当视图的frame改变时并不会重新绘制。</p>

<h2>自定义交互</h2>

<p>正如之前所说的，自定义控件的时候，你几乎一定会扩展一个UIControl的子类。在你的子类里，可以使用目标-动作机制触发事件，如下面的例子:</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>为了响应触摸，你可能更倾向于使用手势识别。然而如果想要更接近底层，仍然可以重写<code>touchesBegan</code>，<code>touchesMoved</code>和<code>touchesEnded</code>方法来访问原始的触摸行为。但虽说如此，创建一个手势识别的子类来把手势处理相关的逻辑从你的视图或者视图控制器中分离出来，在很多情况下都是一种更合适的方式。</p>

<p>创建自定义控件时所面对的一个普遍的设计问题是向拥有它们的类中回传返回值。比如，假设你创建了一个绘制交互饼状图的自定义控件，想知道用户何时选择了其中一个部分。你可以用很多种不同的方法来解决这个问题，比如通过目标-动作模式，代理，block或者KVO，甚至通知。</p>

<h3>目标-动作</h3>

<p>老式的，通常也是最方便的方法是使用目标-动作。在用户选择后你可以在自定义的视图中做类似这样的事情:</p>

<p><code>objc
[self sendActionsForControlEvents:UIControlEventValueChanged];
</code></p>

<p>如果有一个视图控制器在管理这个视图，需要:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addTarget:self 
                  action:@selector(updateSelection:)
        forControlEvents:UIControlEventValueChanged];
</code></pre>

<p>}</p>

<ul>
<li>(void)updateSelection:(id)sender
{
  NSLog(@&ldquo;%@&rdquo;, self.pieChart.selectedSector);
}
```</li>
</ul>


<p>这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持。</p>

<h3>代理</h3>

<p>如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。在我们的饼状图中，代码看起来大概是这样:</p>

<p><code>objc
[self.delegate pieChart:self didSelectSector:self.selectedSector];
</code></p>

<p>在视图控制器中，你要写如下代码:</p>

<p>```objc
@interface MyViewController <PieChartDelegate></p>

<p> &hellip;</p>

<ul>
<li><p>(void)setupPieChart
{
  self.pieChart.delegate = self;
}</p></li>
<li><p>(void)pieChart:(PieChart<em>)pieChart didSelectSector:(PieChartSector</em>)sector
{
  // Handle the sector
}
```</p></li>
</ul>


<p>当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。不过虽然大多数开发人员可以非常快速的实现自定义代理，但这种方式仍然有一些缺点:你有必要检查代理是否实现了你想要调用的方法(使用<code>respondsToSelector:</code>)，最重要的，通常你只有一个代理(或者需要创建一个代理数组)。也就是说，一旦视图所有者和视图之间的通信变得稍微复杂，我们几乎总是会采取这种模式。</p>

<h3>Block</h3>

<p>另一个选择是使用block。再一次用饼状图举例，代码看起来大概是这样:</p>

<p>```objc
@interface PieChart : UIControl</p>

<p>@property (nonatomic,copy) void(^selectionHandler)(PieChartSection* selectedSection);</p>

<p>@end
```</p>

<p>在选取行为的代码中，只需要执行它。在此之前检查一下block是否被赋值非常重要，因为执行一个未被赋值的block会使程序崩溃。</p>

<p>```objc
if (self.selectionHandler != NULL) {</p>

<pre><code>self.selectionHandler(self.selectedSection);
</code></pre>

<p>}
```</p>

<p>这种方法的好处是可以把相关的代码在视图控制器中整合:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>self.pieChart.selectionHandler = ^(PieChartSection* section) {
    // Do something with the section
}
</code></pre>

<p>}
```</p>

<p>就像代理，每个动作通常只有一个block。另一个重要的限制是不要形成引用循环。如果你的视图控制器持有饼状图的强引用，饼状图持有block，block又持有视图控制器，就形成了一个引用循环。只要在block中引用self就会造成这个错误。所以通常代码会以这样结束:</p>

<p>```objc
__weak id weakSelf = self;
self.pieChart.selectionHandler = ^(PieChartSection* section) {</p>

<pre><code>MyViewController* strongSelf = weakSelf;
[strongSelf handleSectionChange:section];
</code></pre>

<p>}
```</p>

<p>一旦block中的代码要失去控制(比如block中要处理的事情太多，导致block中的代码过多)，你还可以将它们抽离成独立的方法，而且你可能也已经使用了代理。</p>

<h3>KVO</h3>

<p>如果喜欢KVO，你也可以用它来观察。这有一点神奇而且没那么直接，但当应用中已经使用，它是很好的解耦的设计模式。在饼状图类中，编写代码:</p>

<p><code>objc
self.selectedSegment = theNewSelectedSegment;
</code></p>

<p>当使用合成属性，KVO会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[self.pieChart addObserver:self forKeyPath:@"selectedSegment" options:0 context:NULL];
</code></pre>

<p>}</p>

<ul>
<li>(void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context
{
  if(object == self.pieChart &amp;&amp; [keyPath isEqualToString:@&ldquo;selectedSegment&rdquo;]) {
      // Handle change
  }
}
```</li>
</ul>


<p>根据你的需要，在<code>viewWillDisappear:</code>或<code>dealloc</code>中，还需要移除观察者。对同一个对象设置多个观察者很容易造成混乱。有一些技术可以解决这个问题，比如<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>或者更轻量级的<a href="https://github.com/th-in-gs/THObserversAndBinders">THObserversAndBinders</a>。</p>

<h3>通知</h3>

<p>作为最后一个选择，如果你想要一个非常松散的耦合，可以使用通知来使其他对象得知变化。对于饼状图来说你几乎肯定不想这样，不过为了讲解的完整，这里介绍如何去做。在饼状图的的头文件中:</p>

<p><code>objc
extern NSString* const SelectedSegmentChangedNotification;
</code></p>

<p>在实现文件中:</p>

<p>```objc
NSString* const SelectedSegmentChangedNotification = @&ldquo;selectedSegmentChangedNotification&rdquo;;</p>

<p>&hellip;</p>

<ul>
<li>(void)notifyAboutChanges
{
  [[NSNotificationCenter defaultCenter] postNotificationName:SelectedSegmentChangedNotification object:self];
}
```</li>
</ul>


<p>现在订阅通知，在视图控制器中：</p>

<p>```objc
&ndash; (void)setupPieChart
{</p>

<pre><code>[[NSNotificationCenter defaultCenter] addObserver:self 
                                       selector:@selector(segmentChanged:) 
                                           name:SelectedSegmentChangedNotification
                                          object:self.pieChart];
</code></pre>

<p>}</p>

<p>&hellip;</p>

<ul>
<li>(void)segmentChanged:(NSNotification*)note
{
}
```</li>
</ul>


<p>当添加了观察者，你可以不将饼状图作为参数<code>object</code>，而是传递<code>nil</code>，以接收所有饼状图对象发出的通知。就像KVO通知，你也需要在恰当的地方退订这些通知。</p>

<p>这项技术的好处是完全的解耦。另一方面，你失去了类型安全，因为在回调中你得到的是一个通知对象，而不像代理，编译器无法检查通知发送者和接受者之间的类型是否匹配。</p>

<h2>辅助功能</h2>

<p>苹果官方提供的标准iOS控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。</p>

<p>这或许可以作为一整期的主题，但是如果你编写自定义视图，<a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/iPhoneAccessibility/Accessibility_on_iPhone/Accessibility_on_iPhone.html#//apple_ref/doc/uid/TP40008785-CH100-SW3">Accessibility Programming Guide</a>说明了如何创建控件辅助功能。最为值得注意的是，如果有一个视图中有多个需要辅助功能的元素，但它们并不是该视图的子视图，你可以让视图实现<code>UIAccessibilityContainer</code>协议。对于每一个元素，返回一个描述它的<code>UIAccessibilityElement</code>对象。</p>

<h2>本地化</h2>

<p>创建自定义视图时，本地化也同样重要。如辅助功能一样，这个可以作为一整期的话题。本地化自定义视图的最直接工作就是字符串内容。如果使用<code>NSString</code>，你不必担心编码问题。如果在自定义视图中展示日期或数字，使用日期和数字格式化类来展示它们。使用<code>NSLocalizedString</code>本地化字符串。</p>

<p>另一个本地化过程中很有用的工具是Auto Layout。例如，有在英文中很短的词在德语中可能会很长。如果根据英文单词的长度对视图的尺寸做硬编码，那么当翻译成德文的时候几乎一定会遇上麻烦。通过使用Auto Layout，让标签控件自动调整为内容的尺寸，并向依赖元素添加一些其他的限制以确保重新设置尺寸，使这项工作变得非常简单。苹果为此提供了一个很好的<a href="http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/chapters/InternationalizeYourApp/InternationalizeYourApp/InternationalizeYourApp.html">introduction</a>。另外，对于类似希伯来语这种顺序从右到左的语言，如果你使用了leading和trailing属性，整个视图会自动按照从右到左的顺序展示，而不是硬编码的从左至右。</p>

<h2>测试</h2>

<p>最后，让我们考虑测试视图的问题。对于单元测试，你可以使用Xcode自带的工具或者其它第三方框架。另外，可以使用UIAutomation或者其它基于它的工具。为此，你的视图完全支持辅助功能是必要的。UIAutomation并未充分得到利用的一个功能是截图;你可以用它<a href="http://jeffkreeftmeijer.com/2011/comparing-images-and-creating-image-diffs/">自动对比</a>视图和设计以确保两者每一个像素都分毫不差。(另一个无关的功能:你还可以使用它来为应用<a href="http://www.smallte.ch/blog-read_en_29001.html">自动生成截图</a>，这在你有多个多国语言的应用时特别有用)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正确定义Objective-C常量]]></title>
    <link href="http://objcio.com/blog/2014/02/14/correct-way-of-defining-constants-in-objective-c/"/>
    <updated>2014-02-14T11:39:00+08:00</updated>
    <id>http://objcio.com/blog/2014/02/14/correct-way-of-defining-constants-in-objective-c</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://walkingsmarts.com/correct-way-of-defining-constants-in-objective-c/">Correct Way of Defining Constants in Objective-C</a>，转载请注明出处。</p>

<p>本文只是一个关于如何在Cocoa代码中定义常量的书签贴，答案来自于<a href="http://stackoverflow.com/questions/538996/constants-in-objective-c">stackoverflow.com的这个问题</a>。这里为那些懒人提供了一些简短的介绍和帖子本身。你可能读遍了苹果开发者文档，知道一些特定的方法参数只能接受定义为常量的枚举值列表。比如事件类型标记(<code>NSKeyUpMask</code>，<code>NSKeyDownMask</code>，等等)，persistent store coordinator的存储类型(<code>NSSQLiteStoreType</code>，<code>NSBinaryStoreType</code>和<code>NSInMemoryStoreType</code>)，当然还有很多其他的。所有的这些归结为几行代码。实际上定义常量的时候代码行数是你想要的常量的两倍。步骤为:首先，创建<code>Constants.h</code>和<code>Constants.m</code>文件用来存放我们的常量。在<code>Constants.h</code>中，指定常量名字，将常量声明为一个指向<code>NSString</code>对象的指针:</p>

<p><code>objc
// Constants.h
extern NSString * const MyOwnConstant;
extern NSString * const YetAnotherConstant;
</code></p>

<p>最后，在<code>Constants.m</code>中通过赋值定义常量:</p>

<p><code>objc
// Constants.m
NSString * const MyOwnConstant = @"myOwnConstant";
NSString * const  YetAnotherConstant = @"yetAnotherConstant";
</code></p>

<p>现在你所需要做的只是引入<code>Constants.h</code>文件到你工程的预编译头文件。如果你有点小聪明，可能脑中会有两个问题。第一个问题或许是:在能够使用<code>#define</code>的情况下为什么要使用这种方法?这是个非常有意义的问题。答案很简单(但是在读到<a href="http://stackoverflow.com/questions/538996/constants-in-objective-c/539191#539191">这个答案</a>之前还不是很明显) &mdash; 使用这种方法你可以进行指针比较(<code>@"myString" == MyConstant</code>)而不是字符串比较(<code>[@"myString" isEqualToString:MyConstant]</code>)。前者非常非常快。第二个问题应该是为什么应该完全使用常量。又一个有意义的问题。你可以在每个使用常量的地方使用常量对应的值。但是有两个"但是"。第一，始终有人的因素。你很容易输入错字符串，而编译器并不会抱怨你的语法。但如果使用常量，它就会在你输入错常量名称的时候给予你警告。还有(第二个"但是")，XCode会尽最大努力的帮助我们自动完成代码，这些常量也不例外，因此方法会变得非常方便。Happy coding!</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Migrant]]></title>
  <link href="http://objcio.com/atom.xml" rel="self"/>
  <link href="http://objcio.com/"/>
  <updated>2014-11-26T10:24:35+08:00</updated>
  <id>http://objcio.com/</id>
  <author>
    <name><![CDATA[Migrant]]></name>
    <email><![CDATA[tomigrant@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Metal]]></title>
    <link href="http://objcio.com/blog/2014/11/26/metal/"/>
    <updated>2014-11-26T10:03:00+08:00</updated>
    <id>http://objcio.com/blog/2014/11/26/metal</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-18/metal.html">Metal</a>，感谢 <a href="http://onevcat.com/">onevcat</a> 校对，转载请注明出处。本文亦被收录于 <a href="http://objccn.io/">objc中国</a>。</p>

<blockquote><p>Mental 框架支持 GPU 加速高级 3D 图像渲染，以及数据并行计算工作。Mental 提供了先进合理的 API，它不仅为图形的组织、处理和呈现，也为计算命令以及为这些命令相关的数据和资源的管理，提供了细粒度和底层的控制。Mental 的主要目的是最小化 GPU 工作时 CPU 所要的消耗。</p></blockquote>

<p>– <a href="https://developer.apple.com/library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40014221-CH1-SW1">Metal Programming Guide</a></p>

<p>Mental 是针对 iPhone 和 iPad 中 GPU 编程的高度优化的框架。其名字来源是因为 Metal 是 iOS 平台中最底层的图形框架 (意指 &ldquo;最接近硬件&rdquo;)。</p>

<p>该框架被设计用来实现两个目标: 3D 图形渲染和并行计算。这两者有很多共同点。它们都在数量庞大的数据上并行运行特殊的代码，并可以在 <a href="https://en.wikipedia.org/wiki/Graphics_processing_unit">GPU</a>.  上执行。</p>

<!--more-->


<h2>什么人应该使用 Mental?</h2>

<p>在谈论 API 和语言本身之前，我们应该讨论一下什么样的开发者能从 Metal 中受益。正如上面提过的，Metal 提供两个功能: 图形渲染和并行计算。</p>

<p>对于寻找游戏引擎的开发者来说，Metal 不是最佳选择。苹果官方的的 <a href="https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/">Scene Kit</a> (3D) 和 <a href="https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Introduction/Introduction.html">Sprite Kit</a> (2D) 是更好的选择。这些 API 提供了包括物理模拟在内的更高级别的游戏引擎。另外还有功能更全面的 3D 引擎，例如 Epic 的 <a href="https://www.unrealengine.com/">Unreal Engine</a> 或 <a href="http://unity3d.com">Unity</a>，二者都是跨平台的。使用这些引擎，你无需直接使用 Metal 的 API，就可以从 Metal 中获益。</p>

<p>编写基于底层图形 API 的渲染引擎时，除了 Metal 以外的其他选择还有 OpenGL 和 OpenGL ES。OpenGL 不仅支持包括 OSX，Windows，Linux 和 Android 在内的几乎所有平台，还有大量的教程，书籍和最佳实践指南等资料。目前，Metal 的资源非常有限，并且仅限于搭载了 64 位处理器的 iPhone 和 iPad。但另外一方面，因为 OpenGL 的限制，其性能与 Metal 相比并不占优势，毕竟后者是专门用来解决这些问题的。</p>

<p>如果想要一个 iOS 上高性能的并行计算库，答案非常简单。Metal 是唯一的选择。OpenCL 在 iOS 上是私有框架，而 Core Image (使用了 OpenCL) 对这样的任务来说既不够强大又不够灵活。</p>

<h2>使用 Metal 的好处</h2>

<p>Metal 的最大好处就是与 OpenGL ES 相比显著降低了消耗。在 OpenGL 中无论创建缓冲区还是纹理，OpenGL 都会复制一份以防止 GPU 在使用它们的时候被意外访问。出于安全的原因复制类似纹理和缓冲区这样的大的资源是非常耗时的操作。而 Metal 并不复制资源。开发者需要负责在 CPU 和 GPU 之间同步访问。幸运的是，苹果提供了另一个很棒的 API 使资源同步访问更加容易，那就是 <a href="https://developer.apple.com/library/ios/documentation/Performance/Reference/GCD_libdispatch_Ref/index.html">Grand Central Dispatch</a>。虽然使用 Metal 时仍然有些这方面的问题需要注意，但是一个在渲染时加载和卸载资源的先进的引擎，在避免额外的复制后能够获得更多的好处。</p>

<p>Metal 的另外一个好处是其预估 GPU 状态来避免多余的验证和编译。通常在 OpenGL 中，你需要依次设置 GPU 的状态，在每个绘制指令 (draw call) 之前需要验证新的状态。最坏的情况是 OpenGL 需要再次重新编译着色器 (shader) 以反映新的状态。当然，这种评估是必要的，但 Metal 选择了另一种方法。在渲染引擎初始化过程中，一组状态被烘焙 (bake) 至预估渲染的 路径 (pass) 中。多个不同资源可以共同使用该渲染路径对象，但其它的状态是恒定的。Metal 中一个渲染路径无需更进一步的验证，使 API 的消耗降到最低，从而大大增加每帧的绘制指令的数量。</p>

<h2>Metal API</h2>

<p>虽然这个平台上许多 API 都暴露为具体的类，但 Metal 提供的大多是协议。因为 Metal 对象的具体类型取决于 Metal 运行在哪个设备上。这更鼓励了面向接口而不是面向实现编程。然而，这同时也意味着，如果不使用 Objective-C 运行时的广泛而危险的操作，就不能子类化 Metal 的类或者为其增加扩展，</p>

<p>Metal 为了速度而在安全性上做了必要的妥协。对于错误，苹果的其它框架显得更加安全和健壮，而 Metal 则完全相反。在某些时候，你会收到指向内部缓冲区的裸指针，你必须小心的同步访问它。OpenGL 中发生错误时，结果通常是黑屏；然而在 Metal 中，结果可能是完全随机的效果，例如闪屏和偶尔的崩溃。之所以有这些陷阱，是因为 Metal 框架是对 GPU 的非常轻量级抽象。</p>

<p>一个有趣的方面是苹果并没有为 Metal 实现可以在 iOS 模拟器上使用的软件渲染。使用 Metal 框架的时候应用必须运行在真实设备上。</p>

<h2>基础 Metal 程序</h2>

<p>在这部分中，我们会介绍写出第一个 Metal 程序所必要的部分。这个简单的程序绘制了一个正方形的旋转。你可以在 <a href="https://github.com/warrenm/metal-demo-objcio">GitHub 中下载这篇文章的示例代码</a>。</p>

<p>虽然不能涵盖每一个细节，但我们尽量涉及至少所有的移动部分。你可以阅读源代码和参阅线上资源来深入理解。</p>

<h3>使用 UIKit 创建设备和界面</h3>

<p>在 Metal 中，<strong>设备</strong>是 GPU 的抽象。它被用来创建很多其它类型的对象，例如缓冲区，纹理和函数库。使用 <code>MTLCreateSystemDefaultDevice</code> 函数来获取默认设备:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLDevice</span><span class="o">&gt;</span> <span class="n">device</span> <span class="o">=</span> <span class="n">MTLCreateSystemDefaultDevice</span><span class="p">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意 device 并不是一个详细具体的类，正如前面提到的，它是遵循 <code>MTLDevice</code> 协议的类。</p>

<p>下面的代码展示了如何创建一个 Metal layer 并将它作为 sublayer 添加到一个 UIView 的 layer:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">CAMetalLayer</span> <span class="o">*</span><span class="n">metalLayer</span> <span class="o">=</span> <span class="p">[</span><span class="n">CAMetalLayer</span> <span class="n">layer</span><span class="p">];</span>
</span><span class='line'><span class="n">metalLayer</span><span class="p">.</span><span class="n">device</span> <span class="o">=</span> <span class="n">device</span><span class="p">;</span>
</span><span class='line'><span class="n">metalLayer</span><span class="p">.</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">MTLPixelFormatBGRA8Unorm</span><span class="p">;</span>
</span><span class='line'><span class="n">metalLayer</span><span class="p">.</span><span class="n">frame</span> <span class="o">=</span> <span class="n">view</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'><span class="p">[</span><span class="n">view</span><span class="p">.</span><span class="n">layer</span> <span class="nl">addSublayer:</span><span class="n">self</span><span class="p">.</span><span class="n">metalLayer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>CAMetalLayer</code> 是 <a href="https://developer.apple.com/library/mac/Documentation/GraphicsImaging/Reference/CALayer_class/index.html"><code>CALayer</code></a> 的子类，它可以展示 Metal 帧缓冲区的内容。我们必须告诉 layer 该使用哪个 Metal 设备 (我们刚创建的那个)，并通知它所预期的像素格式。我们选择 8-bit-per-channel BGRA 格式，即每个像素由蓝，绿，红和透明组成，值从 0-255。</p>

<h3>库和函数</h3>

<p>你的 Metal 程序的很多功能会被用顶点和片段函数的方式书写，也就是我们所说的着色器。Metal 着色器用 Metal 着色器语言编写，我们将在下面详细讨论。Metal 的优点之一就是着色器函数在你的应用构建到中间语言时进行编译，这可以节省很多应用启动时所需的时间。</p>

<p>一个 Metal 库是一组函数的集合。你的所有写在工程内的着色器函数都将被编译到默认库中，这个库可以通过设备获得:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLLibrary</span><span class="o">&gt;</span> <span class="n">library</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="n">newDefaultLibrary</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来构建渲染管道状态的时候将使用这个库。</p>

<h3>命令队列</h3>

<p>命令通过与 Metal 设备相关联的命令队列提交给 Metal 设备。命令队列以线程安全的方式接收命令并顺序执行。创建一个命令队列:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLCommandQueue</span><span class="o">&gt;</span> <span class="n">commandQueue</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="n">newCommandQueue</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>构建管道</h3>

<p>当我们在 Metal 编程中提到管道，指的是顶点数据在渲染时经历的变化。顶点着色器和片段着色器是管道中两个可编程的节点，但还有其它一定会发生的事件 (剪切，栅格化和视图变化) 不在我们的直接控制之下。管道特性中的后者的类组成了固定功能管道。</p>

<p>在 Metal 中创建一个管道，我们需要指定对于每个顶点和每个像素分别想要执行哪个顶点和片段函数 (译者注: 片段着色器又被称为像素着色器)。我们还需要将帧缓冲区的像素格式告诉管道。在本例中，该格式必须与 Metal layer 的格式匹配，因为我们想在屏幕上绘制。</p>

<p>从库中通过名字来获取函数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLFunction</span><span class="o">&gt;</span> <span class="n">vertexProgram</span> <span class="o">=</span> <span class="p">[</span><span class="n">library</span> <span class="nl">newFunctionWithName:</span><span class="s">@&quot;vertex_function&quot;</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLFunction</span><span class="o">&gt;</span> <span class="n">fragmentProgram</span> <span class="o">=</span> <span class="p">[</span><span class="n">library</span> <span class="nl">newFunctionWithName:</span><span class="s">@&quot;fragment_function&quot;</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来创建一个设置了函数和像素格式的管道描述器:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MTLRenderPipelineDescriptor</span> <span class="o">*</span><span class="n">pipelineStateDescriptor</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MTLRenderPipelineDescriptor</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">pipelineStateDescriptor</span> <span class="nl">setVertexFunction:</span><span class="n">vertexProgram</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">pipelineStateDescriptor</span> <span class="nl">setFragmentFunction:</span><span class="n">fragmentProgram</span><span class="p">];</span>
</span><span class='line'><span class="n">pipelineStateDescriptor</span><span class="p">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">pixelFormat</span> <span class="o">=</span> <span class="n">MTLPixelFormatBGRA8Unorm</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，我们从描述器中创建管道状态。这会根据程序运行的硬件环境，从中间代码中编译着色器函数为优化后的代码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLRenderPipelineState</span><span class="o">&gt;</span> <span class="n">pipelineState</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="nl">newRenderPipelineStateWithDescriptor:</span><span class="n">pipelineStateDescriptor</span> <span class="nl">error:</span><span class="nb">nil</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>读取数据到缓冲区</h3>

<p>现在已经有了一个构建好的管道，我们需要用数据填充它。在示例工程中，我们绘制了一个简单的几何图形: 一个旋转的正方形。正方形由两个共享一条边的直角三角形组成:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">static</span> <span class="kt">float</span> <span class="n">quadVertexData</span><span class="p">[]</span> <span class="o">=</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'>    <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'>    <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'>
</span><span class='line'>     <span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'>     <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'>    <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span>  <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>     <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>每一行的前四个数字代表了每一个顶点的 x，y，z 和 w 元素。后四个数字代表每个顶点的红色，绿色，蓝色和透明值元素。</p>

<p>你可能会奇怪为什么需要四个数字来描述 3D 空间中的一个位置。第四个顶点位置元素，w，是一个数学上的便利，使我们能以一种统一的方式描述 3D 转换 (旋转，平移，缩放)。这个细节在本文的示例代码并没有体现。</p>

<p>为了使用 Metal 绘制顶点数据，我们需要将它放入缓冲区。缓冲区是被 CPU 和 GPU 共享的简单的无结构的内存块:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">vertexBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="nl">newBufferWithBytes:</span><span class="n">quadVertexData</span>
</span><span class='line'>                                       <span class="nl">length:</span><span class="k">sizeof</span><span class="p">(</span><span class="n">quadVertexData</span><span class="p">)</span>
</span><span class='line'>                                      <span class="nl">options:</span><span class="n">MTLResourceOptionCPUCacheModeDefault</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们将使用另一个缓冲区来存储用来旋转正方形的旋转矩阵。与预先提供数据不同，这里只是通过创建规定长度的缓冲区来创建一个空间。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">uniformBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">device</span> <span class="nl">newBufferWithLength:</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Uniforms</span><span class="p">)</span>
</span><span class='line'>                                        <span class="nl">options:</span><span class="n">MTLResourceOptionCPUCacheModeDefault</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>动画</h3>

<p>为了在屏幕上旋转正方形，我们需要把转换顶点作为顶点着色器的一部分。这需要更新每一帧的统一缓冲区。我们运用三角学知识，从当前旋转角度生成一个旋转矩阵，将它复制到统一缓冲区。</p>

<p><code>Uniforms</code> 结构体只有一个成员，该成员是一个保存了旋转矩阵的 4x4 的矩阵。矩阵类型 <code>matrix_float4x4</code> 来自于苹果的 SIMD 库，该库是一个类型的集合，它们可以从 <a href="http://en.wikipedia.org/wiki/SIMD">数据并行操作</a> 中获益:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">matrix_float4x4</span> <span class="n">rotation_matrix</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">Uniforms</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了将旋转矩阵复制到统一缓冲区中，我们取得它的内容的指针并将矩阵 <code>memcpy</code> 进去:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Uniforms</span> <span class="n">uniforms</span><span class="p">;</span>
</span><span class='line'><span class="n">uniforms</span><span class="p">.</span><span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">rotation_matrix_2d</span><span class="p">(</span><span class="n">rotationAngle</span><span class="p">);</span>
</span><span class='line'><span class="kt">void</span> <span class="o">*</span><span class="n">bufferPointer</span> <span class="o">=</span> <span class="p">[</span><span class="n">uniformBuffer</span> <span class="n">contents</span><span class="p">];</span>
</span><span class='line'><span class="n">memcpy</span><span class="p">(</span><span class="n">bufferPointer</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uniforms</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Uniforms</span><span class="p">));</span>
</span></code></pre></td></tr></table></div></figure>


<h3>准备绘制</h3>

<p>为了在 Metal layer 上绘制，首先我们需要从 layer 中获得一个 &lsquo;drawable&rsquo; 对象。这个可绘制对象管理着一组适合渲染的纹理:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">CAMetalDrawable</span><span class="o">&gt;</span> <span class="n">drawable</span> <span class="o">=</span> <span class="p">[</span><span class="n">metalLayer</span> <span class="n">nextDrawable</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来我们创建一个渲染路径描述器，它描述了在渲染之前和完成之后 Metal 应该执行的不同动作。下面我们展示了一个渲染路径，它将首先把帧缓冲区清除为纯白色，然后执行绘制指令，最后将结果存储到帧缓冲区来展示:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MTLRenderPassDescriptor</span> <span class="o">*</span><span class="n">renderPassDescriptor</span> <span class="o">=</span> <span class="p">[</span><span class="n">MTLRenderPassDescriptor</span> <span class="n">renderPassDescriptor</span><span class="p">];</span>
</span><span class='line'><span class="n">renderPassDescriptor</span><span class="p">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">texture</span> <span class="o">=</span> <span class="n">drawable</span><span class="p">.</span><span class="n">texture</span><span class="p">;</span>
</span><span class='line'><span class="n">renderPassDescriptor</span><span class="p">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">loadAction</span> <span class="o">=</span> <span class="n">MTLLoadActionClear</span><span class="p">;</span>
</span><span class='line'><span class="n">renderPassDescriptor</span><span class="p">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">clearColor</span> <span class="o">=</span> <span class="n">MTLClearColorMake</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="n">renderPassDescriptor</span><span class="p">.</span><span class="n">colorAttachments</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">storeAction</span> <span class="o">=</span> <span class="n">MTLStoreActionStore</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>发布绘制指令</h3>

<p>要放入设备的命令队列的命令必须被编码到命令缓冲区里。命令缓冲区是一个或多个命令的集合，可以以一种 GPU 了解的紧凑的方式执行和编码。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLCommandBuffer</span><span class="o">&gt;</span> <span class="n">commandBuffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">commandQueue</span> <span class="n">commandBuffer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了真正编码渲染命令，我们还需要另一个知道如何将我们的绘制指令转换为 GPU 懂得的语言的对象。这个对象叫做命令编码器。我们将上面创建的渲染路径描述器作为参数传入，就可以向命令缓冲区请求一个编码器:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span><span class="o">&lt;</span><span class="n">MTLRenderCommandEncoder</span><span class="o">&gt;</span> <span class="n">renderEncoder</span> <span class="o">=</span> <span class="p">[</span><span class="n">commandBuffer</span> <span class="nl">renderCommandEncoderWithDescriptor:</span><span class="n">renderPassDescriptor</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在绘制指令之前，我们使用预编译的管道状态设置渲染命令编码器并建立缓冲区，该缓冲区将作为顶点着色器的参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">renderEncoder</span> <span class="nl">setRenderPipelineState:</span><span class="n">pipelineState</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">renderEncoder</span> <span class="nl">setVertexBuffer:</span><span class="n">vertexBuffer</span> <span class="nl">offset:</span><span class="mi">0</span> <span class="nl">atIndex:</span><span class="mi">0</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">renderEncoder</span> <span class="nl">setVertexBuffer:</span><span class="n">uniformBuffer</span> <span class="nl">offset:</span><span class="mi">0</span> <span class="nl">atIndex:</span><span class="mi">1</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了真正的绘制几何图形，我们告诉 Metal 要绘制的形状 (三角形) 和缓冲区中顶点的数量 (本例中 6 个):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">renderEncoder</span> <span class="nl">drawPrimitives:</span><span class="n">MTLPrimitiveTypeTriangle</span> <span class="nl">vertexStart:</span><span class="mi">0</span> <span class="nl">vertexCount:</span><span class="mi">6</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，执行 <code>endEncoding</code> 通知编码器发布绘制指令完成。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">renderEncoder</span> <span class="n">endEncoding</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<h3>展示帧缓冲区</h3>

<p>现在我们的绘制指令已经被编码并准备就绪，我们需要通知命令缓冲区应该将结果在屏幕上显示出来。调用  <code>presentDrawable</code>，使用当前从 Metal layer 中获得的 drawable 对象作为参数:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">commandBuffer</span> <span class="nl">presentDrawable:</span><span class="n">drawable</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>执行 <code>commit</code> 告诉缓冲区已经准备好安排并执行:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">commandBuffer</span> <span class="n">commit</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>就这么多！</p>

<h2>Metal 着色语言</h2>

<p>虽然 Metal 和 <a href="https://developer.apple.com/swift/">Swift</a> 是在 <a href="https://www.apple.com/apple-events/june-2014/">WWDC keynote</a> 上被一同发表的，但着色语言是基于 <a href="https://en.wikipedia.org/wiki/C%2B%2B11">C++11</a> 的，有一些有限制的特性和增加的关键字。</p>

<h3>Metal 着色语言实践</h3>

<p>为了在着色器里使用顶点数据，我们定义了一个对应 Objective-C 中顶点数据的结构体：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='glsl'><span class='line'><span class="k">typedef</span> <span class="k">struct</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">float4</span> <span class="n">position</span><span class="p">;</span>
</span><span class='line'>    <span class="n">float4</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">VertexIn</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们还需要一个类似的结构体来描述从顶点着色器传入片段着色器的顶点类型。然而，在本例中，我们必须区分 (通过使用 <code>[[position]]</code> 属性) 哪一个结构体成员应该被看做是顶点位置:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='glsl'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'> <span class="n">float4</span> <span class="n">position</span> <span class="p">[[</span><span class="n">position</span><span class="p">]];</span>
</span><span class='line'> <span class="n">float4</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">VertexOut</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>顶点函数在顶点数据中每个顶点被执行一次。它接收顶点列表的一个指针，和一个包含旋转矩阵的统一数据的引用。第三个参数是一个索引，用来告诉函数当前操作的是哪个顶点。</p>

<p>注意顶点函数的参数后面紧跟着标明它们用途的属性。在缓冲区参数中，参数中的索引对应着我们在渲染命令编码器中设置缓冲区时指定的索引。Metal 就是这样来区分哪个参数对应哪个缓冲区。</p>

<p>在顶点函数中，我们用顶点的位置乘以旋转矩阵。我们构建矩阵的方式决定了效果是围绕中心旋转正方形。接着我们将这个转换过的位置传入输出顶点。顶点颜色则从输入参数中直接复制。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='glsl'><span class='line'><span class="n">vertex</span> <span class="n">VertexOut</span> <span class="n">vertex_function</span><span class="p">(</span><span class="n">device</span> <span class="n">VertexIn</span> <span class="o">*</span><span class="n">vertices</span> <span class="p">[[</span><span class="n">buffer</span><span class="p">(</span><span class="mo">0</span><span class="p">)]],</span>
</span><span class='line'>                                     <span class="n">constant</span> <span class="n">Uniforms</span> <span class="o">&amp;</span><span class="n">uniforms</span> <span class="p">[[</span><span class="n">buffer</span><span class="p">(</span><span class="mi">1</span><span class="p">)]],</span>
</span><span class='line'>                                     <span class="n">uint</span> <span class="n">vid</span> <span class="p">[[</span><span class="n">vertex_id</span><span class="p">]])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">VertexOut</span> <span class="k">out</span><span class="p">;</span>
</span><span class='line'>    <span class="k">out</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">uniforms</span><span class="p">.</span><span class="n">rotation_matrix</span> <span class="o">*</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vid</span><span class="p">].</span><span class="n">position</span><span class="p">;</span>
</span><span class='line'>    <span class="k">out</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">[</span><span class="n">vid</span><span class="p">].</span><span class="n">color</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">out</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>片段函数每个像素就会被执行一次。Metal 在 <a href="http://fgiesen.wordpress.com/2013/02/08/triangle-rasterization-in-practice/">rasterization</a> 过程中会通过在每个顶点中指定的位置和颜色参数中添加来生成参数。在这个简单的片段函数中，我们只是简单的返回了 Metal 添加的颜色。这会成为屏幕像素的颜色:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">fragment</span> <span class="n">float4</span> <span class="nf">fragment_function</span><span class="p">(</span><span class="n">VertexOut</span> <span class="k">in</span> <span class="p">[[</span><span class="n">stage_in</span><span class="p">]])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">in</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>为什么不干脆扩展 OPENGL?</h2>

<p>苹果是 OpenGL 架构审查委员会的成员，并且历史上也在 iOS 上提供过它们自己的 GL 扩展。但从内部改变 OpenGL 看起来是个困难的任务，因为它有着不同的设计目标。实际上，它必须有广泛的硬件兼容性以运行在很多不同的设备上。虽然 OpenGL 还在持续发展，但速度缓慢。</p>

<p>而 Metal 则本来就是只为了苹果的平台而创建的。即使基于协议的 API 最初看起来不太常见，但和其它框架配合的很好。Metal 是用 Objective-C 编写的，基于 <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/ObjC_classic/index.html">Foundation</a>，使用 GCD 在 CPU 和 GPU 之间保持同步。它是更先进的 GPU 管道的抽象，而 OpenGL 想达到这些的话只能完全重写。</p>

<h2>Mac 上的 Metal?</h2>

<p>OS X 上支持 Metal 也是迟早的事。API 本身并不局限于 iPhone 和 iPad 使用的 ARM 架构的处理器。Metal 的大多数优点都可以移植到先进的 GPU 上。另外，iPhone 和 iPad 的 CPU 和 GPU 是共享内存的，无需复制就可以交换数据。这一代的 Mac 电脑并未提供共享内存，但这只是时间问题。或许，API 会被调整为支持使用了专门内存的架构，或者 Metal 只会运行在下一代的 Mac 电脑上。</p>

<h2>总结</h2>

<p>本文中我们尝试给出公正并有所帮助的关于 Metal 框架的介绍。</p>

<p>当然，大多数的游戏开发者并不会直接使用 Metal。然而，顶层的游戏引擎已经从中获益，并且开发者无需直接使用 API 就可以从最新的技术中得到好处。另外，对于那些想要发挥硬件全部性能的开发者来说，Metal 或许可以让他们在游戏中创建出与众不同而华丽的效果，或者进行更快的并行计算，从而得到竞争优势。</p>

<h2>资源</h2>

<ul>
<li><a href="https://developer.apple.com/Library/ios/documentation/Miscellaneous/Conceptual/MetalProgrammingGuide/Introduction/Introduction.html">Metal Programming Guide</a></li>
<li><a href="https://developer.apple.com/library/ios/documentation/Metal/Reference/MetalShadingLanguageGuide/Introduction/Introduction.html">Metal Shading Language Guide</a></li>
<li><a href="http://metalbyexample.com">Metal by Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义 URL Scheme 完全指南]]></title>
    <link href="http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes/"/>
    <updated>2014-05-21T11:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/21/the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://iosdevelopertips.com/cocoa/launching-your-own-application-via-a-custom-url-scheme.html">The Complete Tutorial on iOS/iPhone Custom URL Schemes</a>，转载请注明出处。</p>

<p><strong>注意</strong>: <em>自从自定义 URL 的引入，本文始终是我博客中阅读量最大的文章。虽然大多数都相同，但仍然有一些细微差别的变化。本文是原帖的重写版，更新为最新的 iOS 和 Xcode 版本。</em></p>

<p>iPhone / iOS SDK 最酷的特性之一就是应用将其自身&#8221;绑定&#8221;到一个自定义 URL scheme 上，该 scheme 用于从浏览器或其他应用中启动本应用。</p>

<h2>注册自定义 URL Scheme</h2>

<p>注册自定义 URL Scheme 的第一步是创建 URL Scheme &mdash; 在 Xcode Project Navigator 中找到并点击工程 info.plist 文件。当该文件显示在右边窗口，在列表上点击鼠标右键，选择 <em>Add Row</em>:</p>

<p>向下滚动弹出的列表并选择 <em>URL types</em>。</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-01.gif" alt="iOS Custom URL Scheme" /></p>

<p>点击左边剪头打开列表，可以看到 <em>Item 0</em>，一个字典实体。展开 <em>Item 0</em>，可以看到 <em>URL Identifier</em>，一个字符串对象。该字符串是你自定义的 URL scheme 的名字。建议采用反转域名的方法保证该名字的唯一性，比如 <em>com.yourCompany.yourApp</em>。</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-02.gif" alt="urlScheme2a" /></p>

<p>点击 <em>Item 0</em> 新增一行，从下拉列表中选择 <em>URL Schemes</em>，敲击键盘回车键完成插入。</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-03.gif" alt="iOS Custom URL Scheme" /></p>

<p>注意 URL Schemes 是一个数组，允许应用定义多个 URL schemes。</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-04.gif" alt="iOS Custom URL Scheme" /></p>

<p>展开该数据并点击 <em>Item 0</em>。你将在这里定义自定义 URL scheme 的名字。只需要名字，不要在后面追加 :// &mdash; 比如，如果你输入 iOSDevApp，你的自定义 url 就是 iOSDevApp://</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-05.gif" alt="iOS Custom URL Scheme" /></p>

<p>此时，整个定义如下图:</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-06.gif" alt="iOS Custom URL Scheme" /></p>

<p>虽然我赞同 Xcode 使用描述性的名字的目的，不过看到创建的实际的 key 也是非常有用的。这里有一个方便的技巧，右键点击 plist 并选择 <em>Show Raw Keys/Values</em>，就能看到以下效果:</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-07.png" alt="iOS Custom URL Scheme" /></p>

<p>还有另一种有用的输出格式，XML，因为可以非常容易的看到字典和原始数组及其包括的实体的结构。点击 plist 并选择 <em>Open As &ndash; Source Code</em>:</p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-08.gif" alt="iPhone Custom URL Scheme" /></p>

<!--more-->


<h2>从 Safari 中调用自定义 URL Scheme</h2>

<p>定义了 URL scheme，我们可以运行一个快速测试来验证应用是否如我们所期望的被调用。在这之前，我创建了一个准 UI 以辨别带有自定义 URL 的应用。该应用只有一个 UILabel，带有文本 &ldquo;App With Custom URL&#8221;。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-09.png" alt="iOS App with Custom URL" /></p>

<p>使用模拟器调用应用的步骤:</p>

<ul>
<li>在 Xcode 中运行应用</li>
<li>一旦应用被安装，自定义 URL scheme 就会被注册</li>
<li>通过模拟器的硬件菜单中选择 Home 来关闭应用</li>
<li>启动 Safari</li>
<li>在浏览器地址栏输入之前定义的 URL scheme(如下)</li>
</ul>


<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-10.png" alt="Call Custom URL Scheme from Safari" /></p>

<p>此时 Safari 将会关闭，应用会被带回到前台。祝贺你刚刚使用自定义 URL scheme 调用了一个 iPhone 应用。</p>

<h2>从另一个 iPhone 应用中调用自定义 URL Scheme</h2>

<p>让我们看看如何从另一个应用中调用自定义 URL scheme。我又创建了一个非常简单的 iPhone 应用，它只有一个 UILabel 和一个 UIButton &mdash; 前者显示了一段信息，告诉你这个应用将要通过自定义 URL scheme 来调用另一个应用，按钮则开始这个行为。<a href="http://iosdevelopertips.com/downloads/#customURLScheme">下载源代码</a></p>

<p><img src="http://objcio.com/images/posts/2014-05-21-the-complete-tutorial-on-ios-slash-iphone-custom-url-schemes-11.png" alt="iPhone app that call Custom URL Scheme" /></p>

<p>buttonPressed 方法中的代码处理 URL 调用:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">buttonPressed:</span><span class="p">(</span><span class="n">UIButton</span> <span class="o">*</span><span class="p">)</span><span class="nv">button</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">customURL</span> <span class="o">=</span> <span class="s">@&quot;iOSDevTips://&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="p">([[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span>
</span><span class='line'>    <span class="nl">canOpenURL:</span><span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="n">customURL</span><span class="p">]])</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">openURL:</span><span class="p">[</span><span class="n">NSURL</span> <span class="nl">URLWithString:</span><span class="n">customURL</span><span class="p">]];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle:</span><span class="s">@&quot;URL error&quot;</span>
</span><span class='line'>                          <span class="nl">message:</span><span class="p">[</span><span class="n">NSString</span> <span class="nl">stringWithFormat:</span>
</span><span class='line'>                            <span class="s">@&quot;No custom URL defined for %@&quot;</span><span class="p">,</span> <span class="n">customURL</span><span class="p">]</span>
</span><span class='line'>                          <span class="nl">delegate:</span><span class="n">self</span> <span class="nl">cancelButtonTitle:</span><span class="s">@&quot;Ok&quot;</span>
</span><span class='line'>                          <span class="nl">otherButtonTitles:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">alert</span> <span class="n">show</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第 5 行代码检查自定义 URL 是否被定义，如果定义了，则使用 shared application 实例来打开 URL (第 8 行)。openURL: 方法启动应用并将 URL 传入应用。在此过程中，当前的应用被退出。</p>

<h2>通过自定义 URL Scheme 向应用传递参数</h2>

<p>有时你需要通过自定义 URL 向应用中传递参数。让我们看看该如何完成这个工作。</p>

<p>NSURL 作为从一个应用调用另一个的基础，遵循 <a href="https://tools.ietf.org/html/rfc1808">RFC 1808</a> (Relative Uniform Resource Locators) 标准。 因此你所熟悉的基于网页内容的 URL 格式在这里也适用。</p>

<p>在自定义了 URL scheme 的应用中，app delegate 必须实现以下方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
</span><span class='line'>  <span class="nf">openURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
</span><span class='line'>  <span class="nf">sourceApplication:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">sourceApplication</span>
</span><span class='line'>  <span class="nf">annotation:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">annotation</span>
</span></code></pre></td></tr></table></div></figure>


<p>从一个应用传递参数到另一个的诀窍是通过 URL。例如，假设我们使用以下的 URL scheme，想传递一个名为 &ldquo;token&#8221;的参数和一个标识注册状态的标志，我们可以像这样创建一个 URL:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span> <span class="o">*</span><span class="n">customURL</span> <span class="o">=</span> <span class="s">@&quot;iOSDevTips://?token=123abct&amp;registered=1&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在 web 开发中，字符串 <em>?token=123abct&amp;registered=1</em> 被称作查询询串(query string).</p>

<p>在被调用(设置了自定义 URL)的应用的 app delegate 中，获取参数的代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">openURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
</span><span class='line'>        <span class="nf">sourceApplication:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">sourceApplication</span> <span class="nf">annotation:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">annotation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Calling Application Bundle ID: %@&quot;</span><span class="p">,</span> <span class="n">sourceApplication</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;URL scheme:%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">url</span> <span class="n">scheme</span><span class="p">]);</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;URL query: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">url</span> <span class="n">query</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以上代码在应用被调用时的输出为:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Calling</span> <span class="n">Application</span> <span class="n">Bundle</span> <span class="nl">ID:</span> <span class="n">com</span><span class="mf">.3</span><span class="n">Sixty</span><span class="p">.</span><span class="n">CallCustomURL</span>
</span><span class='line'><span class="n">URL</span> <span class="nl">scheme:</span><span class="n">iOSDevTips</span>
</span><span class='line'><span class="n">URL</span> <span class="nl">query:</span> <span class="n">token</span><span class="o">=</span><span class="mi">123</span><span class="n">abct</span><span class="o">&amp;</span><span class="n">registered</span><span class="o">=</span><span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意 &ldquo;Calling Application Bundle ID&#8221;，你可以用这个来确保只有你定义的应用可以与你的应用直接交互。</p>

<p>让我们改变一下代码，来验证发起调用的应用的 Bundle ID 是否合法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span> <span class="nf">openURL:</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="p">)</span><span class="nv">url</span>
</span><span class='line'>        <span class="nf">sourceApplication:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">sourceApplication</span> <span class="nf">annotation:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">annotation</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// Check the calling application Bundle ID</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">([</span><span class="n">sourceApplication</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;com.3Sixty.CallCustomURL&quot;</span><span class="p">])</span>
</span><span class='line'>  <span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Calling Application Bundle ID: %@&quot;</span><span class="p">,</span> <span class="n">sourceApplication</span><span class="p">);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;URL scheme:%@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">url</span> <span class="n">scheme</span><span class="p">]);</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;URL query: %@&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">url</span> <span class="n">query</span><span class="p">]);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有一点要特别注意，你不能阻止其他应用通过自定义 URL scheme 调用你的应用，然而你可以跳过后续的操作并返回 NO，就像上面的代码那样。也就是说，如果你想阻止其它应用调用你的应用，创建一个与众不同的 URL scheme。尽管这不能保证你的应用不会被调用，但至少大大降低了这种可能性。</p>

<h2>自定义 URL Scheme 示例工程</h2>

<p>我意识到按照本文的每一步做下来还是有一点复杂的。我做好了两个非常基础的 iOS 应用，一个自定义了 URL scheme，另一个则去调用它，并传递了一个比较短的参数列表(query string)。这些是体验自定义 URL 的很好的入门点。</p>

<ul>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app with Custom URL scheme</a></li>
<li><a href="http://iosdevelopertips.com/downloads/#customURLScheme">Download Xcode project for app to call custom URL scheme</a></li>
</ul>


<h2>其它资源</h2>

<p><a href="https://developer.apple.com/library/ios/documentation/Security/Conceptual/SecureCodingGuide/Articles/ValidatingInput.html#//apple_ref/doc/uid/TP40007246">How to Properly Validate URL Parameters</a>
<a href="https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007899">URL Scheme Reference Docs</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iBeacon 来了]]></title>
    <link href="http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon/"/>
    <updated>2014-05-01T22:36:00+08:00</updated>
    <id>http://objcio.com/blog/2014/05/01/can-you-smell-the-ibeacon</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.cocoanetics.com/2013/11/can-you-smell-the-ibeacon/">Can you Smell the iBeacon?</a>，转载请注明出处。</p>

<p>虽然我们还未看到任何实际生活中的使用案例，但 iBeacon 绝对是 iOS 7 带来的最热门的新话题之一。</p>

<p>上周我收到了我的 <a href="https://preorder.estimote.com/">Developer Preview Kit from Estimote</a>，为了将其收入我正在写作的新书中，我开始研究 iBeacon。下面是我的发现。</p>

<p>为了理解两种操作模式的不同之处，有两个词你应该知道:</p>

<ul>
<li><strong>Monitoring</strong> &ndash; 涉及小功率区域监测，接收 didEnterRegion: 和 didExitRegion: 代理消息。</li>
<li><strong>Ranging</strong> &ndash; 意味着大功率活动，此时你能从各个 iBeacon 收到信号强度并能够估计此刻与它们的距离。</li>
</ul>


<p>iOS 7 之前苹果给我们提供了监测设备将要进入或离开某一个特定区域的能力，其核心是 <code>CLRegion</code>。该技术围绕着地理位置和进入或退出该位置时将要发生的事情。更好的是，如果你在 info.plist 中指定了接收后台位置更新，那么系统可以在区域边界处激活你的应用。</p>

<p>iOS 7 增加了继承自 CLRegion 的 <code>CLBeaconRegion</code>。只要有 iBeacon 被 iOS 检测到，即使信号可能很弱，你就被定义为位于区域之内。这让测试过程令人发疯，因为即使我把我所有的 Estmote beacons 用铝箔包裹起来， iOS 仍然认为我位于该区域内。</p>

<p>一个 iBeacon 通过 3 个值被识别: proximityUUID, Major 和 Minor。第一个是 UUID，后两者是两个 16 位二进制整数。你可以构建 3 个级别的 CLBeaconRegion: 只有 UUID，UUID + Major，UUID + Major + Minor。例如你可能想用一个 UUID 对应整个公司，Major 对应各个店铺。Minor 则可以用来指定每个店铺中的各个货架。</p>

<!--more-->


<h2>做广告吧</h2>

<p>普通的 BTLE (Bluetooth Low Energy) 外设宣传多重服务，iBeacon 不同。iBeacon 自己使用广告信息并且不需要真正的蓝牙链接，因为所有所需信息已存在于 iBeacon 广告中。</p>

<p>以一个简略的例子开始</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">ViewController</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">CBPeripheralManager</span> <span class="o">*</span><span class="n">_peripheralManager</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">BOOL</span> <span class="n">_isAdvertising</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">_startAdvertising</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">NSUUID</span> <span class="o">*</span><span class="n">estimoteUUID</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSUUID</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithUUIDString:</span><span class="s">@&quot;B9407F30-F5F8-466E-AFF9-25556B57FE6D&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">CLBeaconRegion</span> <span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLBeaconRegion</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithProximityUUID:</span><span class="n">estimoteUUID</span>
</span><span class='line'>                                                                    <span class="nl">major:</span><span class="mi">2</span>
</span><span class='line'>                                                                    <span class="nl">minor:</span><span class="mi">1</span>
</span><span class='line'>                                                               <span class="nl">identifier:</span><span class="s">@&quot;SimEstimote&quot;</span><span class="p">];</span>
</span><span class='line'>   <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">beaconPeripheralData</span> <span class="o">=</span> <span class="p">[</span><span class="n">region</span> <span class="nl">peripheralDataWithMeasuredPower:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">[</span><span class="n">_peripheralManager</span> <span class="nl">startAdvertising:</span><span class="n">beaconPeripheralData</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">_updateEmitterForDesiredState</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">_peripheralManager</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">CBPeripheralManagerStatePoweredOn</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="c1">// only issue commands when powered on</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">if</span> <span class="p">(</span><span class="n">_isAdvertising</span><span class="p">)</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>         <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_peripheralManager</span><span class="p">.</span><span class="n">isAdvertising</span><span class="p">)</span>
</span><span class='line'>         <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">self</span> <span class="n">_startAdvertising</span><span class="p">];</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>      <span class="k">else</span>
</span><span class='line'>      <span class="p">{</span>
</span><span class='line'>         <span class="k">if</span> <span class="p">(</span><span class="n">_peripheralManager</span><span class="p">.</span><span class="n">isAdvertising</span><span class="p">)</span>
</span><span class='line'>         <span class="p">{</span>
</span><span class='line'>            <span class="p">[</span><span class="n">_peripheralManager</span> <span class="n">stopAdvertising</span><span class="p">];</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - CBPeripheralManagerDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">peripheralManagerDidUpdateState:</span><span class="p">(</span><span class="n">CBPeripheralManager</span> <span class="o">*</span><span class="p">)</span><span class="n">peripheral</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span> <span class="n">_updateEmitterForDesiredState</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - Actions</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">IBAction</span><span class="p">)</span><span class="nl">advertisingSwitch:</span><span class="p">(</span><span class="n">UISwitch</span> <span class="o">*</span><span class="p">)</span><span class="n">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">_isAdvertising</span> <span class="o">=</span> <span class="n">sender</span><span class="p">.</span><span class="n">isOn</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span> <span class="n">_updateEmitterForDesiredState</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子有一个 UISwitch 来切换 soft-beacon。这里有一些陷阱。首先它用了若干毫秒来开启蓝牙系统。只有在蓝牙启动时才能使用 <code>CBPeripheralManager</code>。它一这么做你就会收到 peripheralManagerDidUpdateState: 代理回调，如果蓝牙电源此时处于开启状态，你就可以开始广播 beacon。</p>

<p>停止 iBeacon 要简单的多，只需要一个命令。如果 <code>CBPeripheralManager</code> 电源被关闭，则所有的广告也会停止。当应用进入后台而你又没有告诉 iOS 保持蓝牙服务继续运行时就会导致这种情况发生。没记错的话，所有的服务在应用回到前台时会恢复。</p>

<h2>Estimote</h2>

<p>用何种类型的设备来执行 iBeacon 的功能并无结论，你可以让任何 iOS 设备 (>= iPhone 4S) 和 Mac (>= late 2011) 的蓝牙芯片作为 iBeacon。也有一些硬件公司提供专用的硬件。</p>

<p>Beacon 硬件的初衷是你让你并不需要在墙上粘一个真的 iOS 设备。不是每个人都能在店铺的每一个角落都放上 iPad。标准 iBeacon 硬件的价格是 99 美金 3个。我用这个价格买了 3 个 Estimote beacon。</p>

<p><img src="http://objcio.com/images/posts/2014-05-01-can-you-smell-the-ibeacon-01.jpg" alt="Estimote Developer Preview Kit" /></p>

<p>Estimote 提供了非常友好的拆箱体验。除了 3 个不同颜色的 iBeacon，还有 1 个按钮，1 张贴纸，1 张 Estimote CEO 和联合创始人 Jakub Krzych 的名片，还有一些警告信息来告知你这些 beacon 目前是手工组装的因此可能存在固件 bug。</p>

<p>收到 beacon 后你要做的第一件事是下载 Estimote 的演示应用，它可以让你像上文描述的那样尝试 Monitoring 和 Ranging。它还允许你链接各个 Estimote 设备来观察它们的电量，固件版本，以及 UUID， Major 和 Minor 的设置值。</p>

<p>此时我很惊讶的得知 Estimote 使用了&#8221;烧入&#8221;的 UUID。官方声明说这是有意的设计，用来阻止来自越狱设备的黑客和位置欺骗。</p>

<p>UUID 在应用内很明显，也被公布于几个博客中:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">B9407F30</span><span class="o">-</span><span class="n">F5F8</span><span class="o">-</span><span class="mi">466</span><span class="n">E</span><span class="o">-</span><span class="n">AFF9</span><span class="o">-</span><span class="mi">25556</span><span class="n">B57FE6D</span>
</span></code></pre></td></tr></table></div></figure>


<p>这也是我上面的例子中使用的 UUID，其实是创建了一个模拟的 Estimote beacon。</p>

<p>Estimote beacon 被完全包裹于橡胶之中因此并没有像 USB 之类的物理硬件接口。所有的设置通过蓝牙和 Estimote 暴露的内部服务来完成。推测未来版本的 <a href="https://github.com/Estimote/iOS-SDK">official Estimote SDK</a> 会针对担心自己 beacon 安全的人推出 UUID 加密方法。</p>

<p>他们还建议你使用他们包装的 Core Location 和 Core Bluetooth 来代替原生的 iOS 方法。对于系统也提供的功能，我个人比较反感使用第三方 SDK。对于你和你的邻居使用相同的 UUID 所造成的潜在问题的最佳解决方案是使用随机的 Major 值结合 UUID 来监测。一旦范围被发现，你要做额外的检查 &mdash; 可能针对于地理位置 &mdash; 是否你确实在你自己的店铺里。</p>

<h2>监测 iBeacon 区域</h2>

<p>如果你已经有了一个 Estimote 或按照上面创建了一个 soft-beacon，下一步就是监测这个区域。下面是一个可行的示例，目的是当你穿过区域边界时，更新文本标签并发出一个本地通知</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@implementation</span> <span class="nc">AppDelegate</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">CLLocationManager</span> <span class="o">*</span><span class="n">_locationManager</span><span class="p">;</span>
</span><span class='line'>   <span class="kt">BOOL</span> <span class="n">_isInsideRegion</span><span class="p">;</span> <span class="c1">// flag to prevent duplicate sending of notification</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">application:</span><span class="p">(</span><span class="n">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="n">application</span> <span class="nl">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">options</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">// create a location manager</span>
</span><span class='line'>   <span class="n">_locationManager</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLLocationManager</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="c1">// set delegate, not the angle brackets</span>
</span><span class='line'>   <span class="n">_locationManager</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">NSUUID</span> <span class="o">*</span><span class="n">estimoteUUID</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSUUID</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithUUIDString:</span><span class="s">@&quot;B9407F30-F5F8-466E-AFF9-25556B57FE6D&quot;</span><span class="p">];</span>
</span><span class='line'>   <span class="n">CLBeaconRegion</span> <span class="o">*</span><span class="n">region</span> <span class="o">=</span> <span class="p">[[</span><span class="n">CLBeaconRegion</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithProximityUUID:</span><span class="n">estimoteUUID</span>
</span><span class='line'>                                                               <span class="nl">identifier:</span><span class="s">@&quot;Estimote Range&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="c1">// launch app when display is turned on and inside region</span>
</span><span class='line'>   <span class="n">region</span><span class="p">.</span><span class="n">notifyEntryStateOnDisplay</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="p">([</span><span class="n">CLLocationManager</span> <span class="nl">isMonitoringAvailableForClass:</span><span class="p">[</span><span class="n">CLBeaconRegion</span> <span class="n">class</span><span class="p">]])</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">_locationManager</span> <span class="nl">startMonitoringForRegion:</span><span class="n">region</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1">// get status update right away for UI</span>
</span><span class='line'>      <span class="p">[</span><span class="n">_locationManager</span> <span class="nl">requestStateForRegion:</span><span class="n">region</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;This device does not support monitoring beacon regions&quot;</span><span class="p">);</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Override point for customization after application launch.</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">_sendEnterLocalNotification</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">_isInsideRegion</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">UILocalNotification</span> <span class="o">*</span><span class="n">notice</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILocalNotification</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">notice</span><span class="p">.</span><span class="n">alertBody</span> <span class="o">=</span> <span class="s">@&quot;Inside Estimote beacon region!&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="n">notice</span><span class="p">.</span><span class="n">alertAction</span> <span class="o">=</span> <span class="s">@&quot;Open&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">scheduleLocalNotification:</span><span class="n">notice</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">_isInsideRegion</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">_sendExitLocalNotification</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">_isInsideRegion</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">UILocalNotification</span> <span class="o">*</span><span class="n">notice</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UILocalNotification</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">notice</span><span class="p">.</span><span class="n">alertBody</span> <span class="o">=</span> <span class="s">@&quot;Left Estimote beacon region!&quot;</span><span class="p">;</span>
</span><span class='line'>      <span class="n">notice</span><span class="p">.</span><span class="n">alertAction</span> <span class="o">=</span> <span class="s">@&quot;Open&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>      <span class="p">[[</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">]</span> <span class="nl">scheduleLocalNotification:</span><span class="n">notice</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="n">_isInsideRegion</span> <span class="o">=</span> <span class="n">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">_updateUIForState:</span><span class="p">(</span><span class="n">CLRegionState</span><span class="p">)</span><span class="n">state</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="n">ViewController</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="p">(</span><span class="n">ViewController</span> <span class="o">*</span><span class="p">)</span><span class="n">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">CLRegionStateInside</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Inside&quot;</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">CLRegionStateOutside</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Outside&quot;</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="n">vc</span><span class="p">.</span><span class="n">label</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">@&quot;Unknown&quot;</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#pragma mark - CLLocationManagerDelegate</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">locationManager:</span><span class="p">(</span><span class="n">CLLocationManager</span> <span class="o">*</span><span class="p">)</span><span class="n">manager</span>
</span><span class='line'>    <span class="nl">didDetermineState:</span><span class="p">(</span><span class="n">CLRegionState</span><span class="p">)</span><span class="n">state</span> <span class="nl">forRegion:</span><span class="p">(</span><span class="n">CLRegion</span> <span class="o">*</span><span class="p">)</span><span class="n">region</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">// always update UI</span>
</span><span class='line'>   <span class="p">[</span><span class="n">self</span> <span class="nl">_updateUIForState:</span><span class="n">state</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="p">([</span><span class="n">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">applicationState</span> <span class="o">==</span> <span class="n">UIApplicationStateActive</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="c1">// don&#39;t send any notifications</span>
</span><span class='line'>      <span class="k">return</span><span class="p">;</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">CLRegionStateInside</span><span class="p">)</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">_sendEnterLocalNotification</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">else</span>
</span><span class='line'>   <span class="p">{</span>
</span><span class='line'>      <span class="p">[</span><span class="n">self</span> <span class="n">_sendExitLocalNotification</span><span class="p">];</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>本质上，你只是创建了一个 <code>CLBeaconRegion</code> 并让 <code>CLLocationManager</code> 对象去监听它。对于某些设备 beacon 监听会不可用，比如缺少 BT4 芯片，所以你需要通过 <code>isMonitoringAvailableForClass:</code> 来查询。</p>

<p>注意 didDetermineState: 在穿越区域边界时和 requestStateForRegion: 方法后都会被调用。所以你可以在这里做关于监听的工作并实现 didEnterRegion` 和 didExitRegion: 来保证不会过分干扰用户。</p>

<p>剩下的代码用来在应用在后台运行时发送本地通知，并避免对同一状态连续发送多个相同消息。</p>

<p>在我测试时，当我在 iPad 上打开第一个例子中的 soft beacon，我总是会立刻收到 didEnterRegion: 消息。关闭 beacon 后会延迟 43 秒收到 didExit 消息。所以 iOS 在内部做了一些过滤来避免实时触发。</p>

<h2>后台</h2>

<p>你会发现上面的代码在应用在前台运行时运行的非常好，但是当应用进入后台后不会继续发送/监听。</p>

<p>为了在后台监听区域，你需要将 info.plist 中的 &ldquo;Location updates&rdquo; 后台模式开启。&#8221;Acts as Bluetooth LE accessory&#8221; 则用来使 soft beacon 持久。Xcode 为此提供了很友好的 UI。</p>

<p><img src="http://objcio.com/images/posts/2014-05-01-can-you-smell-the-ibeacon-02.png" alt="Enabling iBeacon background modes" /></p>

<p>这里做出的改变最终会体现在 info.plist 文件中的 <code>UIBackgroundModes</code> 下。</p>

<p>增加配件设置要求用户授权蓝牙文件共享。注意用户可能拒绝或者在隐私设置中关闭授权。</p>

<p>集成了兼容 BT4 芯片的 Mac 可以发射 soft-beacon。CoreBluetooth 从 OS X 10.9 开始也可以在 Mac 上使用。2011 年以后生产的 Mac 通常含有该芯片。唯一缺少的是 CLBeaconRegion，不过如果你自己构建用来广播 iBeacon 的字典就可以解决这个问题。至此，你所需要了解的最后一件事是 CoreBluetooth.framework 隐藏在 IOBluetooth.framework 中。</p>

<p><a href="http://twitter.com/mttrb">Matthew Robinson</a> 创建了 <a href="https://github.com/mttrb/BeaconOSX">BeaconOSX sample</a> 来做这件事。</p>

<h2>竞争</h2>

<p>至写作此文时苹果并未发布官方的 iBeancon 规范。当我询问苹果相关负责人，他告诉我当他们发布时会告知我。所以只能寄希望于它们最终会这么做。与此同时，一些聪明人仍旧跑在前面并且<a href="http://developer.radiusnetworks.com/2013/10/01/reverse-engineering-the-ibeacon-profile.html">对 iBeacon 进行逆向工程</a>。</p>

<p>几个 iBeacon 硬件已经面世，Estimote 很快就会感受到来自他们的竞争。我粗略的搜索后发现的其他公司有:</p>

<ul>
<li><strong>RedBearLab</strong> 出售 Arduino 插件板(也叫做 &ldquo;shield&rdquo;)，售价 $29，有一个 <a href="http://redbearlab.com/ibeacon/">iBeacon profile</a></li>
<li><strong>Kontakt.io</strong> 出售运行于可人工替换的普通电池上的 beacon，售价 $99 3个，$149 5个， $279 10个。</li>
<li><strong>GeoHopper</strong> 以 USB 供电的作为 iBeacon 的微型插头: 售价 $39.99 1个，$89.99 3个，192.99 5个。</li>
<li>你还可以[用 Raspberry Pi 和 Bluetooth LE 适配器自己做一个]，设备价值 $40 左右，适配器 $10 左右。</li>
</ul>


<p>以上公司中，Estimote 似乎服务最好。</p>

<p>USB 供电和可更换电池并不是十分必要，低功耗的 BTLE 据说可以维持 2 年。防水橡胶外套和内置的贴纸可以让你很容易的将它粘贴到任何地方而不必害怕它被偷走和损害。</p>

<p>但是竞争从未停止，更多的公司一如既往的进入这个热门领域，下一年的价格一定会降低一半甚至更多。希望 Estimote 在价格上保持竞争力，并且当可以在生产线量产 beacon 的时候进一步降低价格。</p>

<p>只有两个不那么积极的消息。我个人认为自定义 SDK 不应该被当做 USP 使用来锁定用户，并且他们也不打算支持自定义的 UUID，当然也许是出于安全方面的考虑。也许它们最终也会明白过来。目前这些东西可以很容易的工作，&#8221;包裹&#8221;中其余的东西也非常有价值。</p>

<h2>结论</h2>

<p>没什么能阻止我们将 iBeacon 技术发扬光大，使应用和服务留意用户需求。要是真有什么的话，可能是担心苹果可能会更新仍然保密的 iBeacon 广告包来包含其它值。不过我提到的所有的硬件设备也可以升级来调整广告值。</p>

<p>唯一的问题是想象力的缺乏以及缓慢的卖家和合作方市场的低采用率。iBeacon 承诺会让进入传统的实体商店再次变得有趣。如此一来，任何这种公司会被很好的宣传以快速采用 iBeacon，以此方法将顾客重新勾住和拉回实体店。</p>

<p>小型商店可以在他们用于 POS 系统的 Mac 或 iPad 上运行一个 iBeacon，避免额外话费。这允许基于 Passbook 的优惠券或当靠近收银台时会员卡自动弹出。</p>

<p>你知道有哪些现实生活中 iBeacon 的创新使用? 或者在阅读本文时有新想法？请在评论里让我们知道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[精通iCloud文档存储]]></title>
    <link href="http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store/"/>
    <updated>2014-04-25T22:25:00+08:00</updated>
    <id>http://objcio.com/blog/2014/04/25/mastering-the-icloud-document-store</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-10/icloud-document-store.html">Mastering the iCloud Document Store</a>，转载请注明出处。</p>

<p>即便在推出 3 年后，iCloud 文档存储依然是一个充满神秘、误解和抱怨的话题。iCloud 同步经常被批评不可靠且速度慢。虽然在 iCloud 的早期有一些严重的 bug，开发者们还是不得不学习有关文件同步的课程。文件同步事关重大，为应用开发带来了新方向 &mdash; 一个经常被低估的方向，比如进行同步服务相关的合作时，对于处理文件异步更改的需要。</p>

<p>本文会介绍几个创建支持 iCloud 的应用时可能会遇到的一些绊脚石。因为本文只会给出一些粗略的概述，所以如果你对 iCloud 文档存储还不熟悉，我们强烈建议你先阅读 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<!--more-->


<h2>文档存储简介</h2>

<p>iCloud 文档存储的核心思想非常简单: 每个应用都有至少通往一个&#8221;魔法文件夹&#8221;的入口，该文件夹可以存储文件并且随后在所有注册了同一个 iCloud 帐号的设备间同步。</p>

<p>与其他基于文件系统的同步服务相比，iCloud 文档存储得益于与 OS X 和 iOS 的深度整合。很多系统框架已经被扩展以支持 iCloud。像 <code>NSDocument</code> 和 <code>UIDocument</code> 这样的类被按照可以处理外部变化来进行设计。版本存储和 <code>NSFileVersion</code> 处理同步冲突。Spotlight 被用来提供同步元数据，比如文件传输进度或者云端文档可用性。</p>

<p>写一个简单的基于文档并开启了 iCloud 的 OS X 应用并不需要费多大力气。实际上你并不需要关心任何 iCloud 内部的工作，<code>NSDocument</code> 无偿的做了几乎每件事情: 协调文档的 iCloud 访问，自动观察外部变化，触发下载，处理冲突。它甚至提供了一个简单的 UI 界面来管理云文档。你需要做的所有事情就是创建一个 <code>NSDocument</code> 子类并实现读取和写入文档内容所需要的方法。</p>

<p><img src="http://objcio.com/images/posts/2014-04-25-mastering-the-icloud-document-store-01.png" alt="NSDocument provides a simple user interface for managing the synchronized documents of an app." /></p>

<p>然而，一旦脱离预设的路径，你就需要了解的更多。例如，默认打开面板提供的单层文件夹以外的任何操作都需要手动完成。可能你的应用需要管理除了文档内容以外的文档，比如像 Mail，iPhoto 或者 <a href="http://www.ulyssesapp.com/">Ulysses</a> (我们自己的app) 中做的那样。这种时候，你不能依赖于 <code>NSDocument</code>，而需要自己实现它的功能。但为此你需要对 iCloud 提供的锁和通知机制有一个深入的了解。</p>

<p>开发支持 iCloud 的 iOS 应用同样需要更多的工作和知识: 虽然 <code>UIDocument</code> 仍然管理 iCloud 文件访问和处理同步冲突，但缺乏管理文档和文件夹的图形界面。因为性能和存储空间的原因，iOS 也不会自动从云端下载新文档。你需要使用 Spotlight 来检索最近变化的目录并手动触发下载。</p>

<h2>什么是开放性容器 (Ubiquity Container)</h2>

<p>任何符合 App Store 条件的应用都可以使用 iCloud 文档存储。设置正确的<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/iCloudFundametals.html#//apple_ref/doc/uid/TP40012094-CH6-SW13">授权</a>后，就获得了一个或多个所谓的&#8221;开放性容器&#8221;的访问权限。这是苹果用来称呼&#8221;一个被 iCloud 管理和同步的目录&#8221;的别称。每一个开放性容器限定在一个 app id 内，由此让每个用户在每个应用中有一份共享的存储仓库。有多个应用的开发者可以指定同一个团队的多个 app id，由此可以访问多个容器。</p>

<p><code>NSFileManager</code> 通过 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/URLForUbiquityContainerIdentifier:">URLForUbiquityContainerIdentifier:</a> 提供每一个容器的 URL。在 OS X 系统，可以通过打开 <code>~/Library/Mobile Documents</code> 目录来查看所有可用的开放性容器。</p>

<p><img src="http://objcio.com/images/posts/2014-04-25-mastering-the-icloud-document-store-02.png" alt="The contents of ”~/Library/Mobile Documents.“ It contains a separate folder for each ubiquity container of each application." /></p>

<p>通常每个开放性容器有两个并发进程访问。首先，有一个应用呈现和操作容器内的文档。第二，有一个主要通过开放性守护 (Ubiquity Daemon <em>ubd</em>) 体现的 iCloud 架构。iCloud 架构等待应用对文档的更改并将其上传至苹果云服务器。同时也等待从 iCloud 上收到的更改并相应修改容器的内容。</p>

<p>由于两个进程完全独立于彼此工作，因此需某种形式的仲裁来避免资源竞争或丢失容器内的文件更新的问题。应用需要使用名为 <a href="https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileCoordinators/FileCoordinators.html#//apple_ref/doc/uid/TP40010672-CH11-SW1"><em>文件协调 file coordination</em></a> 的概念来确保对于每一个独立文件的访问权。该访问权由 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFileCoordinator_class/Reference/Reference.html"><code>NSFileCoordinator</code></a> 类提供。概括来说，它为每个文件提供了一个简单的 读-写 锁。这个锁由一个通知机制扩展，该机制用于用于改善访问同一个文件的不同进程间的合作。</p>

<p>这个通知机制相比于简单的文件锁来说是有巨大的好处，并且提供了无缝的用户体验。iCloud 可能会在任何时间把文档用一个来自其他设备的新版本覆盖。如果一个应用当前正在显示同一个文档，它必须从磁盘加载新版本并向用户展示更新过的内容。更新过程中，应用可能需要锁住用户界面一段时间并随后在此打开。甚至可能发生更坏的情况: 应用可能保留着未保存的内容，这些内容需要<em>首先</em>保存到磁盘上以便检查同步冲突。最后，在网络条件良好的时候 iCloud 会上传文件最近的版本。因此必须能够要求应用立刻保存所有未保存的变更。</p>

<p>为了实现这个过程，文件协调伴随着另一套名为 <em>文件展示 (file presentation)</em> 的机制。无论什么时候应用打开并向用户展示一个文件，这被称为 <em>展示文档</em>，并且应该注册一个实现了 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html"><code>NSFilePresenter</code></a> 协议的对象。只要另一个进程通过一个文件协调访问文件，文件展示者 (file presenter) 就会收到关于该文件的通知。这些通知被作为方法调用传递，这些方法在展示者指定的一个操作队列(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfp/NSFilePresenter/presentedItemOperationQueue"><code>presentedItemOperationQueue</code></a>)中异步执行。</p>

<p>例如，在任何其他线程被允许开始一个读取操作前，文件展示者被要求保存任何未保存的变化。这些操作通过分发一个 block 到它的展示队列来执行 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a> 方法来完成。展示者需要保存文件并通过执行作为参数传入的 block 来确认通知。除了改变通知，文件展示者还用来通知应用同步冲突。一旦一个文件的冲突版本被下载，一个新的文件版本被加入到版本存储里。所有的展示者通过 <a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/presentedItemDidGainVersion:"><code>presentedItemDidGainVersion:</code></a> 被通知有一个新版本被创建。该回调接收一个引用了潜在冲突的 <code>NSFileVersion</code> 实例。</p>

<p>文件展示者还可以被用来监视文件夹内容。例如，一旦 iCloud 改变文件夹内容，如创建，删除或者移动文件，应用应该被通知到以便更新它的文档展示。为此，应用可以对展示的目录注册一个实现了 <code>NSFilePresenter</code> 协议的实例。一个目录的文件展示者会收到任何文件夹或其中文件或子文件夹的改变的通知。比如一个文件夹内的文件被修改，展示者会收到一个引用了该文件的 URL 的 <code>presentedSubitemDidChangeAtURL:</code> 通知。</p>

<p>因为带宽和电池寿命在移动设备上更加有限，iOS 不会自动从 iCloud 下载新文件。而是由应用手动决定何时来触发下载新文件到开放性容器中。为了持续告知应用哪些文件可用及其同步状态，iCloud 还会同步开放性容器内的文件元信息。应用可以通过 <code>NSMetadataQuery</code> 或访问 <code>NSURL</code> 的开放资源属性查询这些元信息。无论何时应用想要访问一个文件，它一定会通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 来触发下载行为。</p>

<h2>深入 iCloud</h2>

<p>在继续解释如何实现文件协调和观察之前，现在我们将深入一些过去几年里碰到的一些常见问题。再一次的，确保你已经阅读并理解了 <a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html">Apple iCloud companion guide</a>。</p>

<p>虽然这些文件机制的描述让它们的使用看起来简单明了，但其实其中有很多隐藏的陷阱。这些陷阱中有些来自于底层框架的 bug。因为 iCloud 同步延伸到操作系统中相当多的层面，人们只能寄希望于苹果能够小心的修复这些 bug。实际上，苹果看起来宁愿废弃坏掉的 API 而不是修复它们。</p>

<p>即便如此，我们的经验告诉我们使用 iCloud 是非常非常容易犯错误的。异步，协作，基于锁特性的文件协调和文件展示互相牵连，并不容易掌握。下面，我们将介绍整合 iCloud 文档同步时的一些主要规则，并以这种形式分享我们的经验。</p>

<h3>只在需要时使用 Presenters</h3>

<p>文件展示者代价高昂。仅当你的应用需要立即应对或干预文件访问的时候，才应该使用它。</p>

<p>如果你的应用正在展示类似文档编辑器这样的东西给用户，文件展示足以胜任。这时，在其他进程写入该文件的时候也许需要锁住编辑器，或者还需要保存未保存的改变。然而，如果只是临时访问并且通知也可能会被延迟处理，就不应该使用文件展示。例如，当创建文件索引或缩略图，查看文件更改日期并使用简单的文件协调可能会更高效。另外，如果你正展示一个字典树的内容，在树的根节点注册 <em>一个</em> 展示者或用 <code>NSMetadataQuery</code> 来延迟获取改变通知会可能会非常高效。</p>

<p>是什么让文件展示代价如此高昂？它需要很多的进程间通信: 每个文件上注册的展示者在其他进程获取文件的访问权时都被要求释放该文件。比如另一个进程尝试读取一个文件，该文件的展示者会被要求保存所有未保存的内容 (<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/savePresentedItemChangesWithCompletionHandler:"><code>savePresentedItemChangesWithCompletionHandler:</code></a>)。它们还会被要求释放文件给读取者(<a href="https://developer.apple.com/library/mac/documentation/Foundation/Reference/NSFilePresenter_protocol/Reference/Reference.html#//apple_ref/occ/intfm/NSFilePresenter/relinquishPresentedItemToReader:"><code>relinquishPresentedItemToReader:</code></a>)，例如文件被读取时暂时锁住编辑器。</p>

<p>这些通知每一个都需要分发，加工并由各自的接收者确认。并且因为只有实现的进程知道哪些通知会被处理，所以即使展示者没有实现任何方法，进程间也会为每一个可能的通知进行通信。</p>

<p>另外，每个步骤都需要在读取进程，展示进程和文件协调守护进程 (<code>filecoordinationd</code>) 间的多重上下文的切换。结果就导致了一个简单的文件访问很快就变成耗费资源的操作。</p>

<p>除此之外，如果太多的展示者被注册，文件协调守护进程可能会删除重要的系统资源。对于每一个展示者，都需要打开并监听每一个它所描述的路径上的文件夹。尤其在 OS X Lion 和 iOS 5 上，这些资源是非常稀少的，过度的使用很容易导致文件协调守护进程的锁死或崩溃。</p>

<p>基于这些原因，我们强烈建议不要在目录树的每一个节点上增加文件展示者，只根据需要使用最少的文件展示者。</p>

<h3>只在需要时使用协调</h3>

<p>虽然文件协调要比文件展示节约资源，但它仍然给你的应用和整个系统增加额外的负担。</p>

<p>每当你的应用正在协调一个文件，其他同时想要访问同一个文件的进程可能需要等待。因此你不该在协调文件时执行过于耗时的任务。如果你这么做了，比如存储了大文件，你可以考虑将它存储到一个临时文件夹，随后在协调访问时使用硬连接。注意每一个协调的访问都可能会触发另一个进程上的文件展示者 &mdash; 该展示者可能需要时间在你的访问之前更新文件。始终考虑使用诸如 <code>NSFileCoordinatorReadingWithoutChanges</code> 这样的标识，除非需要读取文件的最新版本。</p>

<p>虽然你的应用的开放性容器可能不会被其他应用访问，过分的文件协调仍然可能成为 iCloud 的一个问题，执行太多的协调请求会造成类似 <code>ubd</code> 的进程的<a href="http://en.wikipedia.org/wiki/Resource_starvation">资源饥饿</a>问题。在应用启动阶段，<code>ubd</code> 似乎会扫描开放性容器内的所有文件。如果你的应用在程序启动阶段也在执行相同的扫描。两个进程会经常冲突，从而可能导致协调的高开销。这时考虑更优化的解决方案是明智的。例如扫描目录内容时，单独的文件内容访问权限是根本不需要的。把协调工作延迟到文件内容真正被展示的时候再进行会是不错的选择。</p>

<p>最后，绝对不要协调一个还没有被下载的文件。文件协调会触发对该文件的下载。不幸的是，协调将会一直等待直到下载完成，这有可能会导致应用被锁住很长一段时间。访问一个文件之前，应用应该先检查文件下载状态。你可以通过查询 URL 的 <code>NSURLUbiquitousItemDownloadingStatusKey</code> 的值或使用 <code>NSMetadataQuery</code> 做到这一点。</p>

<h3>协调方法的几个备注</h3>

<p>阅读 <code>NSFileCoordinator</code> 的文档，你可能注意到每个方法都有一个冗长而复杂的描述。虽然 API 文档通常是非常可靠的，但由于同其他协调器和文件展示者交互的多样性，以及文件夹和文件锁的语法多样性，都造成了很高的复杂度。有一些很容易忽略的细节和问题贯穿这些长长的描述:</p>

<ol>
<li>认真选择协调选项。它们真的对文件协调器和文件展示者有着影响。比如，如果没有采用 <code>NSFileCoordinatorWritingForDeleting</code> 标识，文件展示者将无法通过 <code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 对文件删除操作做出影响。如果移动目录时不使用 <code>NSFileCoordinatorWritingForMoving</code>，则移动操作将不会等待其子项目上正在执行的协调操作进行完成。</li>
<li>始终认为协调调用可能会失败并返回错误。因为文件协调同 iCloud 交互，如果被协调的文件不能被下载，协调调用会失败并产生一条错误信息，并且你实际的文件操作可能不会被执行。如果没有正确的实现错误处理方法，你的应用可能不会注意到这样的问题。</li>
<li>在进入协调 block 之后检查文件状态。协调请求之后，也许很长时间已经过去了。这时，应用操作文件的前提条件可能已经失效。你想写入的信息直到重新获得锁之前有可能都是脏数据。也可能在你等待获得写入权限的时候文件已经被删除。这时你可能会无意中再次创建已经被删除的文件。</li>
</ol>


<h3>通知死锁</h3>

<p>实现 <code>NSFilePresenter</code> 的通知处理方法需要特别注意。类似 <code>relinquishPresentedItemToReader:</code> 这样的通知处理方法必须被确认及告知其他进程该文件已经对访问准备就绪。这一般通过执行作为参数传入通知处理方法的确认 block 来完成。确认 block 被调用之前，其他进程不得不等待，了解这一点是尤为重要的。如果确认因为通知处理的缓慢而被延迟，协调进程也许会被搁置。如果一直没有被执行，则可能会永远被挂起。</p>

<p>不幸的是，需要被确认的通知也会被其他完全独立的通知拖慢。为了确保通知以正确的顺序执行，<code>presentedItemOperationQueue</code> 一般被设置为一个顺序执行队列。但是一个顺序队列就意味着处理速度慢的通知会延缓随后的通知。尤其是它们会延缓需要确认的通知，在那之前，所有的进程都将等待。</p>

<p>例如，假设一个 <code>presentedItemDidChange</code> 通知首先进入队列。该回调漫长的处理过程将会延缓其他随后进入队列的通知，比如 <code>relinquishPresentedItemToReader:</code>。因此，该通知的确认也会被延迟，从而也导致等待它的进程被延缓。</p>

<p>综上所述，在展示队列里的时候 <em>永远不要</em> 执行文件协调。实际上，即使简单的不需要任何确认的通知 (比如 <code>presentedItemDidChange</code>) 也会导致死锁。设想两个文件展示者同时在展示同一个文件。两个展示者都通过执行协调的读取操作来处理 <code>presentedItemDidChange</code> 通知。如果文件发生改变，通知被发送到两个展示者并且二者都在同一个文件上执行协调的读取操作。因此，两个展示者都通过入队一个  <code>relinquishPresentedItemToReader:</code> 请求对方释放文件并等待对方确认。不幸的是，两个展示者无法确认通知，因为它们都因为永久的等待对方确认的协调请求而阻塞了它们的展示队列。我们在 <a href="https://github.com/hydrixos/DeadlockExample">GitHub</a> 上提供了一个小例子展示这种死锁。</p>

<h3>通知缺陷</h3>

<p>从通知中得出正确结论并不容易。文件展示中存在的 bug 造成了有些通知处理器<em>从未被执行</em>。这里初步介绍一些已知的不太规律的通知:</p>

<ol>
<li>除了 <code>presentedSubitemDidChangeAtURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code>，所有的子项目通知要么不被调用，要么以一种难以预测的方式被调用。绝对不要依赖它们 &mdash; 实际上，<code>presentedSubitemDidAppearAtURL:</code> 和 <code>accommodatePresentedSubitemDeletionAtURL:completionHandler:</code> 从不会被调用。</li>
<li>只有通过使用了 <code>NSFileCoordinatorWritingForDeleting</code> 的文件协调来删除文件，<code>accommodatePresentedItemDeletionWithCompletionHandler:</code> 才会工作。否则，你会连一个 change 的通知都收不到。</li>
<li>只有文件展示者执行 <code>itemAtURL:didMoveToURL:</code> 时，<code>presentedItemDidMoveToURL:</code> 和 <code>presentedSubitemAtURL:didMoveToURL:</code> 才会被调用。否则项目不会收到任何有用的通知。子项目仍旧会分别针对旧的和新的 URL 收到 <code>presentedSubitemDidChange</code> 通知。</li>
<li>即使文件被正确移动，<code>presentedSubitemAtURL:didMoveToURL:</code> 通知也被发送，你仍然会针对旧的和新的 URL 收到两个额外的 <code>presentedSubitemDidChangeAtURL:</code> 通知。要做好准备好处理这个。</li>
</ol>


<p>一般来说，你必须注意通知可能会失效。也不应该依赖于任何特定的通知顺序。例如，当描述一个目录树时，你不能期望父文件夹的通知会先于或晚于其中子项目的通知。</p>

<h3>注意 URL 变化</h3>

<p>在文件协调和文件展示者传递参照着相同文件的不同的 URL 时，有几种你需要应对的情况。你绝不应该使用 <code>isEqual:</code> 比较 URL，因为两个不同的 URL 可能关联同一个文件。应该始终在比较之前标准化它们。这一点在 iOS 上尤为重要，在 iOS 中开放性容器存储在 <code>/var/mobile/Library/Mobile Documents/</code> 中，这个文件夹是 <code>/private/var/mobile/Library/Mobile Documents/</code> 的符号链接。你会收到带有指向同一个文件，基于 <em>两种路径变体</em> 的 URL 的展示者通知。如果你对 iCloud 和本地文档使用文件协调代码，这个问题在 OS X 上也会发生。</p>

<p>除此之外，还有几个关于大小写不敏感的文件系统的问题。<em>如果</em>文件系统要求，应该始终确保你使用大小写不敏感的文件名比较。文件协调 block 和展示者通知可能传递使用不同大小写的相同的 URL 变体。实际上，这是使用文件协调器重命名时的重要问题。为了搞懂这个问题，你需要回顾文件实际上是如何被重命名的:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">coordinator</span> <span class="nl">coordinateWritingItemAtURL:</span><span class="n">sourceURL</span>
</span><span class='line'>                                <span class="nl">options:</span><span class="n">NSFileCoordinatorWritingForMoving</span>
</span><span class='line'>                       <span class="nl">writingItemAtURL:</span><span class="n">destURL</span>
</span><span class='line'>                                <span class="nl">options:</span><span class="mi">0</span>
</span><span class='line'>                                  <span class="nl">error:</span><span class="nb">NULL</span>
</span><span class='line'>                             <span class="nl">byAccessor:</span><span class="o">^</span><span class="p">(</span><span class="n">NSURL</span> <span class="o">*</span><span class="n">oldURL</span><span class="p">,</span> <span class="n">NSURL</span> <span class="o">*</span><span class="n">newURL</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">NSFileManager</span><span class="p">.</span><span class="n">defaultManager</span> <span class="nl">moveItemAtURL:</span><span class="n">oldURL</span> <span class="nl">toURL:</span><span class="n">newURL</span> <span class="nl">error:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">coordinator</span> <span class="nl">itemAtURL:</span><span class="n">oldURL</span> <span class="nl">didMoveToURL:</span><span class="n">newURL</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设 <code>sourceURL</code> 指向一个名为 <code>~/Desktop/my text</code> 的文件，<code>destURL</code> 使用了大写字母的新文件名 <code>~/Desktop/My Text</code>。协调 block 被有意设计成传入两个 URL 的最新版本，以兼容等待文件访问时发生的移动操作。现在，不幸的，当改变文件名的大小写，文件协调所执行的 URL 校验将会发现新旧两个 URL 都存在一个有效文件，而新的 URL 是小写 <code>~/Desktop/my text</code> 的变体。访问 block 将会接收到同样的 <em>小写</em> URL 作为 <code>oldURL</code> 和 <code>newURL</code>，导致移动操作失败。</p>

<h3>请求下载</h3>

<p>在 iOS 中，触发从 iCloud 的下载是应用的责任。可以通过 <code>NSFileManager</code> 的 <a href="https://developer.apple.com/library/mac/documentation/cocoa/reference/foundation/classes/nsfilemanager_class/reference/reference.html#//apple_ref/occ/instm/NSFileManager/startDownloadingUbiquitousItemAtURL:error:"><code>startDownloadingUbiquitousItemAtURL:error:</code></a> 方法触发下载。如果你的应用设计成自动下载文件 (也就是不由用户触发)，你应该始终在一个顺序后台队列中执行这些下载请求。换句话说，每一个单独的下载请求涉及到相当多的进程间通信并可能会很耗时。另一方面，同时触发太多的下载有时会过载 <em>ubd</em> 守护进程。一个普遍的错误就是使用 <code>NSMetadataQuery</code> 等待 iCloud 中的新文件然后自动触发下载它们。因为查询结果总是在主队列中传递并且可能包含一打的更新信息，直接触发下载会阻塞应用很长一段时间。</p>

<p>为了查询某个文件的下载或者上传状态，你可以使用 <code>NSURL</code> 的资源值。在 iOS 7 / OS X 10.9 之前，一个文件的下载状态通过 <code>NSURLUbiquitousItemIsDownloadedKey</code> 来确认。根据头文件文档，这个资源值从未正确生效过，所以在 iOS 7 和 Mavericks 中被废弃了。现在苹果建议使用 <code>NSURLUbiquitousItemDownloadingStatusKey</code>。在老系统上，你应该使用 <code>NSMetadataQuery</code> 查询 <code>NSMetadataUbiquitousItemIsDownloadedKey</code> 来获得正确的下载状态。</p>

<h2>综合考虑</h2>

<p>为你的应用增加 iCloud 支持并不只是你增加的另一个功能，而是一个对应用设计和实现有着深远影响的决定。它既影响着你的数据模型也影响着 UI。所以不要低估支持 iCloud 所需要做出的努力。</p>

<p>最重要的，增加 iCloud 会引入一个新的异步层。应用必须能够在任何时候处理文档和元数据的变化。这些变化上的通知可能会在不同线程上收到，这就需要在你的整个应用中添加同步机制来对这些通知进行适当的处理。你需要注意那些对于用户文档完整性有重大影响的关键代码中的问题，比如丢失更新，竞争和死锁等。</p>

<p>始终注意 iCloud 的同步保证是非常脆弱的。你只能假设文件和包是自动同步的。但你不能期望多个同时被修改的文件也会被立刻同步。比如，如果你的应用分开存储元信息和实际的文件的话，你一定要能够应对元信息会先于或晚于实际文件被下载的情况。</p>

<p>使用 iCloud 文档同步同时也意味着你正在做一个发布的应用。你的文档会在运行着不同版本的不同设备上。你可能想要使你文件格式的不同版本向前兼容。起码，你必须确保你的应用在面对其他不同设备上安装的新版本应用创建的文件时不会崩溃或发生错误。用户未必会立刻更新所有的设备，所以预先准备好这个问题。</p>

<p>最后，你的 UI 需要反映同步行为。即使这会抹杀掉一些神奇之处。尤其在 iOS 上，连接失败和缓慢的文件转换是现实状况。你的用户应该被通知关于文档的同步状态。你应该考虑展示文件是在被上传还是在下载，以告知用户他们的文档现在是否可用。使用大文件时，你可能需要显示文件传输进度，你的 UI 应该优雅一些; 如果 iCloud 不能及时给你某个文档，你的应用应该响应，并且让用户重试或至少放弃操作。</p>

<h2>调试</h2>

<p>因为涉及到多系统服务和外部服务，调试 iCloud 问题非常困难。Xcode 5 提供的 iCloud 调试功能非常有限并且大多数时候只会告诉你 iCloud 是否已经同步。幸运的是，还有一些差不多是官方的方法来调试 iCloud 文档存储。</p>

<h3>在 OS X 上调试</h3>

<p>有时你可能经历过 iCould 停止同步某个文件或干脆完全停止工作。实际上，这在文件协调器内使用断点或在一个文件操作进行期间杀掉一个进程时很容易发生。甚至如果你的应用在某个关键点崩溃后也会发生。通常来说，重启或者注销后重新登录 iCloud 都不能修复这个问题。</p>

<p>为了修复这些锁定，一个命令行工具会非常有好处: <code>ubcontrol</code>。这个工具是 10.7 以后版本 OS X 的一部分。使用命令 <code>ubcontrol -x</code>，你能够重置文档同步的本地状态。它通过重置一些私有数据库和缓存，重启所有涉及到的系统守护进程，来复原熄火的同步。同时它也会存储一些报告分析信息到 <code>~/Library/Application Support/Ubiquity-backups</code>。</p>

<p>虽然已经有日志文件被写入 <code>~/Library/Logs/Ubiquity</code> 中，你也还可以通过 <code>ubcontrol -k 7</code> 来增加日志级别。在进行 iCloud 相关的错误报告时，苹果工程师经常会要求你这么做以便收集信息。</p>

<p>为了调试文件协调，你还可以从文件协调守护进程中直接取回锁状态信息。这使你能够得知在应用中或多进程间可能遇到的文件协调死锁。为了访问这个信息，你需要在终端中执行以下命令:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">sudo</span> <span class="n">heap</span> <span class="n">filecoordinationd</span> <span class="o">-</span><span class="n">addresses</span> <span class="n">NSFileAccessArbiter</span>
</span><span class='line'><span class="n">sudo</span> <span class="n">lldb</span> <span class="o">-</span><span class="n">n</span> <span class="n">filecoordinationd</span>
</span><span class='line'><span class="n">po</span> <span class="p">[</span><span class="o">&lt;</span><span class="n">address</span><span class="o">&gt;</span> <span class="nl">valueForKey:</span> <span class="s">@&quot;rootNode&quot;</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个命令会返回一个文件协调守护进程的内部单例对象的地址。随后，你关联 <em>lldb</em> 到运行的守护进程上。通过使用第一步取回的地址，你将会得到一个所有活动的锁和文件展示者的状态的概览。调试命令会展示当前正在被展示或协调的整个文件树。例如，如果 TextEdit 正在展示一个名为 <code>example.txt</code> 的文件，你会得到以下跟踪信息:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">example</span><span class="p">.</span><span class="n">txt</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">NSFileAccessNode</span> <span class="mi">0</span><span class="n">x</span><span class="err">…</span><span class="o">&gt;</span> <span class="nl">parent:</span> <span class="mi">0</span><span class="n">x</span><span class="err">…</span><span class="p">,</span> <span class="nl">name:</span> <span class="s">&quot;example.txt&quot;</span>
</span><span class='line'>    <span class="nl">presenters:</span>
</span><span class='line'>        <span class="o">&lt;</span><span class="n">NSFilePresenterProxy</span> <span class="err">…</span><span class="o">&gt;</span> <span class="nl">client:</span> <span class="n">TextEdit</span> <span class="err">…</span><span class="o">&gt;</span>
</span><span class='line'>        <span class="nl">location:</span> <span class="mh">0x7f9f4060b940</span>
</span><span class='line'>    <span class="n">access</span> <span class="nl">claims:</span> <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">progress</span> <span class="nl">subscribers:</span> <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="n">progress</span> <span class="nl">publishers:</span> <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="nl">children:</span> <span class="o">&lt;</span><span class="n">none</span><span class="o">&gt;****</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果你在文件协调进行时创建这种跟踪 (比如通过在文件协调 block 中设置断点)，你还会得到一个等待文件协调器的所有进程的列表。</p>

<p>如果通过 <em>lldb</em> 观察文件协调，你应该始终记得尽快执行 <code>detach</code> 命令。否则，全局根进程文件协调守护进程将一直等待，这会影响到系统中几乎所有的应用。</p>

<h3>在 iOS 上调试</h3>

<p>在 iOS 上，调试要更加复杂，因为你无法检查运行的系统进程，你也无法使用像 <code>ubcontrol</code> 的命令行工具。</p>

<p>iCloud 锁定在 iOS 上似乎更经常发生。重启应用或设备都无效。唯一有效的修复这种问题的方法是 <em>冷启动</em>。在冷启动过程中，iOS 似乎进行了 iClouds 的内部数据库重置。可以通过同时按下电源键和 home 键 10 秒钟冷启动设备。</p>

<p>为了在 iOS 上激活更详细的日志，在苹果 <a href="https://developer.apple.com/downloads">developer downloads page</a> 有一个专用的 iCloud 日志概述。如果搜索 &ldquo;Bug Reporter Logging Profiles (iOS)&#8221;，你将会找到一个叫做 &#8220;iCloud Logging Profile&rdquo; 移动设备概述。在你的 iOS 设备上安装该文件来激活更详细的日志。你可以用 iTunes 同步设备来访问这些日志.随后，你可以在 <code>Library/Logs/CrashReporter/Mobile Device/&lt;Device Name&gt;/DiagnosticLogs/Ubiquity</code> 文件夹找到它。如果想要关掉这种加强的日志输出，从设备删除描述文件即可。苹果建议你在激活或关闭概述前重启设备。</p>

<h3>在 iCloud Servers 上调试</h3>

<p>除了在你自己的设备上调试，考虑使用苹果服务上的调试服务可能也会有用。<a href="https://developer.icloud.com/">developer.icloud.com</a> 上有一个特殊的 web 应用，它允许你浏览存储在开放性容器内的所有信息和当前传输状态。</p>

<p>过去的几个月，苹果还提供了安全地在服务端对所有已连接设备进行 iCloud 重置的方法。更多信息可查看 <a href="http://support.apple.com/kb/HT5824">support document</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[自定义控件]]></title>
    <link href="http://objcio.com/blog/2014/03/10/custom-controls/"/>
    <updated>2014-03-10T10:27:00+08:00</updated>
    <id>http://objcio.com/blog/2014/03/10/custom-controls</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://objcio.com"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-3/custom-controls.html">Custom Controls</a>，转载请注明出处。</p>

<p>本文将讨论一些自定义视图和控件的诀窍和技巧。我们先对UIKit已经提供给我们的控件做一个概览，介绍一些渲染技巧。随后我们会深入到视图和它们的所有者之间的通信策略，并简略探讨辅助功能，本地化和测试。</p>

<!--more-->


<h2>视图层次概览</h2>

<p>看一下UIView的子视图，可以看到3个基本类:响应者，视图和控件。我们快速重温一下它们。</p>

<h3>UIResponder</h3>

<p><code>UIResponder</code>是<code>UIView</code>的父类。响应这能够处理触摸，手势，远程控制等事件。之所以它是一个单独的类而没有合并到<code>UIView</code>中，是因为<code>UIResponder</code>有更多的子类，最明显的就是<code>UIApplication</code>和<code>UIViewController</code>。通过重写<code>UIResponder</code>的方法，可以决定一个类是否可以成为第一响应者(例如当前输入焦点元素)。</p>

<p>当触摸或手势等交互行为发生，它们被发送给第一响应者(通常是一个视图)。如果第一响应者没有处理，则该行为沿着响应者链到达视图控制器，如果行为仍然没有被处理，则它继续传递给应用。如果想检测晃动手势，可以根据需要在这3层中的任意位置处理。</p>

<p><code>UIResponder</code>还允许自定义输入方法，通过<code>inputAccessoryView</code>向键盘添加辅助视图或使用<code>inputView</code>提供一个完全自定义的键盘。</p>

<h3>UIView</h3>

<p><code>UIView</code>的子类处理所有跟内容绘制有关的事情和触摸。只要写过&#8221;Hello, World&#8221;应用的人都知道视图，但我们重申一些技巧点:</p>

<p>一个普遍的错误概念是视图的区域是由它的frame定义的。实际上frame是一个派生属性，主要由center和bounds合成而来。不使用Auto Layout时，大多数人使用frame来定位改变视图的大小。作为警告，<a href="https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIView_Class/UIView/UIView.html#//apple_ref/occ/instp/UIView/frame">官方文档</a>特别详细说明了一个注意事项:</p>

<blockquote><p>If the transform property is not the identity transform, the value of this property is undefined and therefore should be ignored.</p></blockquote>

<p>另一个允许向视图添加交互的方法是使用手势识别器。注意它们并不工作在响应者上，而只在视图及其子类上工作。</p>

<h3>UIControl</h3>

<p><code>UIControl</code>建立在视图上，增加了更多的交互支持。最重要的是，它增加了target/action模式。看一下具体的子类，可以看到按钮，日期选择器，文本输入框，等等。创建交互控件时，你通常想要子类化一个<code>UIControl</code>。一些常见但并不是控件的类是工具栏按钮(虽然也支持target/action)和文本视图(这里需要你使用代理来获得通知)。</p>

<h2>渲染</h2>

<p>现在，我们接下去来到可见的部分:自定义渲染。正如Daniel在他的<a href="http://www.objc.io/issue-3/moving-pixels-onto-the-screen.html">文章</a>中提到的，你可能想避免在CPU上做渲染而将其丢给GPU。这里有一条经验:尽量避免<code>drawRect:</code>，而使用现有的视图构建自定义视图。</p>

<p>通常最快速的渲染方法是使用图片视图。例如，假设你想画一个带有边框的圆形头像，像下面图片中这样:</p>

<p><img src="http://objcio.com/images/posts/2014-03-10-custom-controls.png" alt="" /></p>

<p>为了实现这个，我们用以下的代码创建了一个图片视图的子类:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// called from initializer</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupView</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">clipsToBounds</span> <span class="o">=</span> <span class="n">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">borderWidth</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">layer</span><span class="p">.</span><span class="n">borderColor</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">darkGrayColor</span><span class="p">].</span><span class="n">CGColor</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我鼓励各位读者深入了解<code>CALayer</code>及其属性，因为你用它能实现的大多数事情会比用Core Graphics自己画要快。然而一如既往，剖析自己的代码是十分重要的。</p>

<p>把可拉伸的图片和图片视图一起使用也可以极大的提高效率。在<a href="http://robots.thoughtbot.com/post/33427366406/designing-for-ios-taming-uibutton">Taming UIButton</a>这个帖子中，Reda Lemeden探索了几种不同的绘图方法。在文章结尾处有一个很有价值的帖子:<a href="https://news.ycombinator.com/item?id=4645585">a comment by Andy Matuschak</a>，解释了可拉伸图片是这些技术中最快的。原因是可拉伸图片在CPU和GPU之间的数据转移量最小，并且这些图片的绘制是经过高度优化的。</p>

<p>处理图片时，你也可以让GPU为你工作来代替使用Core Graphics。使用Core Image，你不必用CPU做任何的工作就可以在图片上建立复杂的效果。你可以直接在OpenGL上下文上直接渲染，所有的工作都在GPU上完成。</p>

<h3>自定义绘制</h3>

<p>如果决定了采用自定义绘制，有几种不同的选项可供选择。如果可能的话，看看是否可以生成一张图片并在内存和磁盘上缓存起来。如果内容是动态的，也许你可以使用Core Animation，如果还是行不通，使用Core Graphics。如果你真的想要接近底层，使用GLKit和原生OpenGL也不是那么难，但是需要做很多工作。</p>

<p>如果你真的选择了重写<code>drawRect:</code>，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，并且当视图的frame改变时并不会重新绘制。</p>

<h2>自定义交互</h2>

<p>正如之前所说的，自定义控件的时候，你几乎一定会扩展一个UIControl的子类。在你的子类里，可以使用目标-动作机制触发事件，如下面的例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">sendActionsForControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了响应触摸，你可能更倾向于使用手势识别。然而如果想要更接近底层，仍然可以重写<code>touchesBegan</code>，<code>touchesMoved</code>和<code>touchesEnded</code>方法来访问原始的触摸行为。但虽说如此，创建一个手势识别的子类来把手势处理相关的逻辑从你的视图或者视图控制器中分离出来，在很多情况下都是一种更合适的方式。</p>

<p>创建自定义控件时所面对的一个普遍的设计问题是向拥有它们的类中回传返回值。比如，假设你创建了一个绘制交互饼状图的自定义控件，想知道用户何时选择了其中一个部分。你可以用很多种不同的方法来解决这个问题，比如通过目标-动作模式，代理，block或者KVO，甚至通知。</p>

<h3>目标-动作</h3>

<p>老式的，通常也是最方便的方法是使用目标-动作。在用户选择后你可以在自定义的视图中做类似这样的事情:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span> <span class="nl">sendActionsForControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果有一个视图控制器在管理这个视图，需要:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupPieChart</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pieChart</span> <span class="nl">addTarget:</span><span class="n">self</span>
</span><span class='line'>                      <span class="nl">action:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">updateSelection:</span><span class="p">)</span>
</span><span class='line'>            <span class="nl">forControlEvents:</span><span class="n">UIControlEventValueChanged</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateSelection:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">pieChart</span><span class="p">.</span><span class="n">selectedSector</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这么做的好处是在自定义视图子类中需要做的事情很少，并且自动获得多目标支持。</p>

<h3>代理</h3>

<p>如果你需要更多的控制从视图发送到视图控制器的消息，通常使用代理模式。在我们的饼状图中，代码看起来大概是这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">pieChart:</span><span class="n">self</span> <span class="nl">didSelectSector:</span><span class="n">self</span><span class="p">.</span><span class="n">selectedSector</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>在视图控制器中，你要写如下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">MyViewController</span> <span class="o">&lt;</span><span class="n">PieChartDelegate</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'> <span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">setupPieChart</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">pieChart</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">pieChart:</span><span class="p">(</span><span class="n">PieChart</span><span class="o">*</span><span class="p">)</span><span class="n">pieChart</span> <span class="nl">didSelectSector:</span><span class="p">(</span><span class="n">PieChartSector</span><span class="o">*</span><span class="p">)</span><span class="n">sector</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="c1">// Handle the sector</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当你想要做更多复杂的工作而不仅仅是通知所有者值发生了变化时，这么做显然更合适。不过虽然大多数开发人员可以非常快速的实现自定义代理，但这种方式仍然有一些缺点:你有必要检查代理是否实现了你想要调用的方法(使用<code>respondsToSelector:</code>)，最重要的，通常你只有一个代理(或者需要创建一个代理数组)。也就是说，一旦视图所有者和视图之间的通信变得稍微复杂，我们几乎总是会采取这种模式。</p>

<h3>Block</h3>

<p>另一个选择是使用block。再一次用饼状图举例，代码看起来大概是这样:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">PieChart</span> : <span class="nc">UIControl</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">copy</span><span class="p">)</span> <span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="n">selectionHandler</span><span class="p">)(</span><span class="n">PieChartSection</span><span class="o">*</span> <span class="n">selectedSection</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>在选取行为的代码中，只需要执行它。在此之前检查一下block是否被赋值非常重要，因为执行一个未被赋值的block会使程序崩溃。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">selectionHandler</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">selectionHandler</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">selectedSection</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方法的好处是可以把相关的代码在视图控制器中整合:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupPieChart</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">pieChart</span><span class="p">.</span><span class="n">selectionHandler</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">PieChartSection</span><span class="o">*</span> <span class="n">section</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Do something with the section</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>就像代理，每个动作通常只有一个block。另一个重要的限制是不要形成引用循环。如果你的视图控制器持有饼状图的强引用，饼状图持有block，block又持有视图控制器，就形成了一个引用循环。只要在block中引用self就会造成这个错误。所以通常代码会以这样结束:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">__weak</span> <span class="kt">id</span> <span class="n">weakSelf</span> <span class="o">=</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">pieChart</span><span class="p">.</span><span class="n">selectionHandler</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">PieChartSection</span><span class="o">*</span> <span class="n">section</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MyViewController</span><span class="o">*</span> <span class="n">strongSelf</span> <span class="o">=</span> <span class="n">weakSelf</span><span class="p">;</span>
</span><span class='line'>    <span class="p">[</span><span class="n">strongSelf</span> <span class="nl">handleSectionChange:</span><span class="n">section</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一旦block中的代码要失去控制(比如block中要处理的事情太多，导致block中的代码过多)，你还可以将它们抽离成独立的方法，而且你可能也已经使用了代理。</p>

<h3>KVO</h3>

<p>如果喜欢KVO，你也可以用它来观察。这有一点神奇而且没那么直接，但当应用中已经使用，它是很好的解耦的设计模式。在饼状图类中，编写代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">selectedSegment</span> <span class="o">=</span> <span class="n">theNewSelectedSegment</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>当使用合成属性，KVO会拦截到该变化并发出通知。在视图控制器中，编写类似的代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupPieChart</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">pieChart</span> <span class="nl">addObserver:</span><span class="n">self</span> <span class="nl">forKeyPath:</span><span class="s">@&quot;selectedSegment&quot;</span> <span class="nl">options:</span><span class="mi">0</span> <span class="nl">context:</span><span class="nb">NULL</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">observeValueForKeyPath:</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="p">)</span><span class="nv">keyPath</span> <span class="nf">ofObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">object</span> <span class="nf">change:</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="p">)</span><span class="nv">change</span> <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">object</span> <span class="o">==</span> <span class="n">self</span><span class="p">.</span><span class="n">pieChart</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="n">keyPath</span> <span class="nl">isEqualToString:</span><span class="s">@&quot;selectedSegment&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Handle change</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>根据你的需要，在<code>viewWillDisappear:</code>或<code>dealloc</code>中，还需要移除观察者。对同一个对象设置多个观察者很容易造成混乱。有一些技术可以解决这个问题，比如<a href="https://github.com/ReactiveCocoa/ReactiveCocoa">ReactiveCocoa</a>或者更轻量级的<a href="https://github.com/th-in-gs/THObserversAndBinders">THObserversAndBinders</a>。</p>

<h3>通知</h3>

<p>作为最后一个选择，如果你想要一个非常松散的耦合，可以使用通知来使其他对象得知变化。对于饼状图来说你几乎肯定不想这样，不过为了讲解的完整，这里介绍如何去做。在饼状图的的头文件中:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">extern</span> <span class="n">NSString</span><span class="o">*</span> <span class="k">const</span> <span class="n">SelectedSegmentChangedNotification</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>在实现文件中:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSString</span><span class="o">*</span> <span class="k">const</span> <span class="n">SelectedSegmentChangedNotification</span> <span class="o">=</span> <span class="s">@&quot;selectedSegmentChangedNotification&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">notifyAboutChanges</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">postNotificationName:</span><span class="n">SelectedSegmentChangedNotification</span> <span class="nl">object:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在订阅通知，在视图控制器中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">setupPieChart</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="p">[[</span><span class="n">NSNotificationCenter</span> <span class="n">defaultCenter</span><span class="p">]</span> <span class="nl">addObserver:</span><span class="n">self</span>
</span><span class='line'>                                           <span class="nl">selector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">segmentChanged:</span><span class="p">)</span>
</span><span class='line'>                                               <span class="nl">name:</span><span class="n">SelectedSegmentChangedNotification</span>
</span><span class='line'>                                              <span class="nl">object:</span><span class="n">self</span><span class="p">.</span><span class="n">pieChart</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">segmentChanged:</span><span class="p">(</span><span class="n">NSNotification</span><span class="o">*</span><span class="p">)</span><span class="nv">note</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当添加了观察者，你可以不将饼状图作为参数<code>object</code>，而是传递<code>nil</code>，以接收所有饼状图对象发出的通知。就像KVO通知，你也需要在恰当的地方退订这些通知。</p>

<p>这项技术的好处是完全的解耦。另一方面，你失去了类型安全，因为在回调中你得到的是一个通知对象，而不像代理，编译器无法检查通知发送者和接受者之间的类型是否匹配。</p>

<h2>辅助功能</h2>

<p>苹果官方提供的标准iOS控件均有辅助功能。这也是推荐用标准控件创建自定义控件的另一个原因。</p>

<p>这或许可以作为一整期的主题，但是如果你编写自定义视图，<a href="http://developer.apple.com/library/ios/#documentation/UserExperience/Conceptual/iPhoneAccessibility/Accessibility_on_iPhone/Accessibility_on_iPhone.html#//apple_ref/doc/uid/TP40008785-CH100-SW3">Accessibility Programming Guide</a>说明了如何创建控件辅助功能。最为值得注意的是，如果有一个视图中有多个需要辅助功能的元素，但它们并不是该视图的子视图，你可以让视图实现<code>UIAccessibilityContainer</code>协议。对于每一个元素，返回一个描述它的<code>UIAccessibilityElement</code>对象。</p>

<h2>本地化</h2>

<p>创建自定义视图时，本地化也同样重要。如辅助功能一样，这个可以作为一整期的话题。本地化自定义视图的最直接工作就是字符串内容。如果使用<code>NSString</code>，你不必担心编码问题。如果在自定义视图中展示日期或数字，使用日期和数字格式化类来展示它们。使用<code>NSLocalizedString</code>本地化字符串。</p>

<p>另一个本地化过程中很有用的工具是Auto Layout。例如，有在英文中很短的词在德语中可能会很长。如果根据英文单词的长度对视图的尺寸做硬编码，那么当翻译成德文的时候几乎一定会遇上麻烦。通过使用Auto Layout，让标签控件自动调整为内容的尺寸，并向依赖元素添加一些其他的限制以确保重新设置尺寸，使这项工作变得非常简单。苹果为此提供了一个很好的<a href="http://developer.apple.com/library/ios/#referencelibrary/GettingStarted/RoadMapiOS/chapters/InternationalizeYourApp/InternationalizeYourApp/InternationalizeYourApp.html">introduction</a>。另外，对于类似希伯来语这种顺序从右到左的语言，如果你使用了leading和trailing属性，整个视图会自动按照从右到左的顺序展示，而不是硬编码的从左至右。</p>

<h2>测试</h2>

<p>最后，让我们考虑测试视图的问题。对于单元测试，你可以使用Xcode自带的工具或者其它第三方框架。另外，可以使用UIAutomation或者其它基于它的工具。为此，你的视图完全支持辅助功能是必要的。UIAutomation并未充分得到利用的一个功能是截图;你可以用它<a href="http://jeffkreeftmeijer.com/2011/comparing-images-and-creating-image-diffs/">自动对比</a>视图和设计以确保两者每一个像素都分毫不差。(另一个无关的功能:你还可以使用它来为应用<a href="http://www.smallte.ch/blog-read_en_29001.html">自动生成截图</a>，这在你有多个多国语言的应用时特别有用)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正确定义Objective-C常量]]></title>
    <link href="http://objcio.com/blog/2014/02/14/correct-way-of-defining-constants-in-objective-c/"/>
    <updated>2014-02-14T11:39:00+08:00</updated>
    <id>http://objcio.com/blog/2014/02/14/correct-way-of-defining-constants-in-objective-c</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://walkingsmarts.com/correct-way-of-defining-constants-in-objective-c/">Correct Way of Defining Constants in Objective-C</a>，转载请注明出处。</p>

<p>本文只是一个关于如何在Cocoa代码中定义常量的书签贴，答案来自于<a href="http://stackoverflow.com/questions/538996/constants-in-objective-c">stackoverflow.com的这个问题</a>。这里为那些懒人提供了一些简短的介绍和帖子本身。你可能读遍了苹果开发者文档，知道一些特定的方法参数只能接受定义为常量的枚举值列表。比如事件类型标记(<code>NSKeyUpMask</code>，<code>NSKeyDownMask</code>，等等)，persistent store coordinator的存储类型(<code>NSSQLiteStoreType</code>，<code>NSBinaryStoreType</code>和<code>NSInMemoryStoreType</code>)，当然还有很多其他的。所有的这些归结为几行代码。实际上定义常量的时候代码行数是你想要的常量的两倍。步骤为:首先，创建<code>Constants.h</code>和<code>Constants.m</code>文件用来存放我们的常量。在<code>Constants.h</code>中，指定常量名字，将常量声明为一个指向<code>NSString</code>对象的指针:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Constants.h</span>
</span><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">MyOwnConstant</span><span class="p">;</span>
</span><span class='line'><span class="k">extern</span> <span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">YetAnotherConstant</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，在<code>Constants.m</code>中通过赋值定义常量:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Constants.m</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span> <span class="n">MyOwnConstant</span> <span class="o">=</span> <span class="s">@&quot;myOwnConstant&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">NSString</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">YetAnotherConstant</span> <span class="o">=</span> <span class="s">@&quot;yetAnotherConstant&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在你所需要做的只是引入<code>Constants.h</code>文件到你工程的预编译头文件。如果你有点小聪明，可能脑中会有两个问题。第一个问题或许是:在能够使用<code>#define</code>的情况下为什么要使用这种方法?这是个非常有意义的问题。答案很简单(但是在读到<a href="http://stackoverflow.com/questions/538996/constants-in-objective-c/539191#539191">这个答案</a>之前还不是很明显) &mdash; 使用这种方法你可以进行指针比较(<code>@"myString" == MyConstant</code>)而不是字符串比较(<code>[@"myString" isEqualToString:MyConstant]</code>)。前者非常非常快。第二个问题应该是为什么应该完全使用常量。又一个有意义的问题。你可以在每个使用常量的地方使用常量对应的值。但是有两个&#8221;但是&#8221;。第一，始终有人的因素。你很容易输入错字符串，而编译器并不会抱怨你的语法。但如果使用常量，它就会在你输入错常量名称的时候给予你警告。还有(第二个&#8221;但是&#8221;)，XCode会尽最大努力的帮助我们自动完成代码，这些常量也不例外，因此方法会变得非常方便。Happy coding!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础集合类]]></title>
    <link href="http://objcio.com/blog/2014/01/20/the-foundation-collection-classes/"/>
    <updated>2014-01-20T17:41:00+08:00</updated>
    <id>http://objcio.com/blog/2014/01/20/the-foundation-collection-classes</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://www.objc.io/issue-7/collections.html">The Foundation Collection Classes</a>，转载请注明出处。</p>

<h2>NSArray, NSSet, NSOrderedSet 和 NSDictionary</h2>

<p>基础集合类是每一个Mac/iOS应用的基本组成部分。在本文中，我们将对&#8221;老类&#8221;(<code>NSArray</code>, <code>NSSet</code>)和&#8221;新类&#8221;(<code>NSMapTable</code>, <code>NSHashTable</code>, <code>NSPointerArray</code>)进行一个深入的研究，探索每一个的效率细节，并讨论其使用场景。</p>

<p>作者提示:本文包含一些参照结果，但它们并不意味着绝对精确，也没有进行多个、复杂的测试。这些结果的目的是给出一个快速和主要的运行时统计。所有的测试基于iPhone 5s，使用Xcode 5.1b1和iOS 7.1b1，64位的程序。编译选项设置为-Ofast的发布构建。Vectorize loops和unroll loops(默认设置)均设置为关闭。</p>

<!--more-->


<h2>大O符号</h2>

<p>首先，我们需要一些理论知识。效率通常用<a href="https://en.wikipedia.org/wiki/Big_O_notation">大O符号</a>描述。它定义了一个函数的 <em>极限特征</em> ，通常被用于描绘其算法效率。O定义了函数增长率的上限。通过查看通常使用的O符号和所需要的操作数来查看差异的大小。</p>

<p><img src="http://objcio.com/images/posts/2014-01-20-the-foundation-collection-classes-01.png" alt="" /></p>

<p>例如，如果用算法复杂度为O(n<sup>2</sup>)的算法对一个有50个元素的数组排序，需要2500步的操作。而且，还有内部的系统开销和方法调用 &mdash; 所以是2500个操作的时间常量。 O(1)是理想的复杂度，代表着恒定的时间。<a href="http://en.wikipedia.org/wiki/Sorting_algorithm#Comparison_of_algorithms">好的算法通常需要O(n*log n)的时间</a>。</p>

<h2>可变性</h2>

<p>大多数的集合类存在两个版本:可变和不可变(默认)。这和其他大多数的框架有非常大的不同，一开始会让人觉得有一点奇怪。然而其他的框架现在也应用了这一特性:就在几个月前，<a href="http://blogs.msdn.com/b/dotnet/archive/2013/09/25/immutable-collections-ready-for-prime-time.aspx">.NET公布了作为官方扩展的不可变集合</a>。</p>

<p>最大的好处是什么?<strong>线程安全</strong>。不可变的集合完全是线程安全的，可以同时在多个线程中迭代，避免各种突变异常的风险。你的API <em>绝不</em> 应该暴露可变集合。</p>

<p>当然从不可变到可变再变回来会有一定的代价 &mdash; 对象必须被拷贝两次，所有集合内的对象将被retain/release。有时在内部使用一个可变的集合而在出口返回一个不可变的对象副本会更高效。</p>

<p>与其他框架不同，苹果没有提供一个线程安全的可变集合，<code>NSCache</code>是例外 &mdash; 但它真的算不上是集合类，因为它不是一个通用的容器。大多数时候，你的确想要高于集合级别的同步。想象一段代码，作用是检查字典中一个key是否存在，并根据检查结果决定设置一个新的key或者返回某些值 &mdash; 你通常需要把多个操作归类，这时线程安全的可变变体并不能帮助你。</p>

<p>这里有一些同步的，线程安全的可变集合有效的使用案例，只需要用几行代码，通过子类和组合的方法建立诸如<a href="https://gist.github.com/steipete/7746843"><code>NSDictionary</code></a>或<a href="https://github.com/Cue/TheKitchenSync/blob/master/Classes/Collections/CueSyncArray.mm"><code>NSArray</code></a>。</p>

<p>需要注意的是，一些更新式的集合类，如<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>默认就是可变的，它们并没有对应的不可变的类。它们用于类的内部使用，或者某个你想要不常见的可变类的场景。</p>

<h2>NSArray</h2>

<p><code>NSArray</code>作为一个存储对象的有序集合，可能是被使用最多的集合类。这也是为什么它有自己的比原来的<code>[NSArray arrayWithObjects:..., nil]</code>简短得多的快速语法糖符号<code>@[...]</code>。</p>

<p><code>NSArray</code>实现了<code>objectAtIndexedSubscript:</code>，因为我们可以使用类C的语法<code>array[0]</code>来代替原来的<code>[array objectAtIndex:0]</code>。</p>

<h2>性能特征</h2>

<p>关于<code>NSArray</code>的内容比你想象的要多的多。基于存储对象的多少，它使用各种内部的变体。最有趣的部分是苹果对于个别的对象访问并不保证O(1)的访问时间 &mdash; 正如你在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFArray.h">CFArray.h CoreFoundation header</a>中的关于算法复杂度的注解中可以读到的:</p>

<blockquote><p>The access time for a value in the array is guaranteed to be at worst O(lg N) for any implementation, current and future, but will often be O(1) (constant time). Linear search operations similarly have a worst case complexity of O(Nlg N), though typically the bounds will be tighter, and so on. Insertion or deletion operations will typically be linear in the number of values in the array, but may be O(Nlg N) clearly in the worst case in some implementations. There are no favored positions within the array for performance; that is, it is not necessarily faster to access values with low indices, or to insert or delete values with high indices, or whatever.</p></blockquote>

<p>在测量的时候，<code>NSArray</code>产生了一些<a href="http://ridiculousfish.com/blog/posts/array.html">有趣的额外的性能特征</a>。在数组的开头和结尾插入/删除元素通常是一个O(1)操作，而随机的插入/删除通常是 O(N)的。</p>

<h2>有用的方法</h2>

<p><code>NSArray</code>的大多数方法使用<code>isEqual:</code>来检查对象间的关系(例如<code>containsObject:</code>)。有一个特别的方法<code>indexOfObjectIdenticalTo:</code>用来检查指针相等，如果你确保在同一个集合中搜索，那么这个方法可以很大的提升搜索速度。</p>

<p>在iOS 7中，我们最终得到了与<code>lastObject</code>对应的公开的<code>firstObject</code>方法，对于空数组，这两个方法都会返回<code>nil</code> &mdash; 而常规的访问方法会抛出一个<code>NSRangeException</code>异常。</p>

<p>关于构造(可变)数组有一个漂亮的细节可以节省代码量。如果你通过一个可能为nil的数组创建一个可变数组，通常会这么写:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">];</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutableObjects</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者通过更简洁的<a href="http://en.wikipedia.org/wiki/%3F:">三元运算符</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="n">mutableCopy</span><span class="p">]</span> <span class="o">?:</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>更好的解决方案是使用<code>arrayWithArray:</code>，即使原数组为nil，该方法也会返回一个数组对象:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithArray:</span><span class="n">array</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两个操作在效率上几乎相等。使用<code>copy</code>会快一点点，不过话说回来，这不太可能是你应用的瓶颈所在。<strong>提醒:</strong>不要使用<code>[@[] mutableCopy]</code>。经典的<code>[NSMutableArray array]</code>可读性更好。</p>

<p>翻转一个数组非常简单:<code>array.reverseObjectEnumerator.allObjects</code>。我们使用系统提供的<code>reverseObjectEnumerator</code>，每一个<code>NSEnumerator</code>都实现了<code>allObjects</code>，该方法返回一个新数组。虽然没有原生的<code>randomObjectEnumerator</code>方法，你可以写一个自定义的打乱数组顺序的枚举器或者使用<a href="https://github.com/mattt/TTTRandomizedEnumerator/blob/master/TTTRandomizedEnumerator/TTTRandomizedEnumerator.m">一些出色的开源代码</a>。</p>

<h2>数组排序</h2>

<p>有很多各种各样的方法来对一个数组排序。如果数组存储的是字符串对象，<code>sortedArrayUsingSelector:</code>是第一选择:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="s">@&quot;John Appleseed&quot;</span><span class="p">,</span> <span class="s">@&quot;Tim Cook&quot;</span><span class="p">,</span> <span class="s">@&quot;Hair Force One&quot;</span><span class="p">,</span> <span class="s">@&quot;Michael Jurewitz&quot;</span><span class="p">];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">sortedArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">array</span> <span class="nl">sortedArrayUsingSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">localizedCaseInsensitiveCompare:</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的代码对存储数字的内容同样很好，因为<code>NSNumber</code>实现了<code>compare:</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">numbers</span> <span class="o">=</span> <span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">9</span><span class="p">,</span> <span class="err">@</span><span class="mi">5</span><span class="p">,</span> <span class="err">@</span><span class="mi">11</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">,</span> <span class="err">@</span><span class="mi">1</span><span class="p">];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">sortedNumbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">numbers</span> <span class="nl">sortedArrayUsingSelector:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">compare:</span><span class="p">)];</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果想更可控，可以使用基于函数指针的排序方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayHint</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="n">NSInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="nv">comparator</span>
</span><span class='line'>                              <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingFunction:</span><span class="p">(</span><span class="n">NSInteger</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">id</span><span class="p">,</span> <span class="kt">id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="nv">comparator</span>
</span><span class='line'>                              <span class="nf">context:</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="nv">context</span> <span class="nf">hint:</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="p">)</span><span class="nv">hint</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>苹果增加了一个方法来加速使用<code>sortedArrayHint</code>的排序。</p>

<blockquote><p>The hinted sort is most efficient when you have a large array (N entries) that you sort once and then change only slightly (P additions and deletions, where P is much smaller than N). You can reuse the work you did in the original sort by conceptually doing a merge sort between the N “old” items and the P “new” items. To obtain an appropriate hint, you use sortedArrayHint when the original array has been sorted, and keep hold of it until you need it (when you want to re-sort the array after it has been modified).</p></blockquote>

<p>因为block的引入，也出现了一些基于block的排序方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">sortedArrayWithOptions:</span><span class="p">(</span><span class="n">NSSortOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class='line'>                    <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>性能上来说，不同的方法间并没有太多的不同。有趣的是，基于selector的方式是最快的。<a href="https://github.com/steipete/PSTFoundationBenchmark">你可以在GitHub上找到测试用的源代码</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Sorting</span> <span class="mi">1000000</span> <span class="n">elements</span><span class="p">.</span> <span class="nl">selector:</span> <span class="mf">4947.90</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span> <span class="nl">function:</span> <span class="mf">5618.93</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span> <span class="nl">block:</span> <span class="mf">5082.98</span><span class="p">[</span><span class="n">ms</span><span class="p">].</span>
</span></code></pre></td></tr></table></div></figure>


<h2>二分查找</h2>

<p><code>NSArray</code>从iOS 4/Snow Leopard开始内置了<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="nf">NS_OPTIONS</span><span class="p">(</span><span class="n">NSUInteger</span><span class="p">,</span> <span class="n">NSBinarySearchingOptions</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">NSBinarySearchingFirstEqual</span>     <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">),</span>
</span><span class='line'>        <span class="n">NSBinarySearchingLastEqual</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">),</span>
</span><span class='line'>        <span class="n">NSBinarySearchingInsertionIndex</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">UL</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">),</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSUInteger</span><span class="p">)</span><span class="nf">indexOfObject:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">obj</span>
</span><span class='line'>              <span class="nf">inSortedRange:</span><span class="p">(</span><span class="n">NSRange</span><span class="p">)</span><span class="nv">r</span>
</span><span class='line'>                    <span class="nf">options:</span><span class="p">(</span><span class="n">NSBinarySearchingOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class='line'>            <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmp</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>为什么要使用这个方法?类似<code>containsObject:</code>和<code>indexOfObject:</code>这样的方法从0索引开始搜索每个对象直到找到目标 &mdash; 不需要数组被排序而且是O(n)的效率特性。换句话说，二分查找需要数组事先被排序，但只需要O(log n)的时间。因此，对于1,000,000的记录，二分查找法最多只需要21次比较，而传统的线性查找则平均需要5000,000次的比较。</p>

<p>这是个简单的衡量二分查找有多快的数据:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Time</span> <span class="n">to</span> <span class="n">search</span> <span class="k">for</span> <span class="mi">1000</span> <span class="n">entries</span> <span class="n">within</span> <span class="mi">1000000</span> <span class="n">objects</span><span class="p">.</span> <span class="nl">Linear:</span> <span class="mf">54130.38</span><span class="p">[</span><span class="n">ms</span><span class="p">].</span> <span class="nl">Binary:</span> <span class="mf">7.62</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>作为比较，查找<code>NSOrderedSet</code>中的指定索引花费0.23毫秒 &mdash; 即使跟二分查找相比也快了30多倍。</p>

<p>记住排序的开销也是昂贵的。苹果使用复杂度为O(n*log n)的归并排序，所以如果执行过<code>indexOfObject:</code>一次，就没有必要使用二分查找了。</p>

<p>通过指定<code>NSBinarySearchingInsertionIndex</code>，你可以获得正确的插入索引，以确保在插入元素后仍然可以保证数组的顺序。</p>

<h2>枚举和高阶消息</h2>

<p>作为参照，我们来看一个普通的使用场景。从一个数组中过滤出另一个数组。测试了多个枚举方法和API特性:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// First variant, using `indexesOfObjectsWithOptions:passingTest:`.</span>
</span><span class='line'><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">indexesOfObjectsWithOptions:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class='line'>                                                   <span class="nl">passingTest:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">filteredArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">objectsAtIndexes:</span><span class="n">indexes</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Filtering using predicates (block-based or text)    </span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">filteredArray2</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="nl">filteredArrayUsingPredicate:</span><span class="p">[</span><span class="n">NSPredicate</span> <span class="nl">predicateWithBlock:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">bindings</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}]];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Block-based enumeration </span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">randomArray</span> <span class="nl">enumerateObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Classic enumeration</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">randomArray</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Using NSEnumerator, old school.</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomArray</span> <span class="n">objectEnumerator</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">while</span> <span class="p">((</span><span class="n">obj</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Using objectAtIndex: (via subscripting)</span>
</span><span class='line'><span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">mutableArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">array</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">randomArray</span><span class="p">.</span><span class="n">count</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomArray</span><span class="p">[</span><span class="n">idx</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">mutableArray</span> <span class="nl">addObject:</span><span class="n">obj</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--
Enumeration Method / Time [ms]  | 10.000.000 elements | 10.000 elements
:------------------------------ | ------------------: | --------------:
`indexesOfObjects:`, concurrent |             1844.73 |            2.25
`NSFastEnumeration` (for in)    |             3223.45 |            3.21
`indexesOfObjects:`             |             4221.23 |            3.36
`enumerateObjectsUsingBlock:`    |             5459.43 |            5.43
`objectAtIndex:`                |             5282.67 |            5.53
`NSEnumerator`                  |             5566.92 |            5.75
`filteredArrayUsingPredicate:`  |             6466.95 |            6.31
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Enumeration Method / Time [ms]  </th>
<th align="right"> 10.000.000 elements </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>indexesOfObjects:</code>, concurrent </td>
<td align="right"> 1844.73             </td>
<td align="right">            2.25 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code> (for in)    </td>
<td align="right"> 3223.45             </td>
<td align="right">            3.21 </td>
</tr>
<tr>
<td align="left"> <code>indexesOfObjects:</code>              </td>
<td align="right">             4221.23 </td>
<td align="right">            3.36 </td>
</tr>
<tr>
<td align="left"> <code>enumerateObjectsUsingBlock:</code>    </td>
<td align="right">             5459.43 </td>
<td align="right">            5.43 </td>
</tr>
<tr>
<td align="left"> <code>objectAtIndex:</code>                </td>
<td align="right">             5282.67 </td>
<td align="right">            5.53 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumerator</code>                  </td>
<td align="right">             5566.92 </td>
<td align="right">            5.75 </td>
</tr>
<tr>
<td align="left"> <code>filteredArrayUsingPredicate:</code>  </td>
<td align="right">             6466.95 </td>
<td align="right">            6.31 </td>
</tr>
</tbody>
</table>


<p>为了更好的理解这里的效率测量，我们首先看一下数组是如何迭代的。</p>

<p><code>indexesOfObjectsWithOptions:passingTest:</code>必须每次都执行一次block因此比传统的使用<code>NSFastEnumeration</code>技术的基于for循环的枚举要稍微低效一些。然后如果开启了并发枚举，那么前者的速度则会大大的超过后者几乎2倍。iPhone 5s是双核的，所以这说得通。这里并没有体现出来的是<code>NSEnumerationConcurrent</code>只对大量的对象有意义，如果你的集合中的对象数量很少，用哪个方法就真的无关紧要。甚至<code>NSEnumerationConcurrent</code>上额外的线程管理实际上会使结果变得更慢。</p>

<p>最大的输家是<code>filteredArrayUsingPredicate:</code>。<code>NSPredicate</code>需要在这里提及是因为，人们可以写出<a href="http://nshipster.com/nspredicate/">非常复杂的表达式</a>，尤其是用不基于block的变体。使用Core Data的用户应该会很熟悉。</p>

<p>为了比较的完整，我们也加入了<code>NSEnumerator</code>作为比较 &mdash; 虽然没有任何理由再使用它了。然而它竟出人意料的快(比基于<code>NSPredicate</code>的查找要快)，它的运行时消耗无疑比快速枚举更多 &mdash; 现在它只用于向后兼容。甚至没有优化过的<code>objectAtIndex:</code>都要更快些。</p>

<h2>NSFastEnumeration</h2>

<p>在OSX 10.5和iOS的最初版本中，苹果增加了<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/NSFastEnumeration_protocol/Reference/NSFastEnumeration.html"><code>NSFastEnumeration</code></a>。在此之前，只有每次返回一个元素的<code>NSEnumeration</code>，每次迭代都有运行时开销。而快速枚举，苹果通过<code>countByEnumeratingWithState:objects:count:</code>返回一个数据块。该数据块被解析成<code>ids</code>类型的C数组。这就是更快的速度的原因;迭代一个C数组更快，而且可以被编译器更深一步的优化。手动的实现快速枚举是十分难办的，所以苹果的<a href="https://developer.apple.com/library/ios/samplecode/FastEnumerationSample/Introduction/Intro.html">FastEnumerationSample</a>是一个不错的开始，还有一篇<a href="http://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html">Mike Ash的文章</a>也很不错。</p>

<h2>应该用arrayWithCapacity:吗?</h2>

<p>初始化<code>NSArray</code>的时候，可以选择指定数组的预期大小。在检测的时候，结果是在效率上没有差别 &mdash; 测量的时间几乎相等，且在统计不确定性的范围内。有消息透漏说实际上苹果并没有使用这个特性。然而使用<code>arrayWithCapacity:</code>仍然有用，在文档不清晰的代码中，它可以帮助理解代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Adding</span> <span class="mf">10.000.000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">NSArray</span><span class="p">.</span> <span class="n">no</span> <span class="n">count</span> <span class="mf">1067.35</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span> <span class="n">with</span> <span class="nl">count:</span> <span class="mf">1083.13</span><span class="p">[</span><span class="n">ms</span><span class="p">].</span>
</span></code></pre></td></tr></table></div></figure>


<h2>子类化注意事项</h2>

<p>很少有理由去子类化基础集合类。大多数时候，使用CoreFoundation级别的类并且自定义回调函数定制自定义行为是更好的解决方案。</p>

<p>创建一个大小写不敏感的字典，一种方法是子类化<code>NSDictionary</code>并且自定义访问方法，使其将字符串始终变为小写(或大写)，并对排序也做类似的修改。更快更好的解决方案是提供一个不同的<code>CFDictionaryKeyCallBacks</code>集，你可以提供自定义的<code>hash</code>和<code>isEqual:</code>回调。你可以在<a href="https://gist.github.com/steipete/7739473">这里</a>找到一个例子。这种方法的优美之处(感谢<a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html">toll-free bridging</a>)在于它仍然是一个简单的字典，可以被任何使用<code>NSDictionary</code>作为参数的API接受。</p>

<p>子类作用的一个例子是有序字典的用例。.NET提供了一个<code>SortedDictionary</code>，Java有<code>TreeMap</code>，C++有<code>std::map</code>。虽然你 <em>可以</em> 使用C++的STL容器，但却无法使它自动的<code>retain/release</code>，这会使使用起来笨重的多。因为<code>NSDictionary</code>是一个<a href="https://developer.apple.com/library/ios/documentation/general/conceptual/CocoaEncyclopedia/ClassClusters/ClassClusters.html">类簇</a>，所以子类化跟人们想象的相比非常不同。这已经超过了本文的讨论范畴，<a href="https://github.com/nicklockwood/OrderedDictionary/blob/master/OrderedDictionary/OrderedDictionary.m">这里</a>有一个真实的有序字典的例子。</p>

<h2>NSDictionary</h2>

<p>一个字典存储任意的对象键值对。 由于历史原因，初始化方法使用相反的对象到值的方法，<code>[NSDictionary dictionaryWithObjectsAndKeys:object, key, nil]</code>，而新的快捷语法则从key开始，<code>@{key : value, ...}</code>。</p>

<p><code>NSDictionary</code>中的键是被拷贝的并且需要是恒定的。如果在一个键在被用于在字典中放入一个值后被改变，那么这个值可能就会变得无法获取了。一个有趣的细节，在<code>NSDictionary</code>中键是被拷贝的，而在使用一个toll-free桥接的<code>CFDictionary</code>时却只被retain。CoreFoundation类没有通用对象的拷贝方法，因此这时拷贝是不可能的(*)。这只适用于使用<code>CFDictionarySetValue()</code>的时候。如果通过<code>setObject:forKey</code>使用toll-free桥接的<code>CFDictionary</code>，苹果增加了额外处理逻辑来使键被拷贝。反过来这个结论则不成立 &mdash; 转换为<code>CFDictionary</code>的<code>NSDictionary</code>对象，对其使用<code>CFDictionarySetValue()</code>方法会调用回<code>setObject:forKey</code>并拷贝键。</p>

<p>(*)有一个现成的键的回调函数<code>kCFCopyStringDictionaryKeyCallBacks</code>会拷贝字符串，因为<code>CFStringCreateCopy()</code>会调用<code>[NSObject copy]</code>，我们可以使用这个回调来创建一个拷贝键的<code>CFDictionary</code>。</p>

<h2>性能特征</h2>

<p>苹果在定义计算复杂度时显得相当安静。关于它的唯一注释可以在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFDictionary.h"><code>CFDictionary</code>的头文件</a>中找到:</p>

<blockquote><p>The access time for a value in the dictionary is guaranteed to be at worst O(N) for any implementation, current and future, but will often be O(1) (constant time). Insertion or deletion operations will typically be constant time as well, but are O(N*N) in the worst case in some implementations. Access of values through a key is faster than accessing values directly (if there are any such operations). Dictionaries will tend to use significantly more memory than a array with the same number of values.</p></blockquote>

<p>跟数组相似的，字典根据尺寸的不同使用不同的实现，并在其中无缝切换。</p>

<h2>枚举和高阶消息</h2>

<p>过滤字典有几个不同的方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Using keysOfEntriesWithOptions:passingTest:,optionally concurrent</span>
</span><span class='line'><span class="n">NSSet</span> <span class="o">*</span><span class="n">matchingKeys</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="nl">keysOfEntriesWithOptions:</span><span class="n">NSEnumerationConcurrent</span>
</span><span class='line'>                                               <span class="nl">passingTest:</span><span class="o">^</span><span class="kt">BOOL</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">keys</span> <span class="o">=</span> <span class="n">matchingKeys</span><span class="p">.</span><span class="n">allObjects</span><span class="p">;</span>
</span><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="nl">objectsForKeys:</span><span class="n">keys</span> <span class="nl">notFoundMarker:</span><span class="n">NSNull</span><span class="p">.</span><span class="n">null</span><span class="p">];</span>
</span><span class='line'><span class="n">__unused</span> <span class="n">NSDictionary</span> <span class="o">*</span><span class="n">filteredDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">dictionaryWithObjects:</span><span class="n">values</span>
</span><span class='line'>                                                                        <span class="nl">forKeys:</span><span class="n">keys</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Block-based enumeration.</span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">randomDict</span> <span class="nl">enumerateKeysAndObjectsUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">key</span><span class="p">,</span> <span class="kt">id</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// NSFastEnumeration</span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">id</span> <span class="n">key</span> <span class="k">in</span> <span class="n">randomDict</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomDict</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'> <span class="c1">// NSEnumeration</span>
</span><span class='line'> <span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'> <span class="n">NSEnumerator</span> <span class="o">*</span><span class="n">enumerator</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomDict</span> <span class="n">keyEnumerator</span><span class="p">];</span>
</span><span class='line'> <span class="kt">id</span> <span class="n">key</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'> <span class="k">while</span> <span class="p">((</span><span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">enumerator</span> <span class="n">nextObject</span><span class="p">])</span> <span class="o">!=</span> <span class="nb">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">randomDict</span><span class="p">[</span><span class="n">key</span><span class="p">];</span>
</span><span class='line'>       <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// C-based array enumeration via getObjects:andKeys:</span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">mutableDictionary</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="n">dictionary</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">objects</span><span class="p">[</span><span class="n">numberOfEntries</span><span class="p">];</span>
</span><span class='line'><span class="kt">id</span> <span class="n">__unsafe_unretained</span> <span class="n">keys</span><span class="p">[</span><span class="n">numberOfEntries</span><span class="p">];</span>
</span><span class='line'><span class="p">[</span><span class="n">randomDict</span> <span class="nl">getObjects:</span><span class="n">objects</span> <span class="nl">andKeys:</span><span class="n">keys</span><span class="p">];</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numberOfEntries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="kt">id</span> <span class="n">key</span> <span class="o">=</span> <span class="n">keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">testObj</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>       <span class="n">mutableDictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<!--
Filtering/Enumeration Method / Time [ms] | 50.000 elements | 1.000.000 elements
:--------------------------------------- | --------------: | -----------------:
`keysOfEntriesWithOptions:`, concurrent  |           16.65 |             425.24
`getObjects:andKeys:`                    |           30.33 |            798.49*
`keysOfEntriesWithOptions:`              |           30.59 |             856.93
`enumerateKeysAndObjectsUsingBlock:`     |           36.33 |             882.93
`NSFastEnumeration`                      |           41.20 |            1043.42
`NSEnumeration`                          |           42.21 |            1113.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Filtering/Enumeration Method / Time [ms] </th>
<th align="right"> 50.000 elements </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>, concurrent  </td>
<td align="right">           16.65 </td>
<td align="right">             425.24 </td>
</tr>
<tr>
<td align="left"> <code>getObjects:andKeys:</code>                    </td>
<td align="right">           30.33 </td>
<td align="right">            798.49* </td>
</tr>
<tr>
<td align="left"> <code>keysOfEntriesWithOptions:</code>              </td>
<td align="right">           30.59 </td>
<td align="right">             856.93 </td>
</tr>
<tr>
<td align="left"> <code>enumerateKeysAndObjectsUsingBlock:</code>     </td>
<td align="right">           36.33 </td>
<td align="right">             882.93 </td>
</tr>
<tr>
<td align="left"> <code>NSFastEnumeration</code>                      </td>
<td align="right">           41.20 </td>
<td align="right">            1043.42 </td>
</tr>
<tr>
<td align="left"> <code>NSEnumeration</code>                          </td>
<td align="right">           42.21 </td>
<td align="right">            1113.08 </td>
</tr>
</tbody>
</table>


<p>(*)使用<code>getObjects:andKeys:</code>时需要注意。在上面的代码例子中，我们使用了<a href="http://gcc.gnu.org/onlinedocs/gcc/Variable-Length.html">可变长度数组</a>的C99特性(通常，数组的数量需要是一个固定值)。在栈上分配了内存，虽然有限但是更方便一点。上面的代码在有数量较大的元素的时候会崩溃掉，所以使用基于<code>malloc/calloc</code>的分配(和<code>free</code>)以确保安全。</p>

<p>为什么这次<code>NSFastEnumeration</code>这么慢?迭代字典通常需要键和值;快速枚举只能枚举键，我们必须每次都自己获取值。使用基于block的<code>enumerateKeysAndObjectsUsingBlock:</code>更高效，因为值可以更高效的被提前获取。</p>

<p>这个测试的胜利者又是并发迭代<code>keysOfEntriesWithOptions:passingTest:</code>和<code>objectsForKeys:notFoundMarker:</code>。代码稍微多了一点，但是可以用category进行漂亮的封装。</p>

<h2>应该用dictionaryWithCapacity:吗?</h2>

<p>到现在你应该已经知道该如何测试了，简单的回答是<strong>不</strong>，<code>count</code>参数没有改变任何事情:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Adding</span> <span class="mi">10000000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">NSDictionary</span><span class="p">.</span> <span class="n">no</span> <span class="n">count</span> <span class="mf">10786.60</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span> <span class="n">with</span> <span class="nl">count:</span> <span class="mf">10798.40</span><span class="p">[</span><span class="n">ms</span><span class="p">].</span>
</span></code></pre></td></tr></table></div></figure>


<h2>排序</h2>

<p>关于字典排序没有太多可说的。你只能将键排序为一个新对象，因此你可以使用任何正规的<code>NSArray</code>的排序方法:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueUsingSelector:</span><span class="p">(</span><span class="kt">SEL</span><span class="p">)</span><span class="nv">comparator</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueUsingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">)</span><span class="nf">keysSortedByValueWithOptions:</span><span class="p">(</span><span class="n">NSSortOptions</span><span class="p">)</span><span class="nv">opts</span>
</span><span class='line'>                          <span class="nf">usingComparator:</span><span class="p">(</span><span class="n">NSComparator</span><span class="p">)</span><span class="nv">cmptr</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>共享键</h2>

<p>从iOS 6和OS X 10.8开始，字典可以使用一个事先生成好的键集，使用<code>sharedKeySetForKeys:</code>从一个数组中创建键集，用<code>dictionaryWithSharedKeySet:</code>创建字典。共享键集会复用对象，以节省内存。根据<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-FoundationOlderNotes/">Foundation Release Notes</a>，<code>sharedKeySetForKeys:</code>中会计算一个最小最完美的哈希值，这个哈希值丢弃了字典查找过程中探索循环的需要，因此使键的访问更快。</p>

<p>这在JSON解析的时候是完美的使用场景，虽然在我们有限的测试中无法看到苹果在<code>NSJSONSerialization</code>中使用。(使用共享键集创建的字典是<code>NSSharedKeyDictionary</code>的子类;标准的字典是<code>__NSDictionaryI</code>/<code>__NSDictionaryM</code>，I/M表明可变性;toll-free桥接的字典是<code>_NSCFDictionary</code>类，既是可变也是不可变的。)</p>

<p><strong>有趣的细节</strong>:共享键字典<strong>始终是可变的</strong>，即使对它们执行了&#8221;copy&#8221;命令后。这个行为文档中并没有说明，但很容易被测试:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="kt">id</span> <span class="n">sharedKeySet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSDictionary</span> <span class="nl">sharedKeySetForKeys:</span><span class="err">@</span><span class="p">[</span><span class="err">@</span><span class="mi">1</span><span class="p">,</span> <span class="err">@</span><span class="mi">2</span><span class="p">,</span> <span class="err">@</span><span class="mi">3</span><span class="p">]];</span> <span class="c1">// returns NSSharedKeySet</span>
</span><span class='line'><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="n">test</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableDictionary</span> <span class="nl">dictionaryWithSharedKeySet:</span><span class="n">sharedKeySet</span><span class="p">];</span>
</span><span class='line'><span class="n">test</span><span class="p">[</span><span class="err">@</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="s">@&quot;First element (not in the shared key set, but will work as well)&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">immutable</span> <span class="o">=</span> <span class="p">[</span><span class="n">test</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">immutable</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
</span><span class='line'><span class="p">((</span><span class="n">NSMutableDictionary</span> <span class="o">*</span><span class="p">)</span><span class="n">immutable</span><span class="p">)[</span><span class="err">@</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="s">@&quot;Adding objects to an immutable collection should throw an exception.&quot;</span><span class="p">;</span>
</span><span class='line'><span class="n">NSParameterAssert</span><span class="p">(</span><span class="n">immutable</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>NSSet</h2>

<p><code>NSSet</code>和它的可变变体<code>NSMutableSet</code>是无序对象集合。检查一个对象是否存在通常是一个O(1)的操作，使得比<code>NSArray</code>快很多。<code>NSSet</code>只在被使用的哈希方法平衡的情况下能高效的工作;如果所有的对象都在同一个哈希筐内，<code>NSSet</code>在查找对象是否存在时并不比<code>NSArray</code>快多少。</p>

<p><code>NSSet</code>还有变体<code>NSCountedSet</code>，non-toll-free计数变体<code>CFBag</code>/<code>CFMutableBag</code>。</p>

<p><code>NSSet</code>会retain它其中的对象，但是根据set的规定，对象应该是不可变的。添加一个对象到set中随后改变它会导致一些奇怪的问题并破坏set的状态。</p>

<p><code>NSSet</code>的方法比<code>NSArray</code>少的多。没有排序方法，但有一些方便的枚举方法。重要的方法有<code>allObjects</code>，将对象转化为<code>NSArray</code>，<code>anyObject</code>则返回任意的对象，如果set为空，则返回nil。</p>

<h2>Set操作</h2>

<p><code>NSMutableSet</code>有几个很强大的方法，例如<code>intersectSet:</code>，<code>minusSet:</code>和<code>unionSet:</code>。</p>

<p><img src="http://objcio.com/images/posts/2014-01-20-the-foundation-collection-classes-02.png" alt="" /></p>

<h2>应该用setWithCapacity:吗?</h2>

<p>我们再一次测试当创建set时给定容量大小是否会有显著的速度差异:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">Adding</span> <span class="mf">1.000.000</span> <span class="n">elements</span> <span class="n">to</span> <span class="n">NSSet</span><span class="p">.</span> <span class="n">no</span> <span class="n">count</span> <span class="mf">2928.49</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span> <span class="n">with</span> <span class="nl">count:</span> <span class="mf">2947.52</span><span class="p">[</span><span class="n">ms</span><span class="p">].</span>
</span></code></pre></td></tr></table></div></figure>


<p>在统计不确定性的前提下，结果没有显著差异。有一份证据表明<a href="http://www.cocoawithlove.com/2008/08/nsarray-or-nsset-nsdictionary-or.html">至少在上一运行时版本中，有很多的性能上的影响</a>。</p>

<h2>NSSet性能特征</h2>

<p>苹果在<a href="http://www.opensource.apple.com/source/CF/CF-855.11/CFSet.h">CFSet头文件</a>中没有提供任何关于算法复杂度的注释:</p>

<!--
Class / Time [ms]               | 1.000.000 elements
:------------------------------ | -----------------:
`NSMutableSet`, adding          |            2504.38
`NSMutableArray`, adding        |            1413.38
`NSMutableSet`, random access   |               4.40
`NSMutableArray`, random access |               7.95
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding          </td>
<td align="right">            2504.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">            1413.38 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access   </td>
<td align="right">               4.40 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">               7.95 </td>
</tr>
</tbody>
</table>


<p>这个检测非常符合我们的预期:<code>NSSet</code>在每一个被添加的对象上执行<code>hash</code>和<code>isEqual:</code>方法并管理一个哈希筐，所以在添加元素时耗费了更多的时间。set的随机访问比较难以测试，因为这里执行的都是<code>anyObject</code>。</p>

<p>这里没有必要包含<code>containsObject:</code>的测试，set要快几个数量级，毕竟这是它的特点。</p>

<h2>NSOrderedSet</h2>

<p><code>NSOrderedSet</code>在iOS 5和Mac OS X 10.7中第一次被引入，除了CoreData，几乎没有直接使用它的API。看上去它综合了<code>NSArray</code>和<code>NSSet</code>两者的好处，对象查找，对象唯一性，和快速随机访问。</p>

<p><code>NSOrderedSet</code>有着优秀的API方法，使得它可以很便利的与其他set或者有序set对象合作。合并，交集，差集，就像<code>NSSet</code>支持的那样。它有<code>NSArray</code>中的大多数排序方法，除了比较陈旧的基于函数的排序方法和二分查找。毕竟<code>containsObject:</code>非常快，所以没有必要再用二分查找了。</p>

<p><code>array</code>和<code>set</code>方法分别返回一个<code>NSArray</code>和<code>NSSet</code>，但是。这些对象表面上是对象，像不可变对象那样，在有序set被更新的时候，它们会更新自己。当你打算在多个线程上迭代这些对象并发生了突变异常的时候，了解这一点是有好处的。本质上，这些类使用的是<code>__NSOrderedSetSetProxy</code>和<code>__NSOrderedSetArrayProxy</code>。</p>

<p>附注:如果你想知道为什么<code>NSOrderedSet</code>不是<code>NSSet</code>的子类，<a href="http://nshipster.com/nsorderedset/">NSHipster上有一篇非常好的文章解释了可变/不可变类簇的缺点</a>。</p>

<h2>NSOrderedSet性能特征</h2>

<p>如果你看到这份测试，你会看到<code>NSOrderedSet</code>代价高昂，天下没有免费的午餐:</p>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMutableOrderedSet`, adding        |            3190.52
`NSMutableSet`, adding               |            2511.96
`NSMutableArray`, adding             |            1423.26
`NSMutableOrderedSet`, random access |              10.74
`NSMutableSet`, random access        |               4.47
`NSMutableArray`, random access      |               8.08
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, adding        </td>
<td align="right">            3190.52 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding               </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding             </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableOrderedSet</code>, random access </td>
<td align="right">              10.74 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access        </td>
<td align="right">               4.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access      </td>
<td align="right">               8.08 </td>
</tr>
</tbody>
</table>


<p>这个测试在每一个集合类中添加自定义字符串，随后随机访问它们。</p>

<p><code>NSOrderedSet</code>比<code>NSSet</code>和<code>NSArray</code>占用更多的内存，因为它需要一起维护哈希值和索引。</p>

<h2>NSHashTable</h2>

<p><code>NSHashTable</code>效仿了<code>NSSet</code>，但在对象/内存处理时更加的灵活。可以通过自定义<code>CFSet</code>的回调获得<code>NSHashTable</code>的一些特性，哈希表可以保持对对象的弱引用并在对象被销毁之后正确的将其移除 &mdash; 一些手动添加到<code>NSSet</code>的时候非常恶心的事情。它是默认可变的 &mdash; 没有相应的不可变类。</p>

<p><code>NSHashTable</code>有ObjC和原始的C API，C API可以用来存储任意对象。苹果在10.5 Leopard系统中引入了这个类，但是直到最近的iOS 6中才被加入。足够有趣的是它们只移植了 ObjC API;更多强大的C API没有包括在iOS中。</p>

<p><code>NSHashTable</code>可以通过<code>initWithPointerFunctions:capacity:</code>进行大量的设置 &mdash; 我们只选取使用<code>hashTableWithOptions:</code>最普遍的使用场景。最有用的选项有它自己的方便的构造函数<code>weakObjectsHashTable</code>。</p>

<h2>NSPointerFunctions</h2>

<p>这些指针函数可以被用在<code>NSHashTable</code>，<code>NSMapTable</code>和<code>NSPointerArray</code>中，定义了对存储在这个集合中的对象的获取和保留行为。这里是最有用的选项。完整列表参见<code>NSPointerFunctions.h</code>。</p>

<p>有两组选项。内存选项决定了内存管理，个性化定义了哈希和相等。</p>

<p><code>NSPointerFunctionsStrongMemory</code>创建了一个retain/release对象的集合，非常像常规的<code>NSSet</code>或<code>NSArray</code>。</p>

<p><code>NSPointerFunctionsWeakMemory</code>使用等价的<code>__weak</code>来存储对象并自动移除被销毁的对象。</p>

<p><code>NSPointerFunctionsCopyIn</code>在对象被加入到集合前拷贝它们。</p>

<p><code>NSPointerFunctionsObjectPersonality</code>使用对象的<code>hash</code>和<code>isEqual:</code>(默认)。</p>

<p><code>NSPointerFunctionsObjectPointerPersonality</code>对于<code>isEqual:</code>和<code>hash</code>使用直接的指针比较。</p>

<h2>NSHashTable性能特征</h2>

<!--
Class / Time [ms]                 | 1.000.000 elements
:-------------------------------- | -----------------:
`NSHashTable`, adding             |            2511.96
`NSMutableSet`, adding            |            1423.26
`NSHashTable`, random access      |               3.13
`NSMutableSet`, random access     |               4.39
`NSHashTable`, containsObject     |               6.56
`NSMutableSet`, containsObject    |               6.77
`NSHashTable`, NSFastEnumeration  |              39.03
`NSMutableSet`, NSFastEnumeration |              30.43
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                 </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSHashTable</code>, adding             </td>
<td align="right">            2511.96 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, adding            </td>
<td align="right">            1423.26 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, random access      </td>
<td align="right">               3.13 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, random access     </td>
<td align="right">               4.39 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, containsObject     </td>
<td align="right">               6.56 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, containsObject    </td>
<td align="right">               6.77 </td>
</tr>
<tr>
<td align="left"> <code>NSHashTable</code>, NSFastEnumeration  </td>
<td align="right">              39.03 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableSet</code>, NSFastEnumeration </td>
<td align="right">              30.43 </td>
</tr>
</tbody>
</table>


<p>如果你只是需要<code>NSSet</code>的特性，请坚持使用<code>NSSet</code>。<code>NSHashTable</code>在添加对象时花费了将近2倍的时间，但是其他方面的效率却非常相近。</p>

<h2>NSMapTable</h2>

<p><code>NSMapTable</code>和<code>NSHashTable</code>相似，但是效仿的是<code>NSDictionary</code>。因此，我们可以通过<code>mapTableWithKeyOptions:valueOptions:</code>分别控制键和值的对象获取/保留行为。存储弱引用是<code>NSMapTable</code>最有用的特性，这里有4个方便的构造函数:</p>

<ul>
<li><code>strongToStrongObjectsMapTable</code></li>
<li><code>weakToStrongObjectsMapTable</code></li>
<li><code>strongToWeakObjectsMapTable</code></li>
<li><code>weakToWeakObjectsMapTable</code></li>
</ul>


<p>注意，除了使用<code>NSPointerFunctionsCopyIn</code>，任何的默认行为都会retain(或弱引用)键对象而不会拷贝它，与<code>CFDictionary</code>的行为相同而与<code>NSDictionary</code>不同。当你需要一个字典，它的键没有实现<code>NSCopying</code>协议，比如<code>UIView</code>，的时候非常有用。</p>

<p>如果你好奇为什么苹果&#8221;忘记&#8221;为<code>NSMapTable</code>增加下标，你现在知道了。下标访问需要一个<code>id&lt;NSCopying&gt;</code>作为key，对<code>NSMapTable</code>来说这不是强制的。如果不通过一个非法的API协议或者移除<code>NSCopying</code>协议来削弱全局下标，是没有办法给它增加下标的。</p>

<p>你可以通过<code>dictionaryRepresentation</code>把内容转换为普通的<code>NSDictionary</code>。不像<code>NSOrderedSet</code>，这个方法返回一个常规的字典而不是一个代理。</p>

<h2>NSMapTable性能特征</h2>

<!--
Class / Time [ms]                    | 1.000.000 elements
:----------------------------------- | -----------------:
`NSMapTable`, adding                 |            2958.48
`NSMutableDictionary`, adding        |            2522.47
`NSMapTable`, random access          |              13.25
`NSMutableDictionary`, random access |               9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                    </th>
<th align="right"> 1.000.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMapTable</code>, adding                 </td>
<td align="right">            2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding        </td>
<td align="right">            2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMapTable</code>, random access          </td>
<td align="right">              13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access </td>
<td align="right">               9.18 </td>
</tr>
</tbody>
</table>


<p><code>NSMapTable</code>只比<code>NSDictionary</code>略微慢一点。如果你需要一个不retain键的字典，放弃<code>CFDictionary</code>使用它吧。</p>

<h2>NSPointerArray</h2>

<p><code>NSPointerArray</code>类是一个稀疏数组，工作起来与<code>NSMutableArray</code>相似，但可以存储<code>NULL</code>值，并且<code>count</code>方法会反应这些空点。可以用<code>NSPointerFunctions</code>对其进行各种设置，也有应对常见的使用场景的快捷构造函数<code>strongObjectsPointerArray</code>和<code>weakObjectsPointerArray</code>。</p>

<p>在能使用<code>insertPointer:atIndex:</code>之前，我们需要通过直接设置<code>count</code>属性来申请空间，否则会产生一个异常。另一种选择是使用<code>addPointer:</code>，这个方法可以自动根据需要增加数组的大小。</p>

<p>你可以通过<code>allObjects</code>将一个<code>NSPointerArray</code>转换成常规的<code>NSArray</code>。这时所有的<code>NULL</code>值会被去掉，只有真正存在的对象被加入到数组 &mdash; 因此数组的对象索引很有可能会跟指针数组的不同。注意:如果向指针数组中存入任何非对象的东西，试图执行<code>allObjects</code>都会造成<code>EXC_BAD_ACCESS</code>崩溃，因为它会一个一个的retain&#8221;对象&#8221;。</p>

<p>从调试的角度讲，<code>NSPointerArray</code>没有受到太多欢迎。<code>description</code>方法只是简单的返回了<code>&lt;NSConcretePointerArray: 0x17015ac50&gt;</code>。为了得到所有的对象需要执行<code>[pointerArray allObjects]</code>，当然，如果存在<code>NULL</code>的话会改变索引。</p>

<h2>NSPointerArray性能特征</h2>

<p>在性能方面，<code>NSPointerArray</code>真的非常非常慢，所以当你打算在一个很大的数据集合上使用它的时候一定要三思。在本测试中我们比较了使用<code>NSNull</code>作为空标记的<code>NSMutableArray</code>和使用了<code>NSPointerFunctionsStrongMemory</code>设置的<code>NSPointerArray</code>(这样对象会被适当的retain)。在一个有10,000个元素的数组中，我们每隔十个插入一个字符串&#8221;Entry %d&#8221;。此测试包括了用<code>NSNull</code>作为<code>null</code>填充的<code>NSMutableArray</code>。对于<code>NSPointerArray</code>，我们使用<code>setCount:</code>来代替:</p>

<!--
Class / Time [ms]               | 10.000 elements
:------------------------------ | --------------:
`NSMutableArray`, adding        |         2958.48
`NSPointerArray`, adding        |         2522.47
`NSMutableArray`, random access |           13.25
`NSPointerArray`, random access |            9.18
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]               </th>
<th align="right"> 10.000 elements </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableArray</code>, adding        </td>
<td align="right">         2958.48 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, adding        </td>
<td align="right">         2522.47 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableArray</code>, random access </td>
<td align="right">           13.25 </td>
</tr>
<tr>
<td align="left"> <code>NSPointerArray</code>, random access </td>
<td align="right">            9.18 </td>
</tr>
</tbody>
</table>


<p>注意<code>NSPointerArray</code>需要的时间比<code>NSMutableArray</code>多了超过<strong>250x (!) </strong>。这非常奇怪和意外。跟踪内存比较困难，似乎<code>NSPointerArray</code>更高效，但是因为我们使用同一个<code>NSNull</code>标记空对象，所以除了指针不该有更多的消耗。</p>

<h2>NSCache</h2>

<p><code>NSCache</code>是一个非常奇怪的集合。在iOS 4/Snow Leopard中加入，默认为可变并且<strong>线程安全</strong>的。这使它很适合缓存那些创建起来代价高昂的对象。它自动对内存警告做出反应并基于可设置的&#8221;成本&#8221;清理自己。与<code>NSDictionary</code>相比，键是被retain而不是被拷贝的。</p>

<p><code>NSCache</code>的回收方法是不确定的，在文档中也没有说明。向里面放一些类似图片那样比被回收更快填满内存的大对象不是个好主意。(这是在<a href="http://pspdfkit.com/">PSPDFKit</a>中很多跟内存有关的crash的原因，在使用自定义的基于LRU的链表的缓存代码之前，我们起初使用<code>NSCache</code>存储事先渲染的图片。)</p>

<p><code>NSCache</code>可以设置撑自动回收实现了<code>NSDiscardableContent</code>协议的对象。实现该属性的一个比较流行的类是同时间加入的<code>NSPurgeableData</code>，但是<a href="https://developer.apple.com/library/mac/releasenotes/Foundation/RN-Foundation/index.html#//apple_ref/doc/uid/TP30000742">在OS X 10.9之前，是非线程安全的(没有信息表明这是否也影响到iOS或者是否在iOS 7中被修复了)</a>。</p>

<h2>NSCache性能</h2>

<p>那么<code>NSCache</code>如何承受<code>NSMutableDictionary</code>的考验?加入的线程安全必然会带来一些消耗。处于好奇，我也加入了一个自定义的线程安全的字典的子类(<a href="https://gist.github.com/steipete/5928916">PSPDFThreadSafeMutableDictionary</a>)，它通过<code>OSSpinLock</code>实现同步的访问。</p>

<!--
Class / Time [ms]                                 | 1.000.000 elements | iOS 7x64 Simulator | iPad Mini iOS 6
:------------------------------------------------ | -----------------: | -----------------: | --------------:
`NSMutableDictionary`, adding                     |             195.35 |              51.90 |          921.02
`PSPDFThreadSafeMutableDictionary`, adding        |             248.95 |              57.03 |         1043.79
`NSCache`, adding                                 |             557.68 |             395.92 |         1754.59
`NSMutableDictionary`, random access              |               6.82 |               2.31 |           23.70
`PSPDFThreadSafeMutableDictionary`, random access |               9.09 |               2.80 |           32.33
`NSCache`, random access                          |               9.01 |          **29.06** |           53.25
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]                                 </th>
<th align="right"> 1.000.000 elements </th>
<th align="right"> iOS 7x64 Simulator </th>
<th align="right"> iPad Mini iOS 6 </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, adding                     </td>
<td align="right">             195.35 </td>
<td align="right">              51.90 </td>
<td align="right">          921.02 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, adding        </td>
<td align="right">             248.95 </td>
<td align="right">              57.03 </td>
<td align="right">         1043.79 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, adding                                 </td>
<td align="right">             557.68 </td>
<td align="right">             395.92 </td>
<td align="right">         1754.59 </td>
</tr>
<tr>
<td align="left"> <code>NSMutableDictionary</code>, random access              </td>
<td align="right">               6.82 </td>
<td align="right">               2.31 </td>
<td align="right">           23.70 </td>
</tr>
<tr>
<td align="left"> <code>PSPDFThreadSafeMutableDictionary</code>, random access </td>
<td align="right">               9.09 </td>
<td align="right">               2.80 </td>
<td align="right">           32.33 </td>
</tr>
<tr>
<td align="left"> <code>NSCache</code>, random access                          </td>
<td align="right">               9.01 </td>
<td align="right">          <strong>29.06</strong> </td>
<td align="right">           53.25 </td>
</tr>
</tbody>
</table>


<p><code>NSCache</code>表现的相当好，随机访问跟我们自定义的线程安全字典一样快。如我们预料的，添加更慢一些，因为<code>NSCache</code>维持着一个可选的决定何时回收对象的成本系数。就这一点来看这不是一个非常公平的比较。有趣的是，在模拟器上运行效率要慢了几乎10倍。无论对32或64位的系统都是。而且看起来已经在iOS 7中优化过并且受益于64位运行时环境。当在老的设备上测试时，使用<code>NSCache</code>的性能消耗尤为明显。</p>

<p>iOS 6(32 bit)和iOS 7(64 bit)的区别也很明显，因为64位运行时使用<a href="http://www.mikeash.com/pyblog/friday-qa-2012-07-27-lets-build-tagged-pointers.html">标签指针</a>，因此我们的<code>@(idx)</code>封装要更为高效。</p>

<h2>NSIndexSet</h2>

<p>有些使用场景下<code>NSIndexSet</code>(和它的可变变体，<code>NSMutableIndexSet</code>)真的非常出色，对它的使用贯穿在Foundation中。它可以用一种非常高效的方法存储一组无符号整数的集合，尤其是如果只是一个或少量范围的时候。正如set这个名字已经暗示的那样，每一个<code>NSUInteger</code>要么在索引set中要么不在。如果你需要存储任意唯一的整数，最好使用<code>NSArray</code>。</p>

<p>如何把一个整数数组转换伟<code>NSIndexSet</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSIndexSet</span> <span class="o">*</span><span class="nf">PSPDFIndexSetFromArray</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSMutableIndexSet</span> <span class="o">*</span><span class="n">indexSet</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableIndexSet</span> <span class="n">indexSet</span><span class="p">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">number</span> <span class="k">in</span> <span class="n">array</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="n">indexSet</span> <span class="nl">addIndex:</span><span class="p">[</span><span class="n">number</span> <span class="n">unsignedIntegerValue</span><span class="p">]];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">indexSet</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果不使用block，从索引set中拿到所有的索引有点麻烦，<code>getIndexes:maxCount:inIndexRange:</code>是最快的方法，其次是使用<code>firstIndex</code>并迭代直到<code>indexGreaterThanIndex:</code>返回<code>NSNotFound</code>。随着block的到来，使用<code>NSIndexSet</code>工作变得方便的多:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">NSArray</span> <span class="o">*</span><span class="nf">PSPDFArrayFromIndexSet</span><span class="p">(</span><span class="n">NSIndexSet</span> <span class="o">*</span><span class="n">indexSet</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">indexesArray</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="nl">arrayWithCapacity:</span><span class="n">indexSet</span><span class="p">.</span><span class="n">count</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">indexSet</span> <span class="nl">enumerateIndexesUsingBlock:</span><span class="o">^</span><span class="p">(</span><span class="n">NSUInteger</span> <span class="n">idx</span><span class="p">,</span> <span class="kt">BOOL</span> <span class="o">*</span><span class="n">stop</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="p">[</span><span class="n">indexesArray</span> <span class="nl">addObject:</span><span class="err">@</span><span class="p">(</span><span class="n">idx</span><span class="p">)];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">indexesArray</span> <span class="n">copy</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>NSIndexSet性能</h2>

<p>Core Foundation中没有和<code>NSIndexSet</code>相当的类，苹果也没有对性能做出任何承诺。<code>NSIndexSet</code>和<code>NSSet</code>之间的比较也相对的不公平，因为常规的set需要对数字进行包装。为了缓解这个影响，这里的测试准备了实现包装好的<code>NSUintegers</code>，并且在两个循环中都会执行<code>unsignedIntegerValue</code>:</p>

<!--
Class / Time [ms]           | #1.000 | #10.000 | #1.000.000 | #10.000.000 | #1.000.000, iPad Mini
:-------------------------- | -----: | ------: | ---------: | ----------: | --------------------:
`NSIndexSet`, adding        |   0.28 |    4.58 |      98.60 |     9396.72 |                179.27
`NSSet`, adding             |   0.30 |    2.60 |       8.03 |       91.93 |                 37.43
`NSIndexSet`, random access |   0.10 |    1.00 |       3.51 |       58.67 |                 13.44
`NSSet`, random access      |   0.17 |    1.32 |       3.56 |       34.42 |                 18.60
-->




<table class="data-table">
<thead>
<tr>
<th align="left"> Class / Time [ms]           </th>
<th align="right"> #1.000 </th>
<th align="right"> #10.000 </th>
<th align="right"> #1.000.000 </th>
<th align="right"> #10.000.000 </th>
<th align="right"> #1.000.000, iPad Mini </th>
</tr>
</thead>
<tbody>
<tr>
<td align="left"> <code>NSIndexSet</code>, adding        </td>
<td align="right">   0.28 </td>
<td align="right">    4.58 </td>
<td align="right">      98.60 </td>
<td align="right">     9396.72 </td>
<td align="right">                179.27 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, adding             </td>
<td align="right">   0.30 </td>
<td align="right">    2.60 </td>
<td align="right">       8.03 </td>
<td align="right">       91.93 </td>
<td align="right">                 37.43 </td>
</tr>
<tr>
<td align="left"> <code>NSIndexSet</code>, random access </td>
<td align="right">   0.10 </td>
<td align="right">    1.00 </td>
<td align="right">       3.51 </td>
<td align="right">       58.67 </td>
<td align="right">                 13.44 </td>
</tr>
<tr>
<td align="left"> <code>NSSet</code>, random access      </td>
<td align="right">   0.17 </td>
<td align="right">    1.32 </td>
<td align="right">       3.56 </td>
<td align="right">       34.42 </td>
<td align="right">                 18.60 </td>
</tr>
</tbody>
</table>


<p>我们看到在一百万左右对象的时候，<code>NSIndexSet</code>开始变得比<code>NSSet</code>慢，但只是因为新的运行时和标签指针。在iOS 6上运行相同的测试表明，甚至在更高数量级实体的条件下，<code>NSIndexSet</code>更快。实际上，在大多数应用中，你不会添加太多的整数到索引set中。还有一点这里没有测试，就是<code>NSIndexSet</code>跟<code>NSSet</code>比无疑有更好的内存优化。</p>

<h2>结论</h2>

<p>本文提供了一些真实的测试，使你在使用基础集合类的时候做出有根据的选择。除了上面讨论的类，还有一些不常用但是有用的类，尤其是<code>NSCountedSet</code>，<a href="http://nshipster.com/cfbag/">CFBag</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFTreeRef/Reference/reference.html">CFTree</a>，<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBitVectorRef/Reference/reference.html">CFBitVector</a>和<a href="https://developer.apple.com/library/mac/documentation/corefoundation/Reference/CFBinaryHeapRef/Reference/reference.html">CFBinaryHeap</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Frame]]></title>
    <link href="http://objcio.com/blog/2013/12/04/understanding-frame/"/>
    <updated>2013-12-04T13:36:00+08:00</updated>
    <id>http://objcio.com/blog/2013/12/04/understanding-frame</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://macoscope.com/blog/understanding-frame/">Understanding Frame</a>，转载请注明出处。</p>

<p>Frame是布局的核心。每个开发者都使用frame定位和改变<code>UIView</code>和<code>CALayer</code>的大小。在本文中我将把焦点集中在<code>CALayer</code>上，因为它是<code>UIView</code>的底层实现，<code>view.frame</code>简单的返回了<code>view.layer.frame</code>。此外，我不会讨论<code>setFrame:</code>方法。虽然看起来范围十分有限，但实际上有许多有趣的事情在平凡又古老的<code>frame</code> getter方法中发生。</p>

<!--more-->


<h2>Frame依赖于什么</h2>

<p>众所周知，<code>frame</code>是一个派生属性，实际上它基于一些其他的属性。实际上在计算frame值的时候会参考4个(!)属性:<code>bounds</code>，<code>anchorPoint</code>，<code>transform</code>，和<code>position</code>。</p>

<p>我们从<code>bounds</code>开始。bounds很棘手，它混合了层的内部和外部。<code>bounds.size</code>定义了层本身的面积，声明了它所存在的区域。设置<code>masksToBounds</code>为<code>YES</code>会把所有子层超出bounds范围的部分裁掉。另一方面，<code>bounds</code>的<code>origin</code>属性并不影响层本身的布局；然而它会影响它内部的子层的布局方式。<code>bounds.origin</code>定义了层内部坐标系的原点。</p>

<p>这里有一个例子展示了<code>bounds.origin</code>如何工作。例如我们定义<code>bounds.origin</code>为<code>CGPointMake (20.0f, 30.0f)</code></p>

<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-01.png" title="bounds.origin" alt="bounds.origin" /></p>

<p>如何定义本地坐标系？只要把层的左上角放到<code>bounds.origin</code>上就行了。</p>

<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-02.png" title="bounds.origin" alt="bounds.origin" /></p>

<p><code>anchorPoint</code>是一个稍微有点不同的讨厌鬼。首先，它的值标准化为0.0-1.0的范围内。获得以&#8221;点&#8221;为单位的值需要用<code>bounds.size</code>乘以标准化的值。更重要的是，<code>anchorPoint</code>定义了应用变换的坐标系的原点。</p>

<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-03.png" title="anchorPoint" alt="anchorPoint" /></p>

<p>变换具有相同<code>bounds</code>但有不同<code>anchorPoint</code>的层(蓝色)会有很大区别(灰色)。</p>

<p><code>position</code>是最简单的一个概念。它定义了经过<code>bounds.size</code>，<code>anchorPoint</code>和<code>transform</code>的混合后，添加到层中的最终位置。</p>

<h2>精度的快速讨论</h2>

<p>在写这篇博客的时候，我留意到有时我的计算结果和CoreAnimation返回的计算结果相比有所出入。有可能是我计算错误或者有精度问题。我理所当然的首先检查了精度问题。幸运的是我的直觉是正确的。<code>CGFloat</code>在32位架构上是一个<code>float</code>的类型定义(在64位架构上是<code>double</code>)，而似乎CoreAnimation并没有理会<code>CGFloat</code>的实际类型而在内部直接使用了<code>double</code>。</p>

<p>要证实这个猜测并不困难。使用<a href="http://www.hopperapp.com/">Hooper</a>工具检查<code>CALayer</code>的<code>frame</code>getter方法的执行内容，我发现了一个叫做<code>mat4_apply_to_rect</code>的函数。然后我在这里设置了一个符号断点，实际上也就是在<code>CA::Mat4Impl::mat4_apply_to_rect(double const*, double*)</code>和<code>CA::Mat4Impl::mat4_apply_to_rect(float const*, float*)</code>上分别设置了一个断点，以确定哪一个函数被执行。当在设备上运行代码的时候，断点停在了参数是<code>double</code>的函数中，即使使用的是32位ARM架构的iPhone。</p>

<p>在一些极端情况下，使用<code>float</code>和<code>double</code>的差异是显而易见的。然而因为我们的目标是对CoreAnimation进行逆向工程并得到完全相同的结果，所以我们也使用<code>double</code>。我们定义一些和CoreGraphics中相同的非常简单的结构体。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">MCSDoublePoint</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">MCSDoublePoint</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">MCSDoubleSize</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">MCSDoubleSize</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">typedef</span> <span class="k">struct</span> <span class="n">MCSDoubleRect</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">MCSDoublePoint</span> <span class="n">origin</span><span class="p">;</span>
</span><span class='line'>  <span class="n">MCSDoubleSize</span> <span class="n">size</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span> <span class="n">MCSDoubleRect</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>值得注意的是在64位iOS设备上，我们精心构建的<code>struct</code>会变得多余，因为在该架构上，<code>CGPoint</code>，<code>CGSize</code>和<code>CGRect</code>本来就是用<code>doubles</code>的。</p>

<h2>变换</h2>

<p>在深入分析frame之前，我们先了解一下变换。虽然<code>CALayer</code>使用的是一个完整的4×4的矩阵模拟<code>CATransform3D</code>，但它对计算<code>frame</code>的目的真的没有影响。所以，我们把焦点集中在<code>CGAffineTransform</code>上，它可以用每个人都喜欢的<code>CATransform3DGetAffineTransform</code>方法从<code>CATransform3D</code>中简单获得。</p>

<p>让我们从点开始，使用仿射变换来变换点是入门级的袋鼠:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MCSDoublePoint</span> <span class="nf">MCSDoublePointApplyTransform</span><span class="p">(</span><span class="n">MCSDoublePoint</span> <span class="n">point</span><span class="p">,</span> <span class="n">CGAffineTransform</span> <span class="n">t</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">MCSDoublePoint</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'>  <span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">a</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">t</span><span class="p">.</span><span class="n">tx</span><span class="p">;</span>
</span><span class='line'>  <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">b</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">t</span><span class="p">.</span><span class="n">d</span> <span class="o">*</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">t</span><span class="p">.</span><span class="n">ty</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码实现基于<code>CGPointApplyAffineTransform</code>，从根本上来讲是一个3x3的变换矩阵乘一个三维向量。</p>

<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-04.gif" title="equation" alt="equation" /></p>

<p>这个矩阵被<code>CGAffineTransform</code>的值填充，被乘的向量由点的x坐标，y坐标和<code>1.0</code>组成，让结果向量从矩阵中也得到转换过的元素。</p>

<p>通过点变换，我们很容易变换矩形。通过变换矩形的顶点并用直线连接它们创建一个平行四边形(通常可以是任意四边形)。
但这并不是<code>CGRectApplyAffineTransform</code>的如何工作的。这个函数接收一个<code>CGRect</code>参数并返回一个<code>CGRect</code>。正如头文件<code>CGAffineTransform.h</code>中的注释声明的:</p>

<blockquote><p>通常来说因为仿射变换并不保护矩形，这个函数返回一个最小的包括经过变换的<code>rect</code>的四个顶点的矩形。</p></blockquote>

<p>读过这个以后，使用double再现<code>CGRectApplyAffineTransform</code>变得相对直接:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">MCSDoubleRect</span> <span class="nf">MCSDoubleRectApplyTransform</span><span class="p">(</span><span class="n">MCSDoubleRect</span> <span class="n">rect</span><span class="p">,</span> <span class="n">CGAffineTransform</span> <span class="n">transform</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">xMin</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">xMax</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">yMin</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">yMax</span> <span class="o">=</span> <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">MCSDoublePoint</span> <span class="n">points</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCSDoublePointApplyTransform</span><span class="p">((</span><span class="n">MCSDoublePoint</span><span class="p">){</span><span class="n">xMin</span><span class="p">,</span> <span class="n">yMin</span><span class="p">},</span> <span class="n">transform</span><span class="p">),</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCSDoublePointApplyTransform</span><span class="p">((</span><span class="n">MCSDoublePoint</span><span class="p">){</span><span class="n">xMin</span><span class="p">,</span> <span class="n">yMax</span><span class="p">},</span> <span class="n">transform</span><span class="p">),</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCSDoublePointApplyTransform</span><span class="p">((</span><span class="n">MCSDoublePoint</span><span class="p">){</span><span class="n">xMax</span><span class="p">,</span> <span class="n">yMin</span><span class="p">},</span> <span class="n">transform</span><span class="p">),</span>
</span><span class='line'>    <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">MCSDoublePointApplyTransform</span><span class="p">((</span><span class="n">MCSDoublePoint</span><span class="p">){</span><span class="n">xMax</span><span class="p">,</span> <span class="n">yMax</span><span class="p">},</span> <span class="n">transform</span><span class="p">),</span>
</span><span class='line'>  <span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="kt">double</span> <span class="n">newXMin</span> <span class="o">=</span>  <span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">newXMax</span> <span class="o">=</span> <span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">newYMin</span> <span class="o">=</span>  <span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">double</span> <span class="n">newYMax</span> <span class="o">=</span> <span class="o">-</span><span class="n">INFINITY</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">newXMax</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">newXMax</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>    <span class="n">newYMax</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">newYMax</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="n">newXMin</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">newXMin</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span><span class="p">);</span>
</span><span class='line'>    <span class="n">newYMin</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">newYMin</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">MCSDoubleRect</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="n">newXMin</span><span class="p">,</span> <span class="n">newYMin</span><span class="p">,</span> <span class="n">newXMax</span> <span class="o">-</span> <span class="n">newXMin</span><span class="p">,</span> <span class="n">newYMax</span> <span class="o">-</span> <span class="n">newYMin</span><span class="p">};</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们计算了四个顶点的坐标，变换它们并且得到<code>x</code>和<code>y</code>的极值。</p>

<h2>计算Frame</h2>

<p>我们通过努力了解了每一个影响frame的因素，现在，获得frame将会变得很有趣:</p>

<ul>
<li>定义一个面积为<code>bounds.size</code>的矩形</li>
</ul>


<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-05.png" alt="" /></p>

<ul>
<li>计算该矩形内的<code>anchorPoint</code>位置</li>
</ul>


<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-06.png" alt="" /></p>

<ul>
<li>将矩形放入坐标系内，<code>anchorPoint</code>作为坐标系的原点</li>
</ul>


<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-07.png" alt="" /></p>

<ul>
<li>应用任何你实施的变换，保持一个&#8221;包含了经过转换的顶点的最小矩形&#8221;</li>
</ul>


<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-08.png" alt="" /></p>

<ul>
<li>根据<code>position</code>移动<code>anchorPoint</code></li>
</ul>


<p><img src="http://objcio.com/images/posts/2013-12-04-understanding-frame-09.png" alt="" /></p>

<ul>
<li>灰色的就是结果矩形</li>
</ul>


<p>实现这些操作的代码如下:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nf">frameWithBounds:</span><span class="p">(</span><span class="n">CGRect</span><span class="p">)</span><span class="nv">bounds</span> <span class="nf">anchorPoint:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">anchorPoint</span> <span class="nf">transform:</span><span class="p">(</span><span class="n">CATransform3D</span><span class="p">)</span><span class="nv">transform</span> <span class="nf">position:</span><span class="p">(</span><span class="n">CGPoint</span><span class="p">)</span><span class="nv">position</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">MCSDoubleRect</span> <span class="n">rect</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">;</span>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">-</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">*</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="o">-</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">*</span> <span class="n">anchorPoint</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">rect</span> <span class="o">=</span> <span class="n">MCSDoubleRectApplyTransform</span><span class="p">(</span><span class="n">rect</span><span class="p">,</span> <span class="n">CATransform3DGetAffineTransform</span><span class="p">(</span><span class="n">transform</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
</span><span class='line'>  <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rect</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然代码不多，但利用了我们讨论过的所有概念。</p>

<h2>这些如何映射到<code>UIView</code></h2>

<p>关于<code>frame</code>getter方法，<code>bounds</code>和<code>center</code>，<code>UIView</code>并没有做什么工作；它只是简单的各自调用它底层的CALayer的<code>frame</code>，<code>bounds</code>和<code>position</code>方法。</p>

<p>注意<code>center</code>到<code>position</code>的映射 &mdash; 改变底层<code>layer</code>的<code>anchorPoint</code>会使<code>center</code>不能正确的对应到层的&#8221;中心&#8221;或者层的边界矩形的&#8221;中点&#8221;。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在iOS中创建静态库]]></title>
    <link href="http://objcio.com/blog/2013/11/30/creating-a-static-library-in-ios-tutorial/"/>
    <updated>2013-11-30T22:45:00+08:00</updated>
    <id>http://objcio.com/blog/2013/11/30/creating-a-static-library-in-ios-tutorial</id>
    <content type="html"><![CDATA[<p>本文由 <a href="http://migrant.github.io/"><strong>Migrant</strong></a> 翻译自 <a href="http://www.raywenderlich.com/41377/creating-a-static-library-in-ios-tutorial">Creating a Static Library in iOS Tutorial</a>，转载请注明出处。</p>

<p><img class="right" src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-00.jpg" title="Create a static library in iOS!" ></p>

<p>如果你作为iOS开发者已经有一段时间，可能会有一套属于自己的类和工具函数，它们在你的大多数项目中被重用。</p>

<p>重用代码的最简单方法是简单的 <em>拷贝/粘贴</em> 源文件。然而，这种方法很快就会成为维护时的噩梦。因为每个应用都有自己的一份代码副本，你很难在修复bug或者升级时保证所有副本的同步。</p>

<p>这就是静态库要拯救你的。一个静态库是若干个类，函数，定义和资源的包装，你可以将其打包并很容易的在项目之间共享。</p>

<p>在本教程中，你将用两种方法亲手创建你自己的通用静态库。</p>

<!--more-->


<p>为了获得最佳效果，你应该熟悉Objective-C和iOS编程。Core Image的相关知识并不是必须的，但是如果你对示例工程和滤镜代码如何工作感兴趣，了解它会有所帮助。</p>

<p>准备好以效率的名义减少，重用并再生你的代码!</p>

<h2>为什么使用静态库</h2>

<p>创建静态库可能出于以下几个理由:</p>

<ul>
<li>你想将一些你和你团队中的同事们经常使用的类打包并轻松的分享给周围其他人。</li>
<li>你想让一些通用代码处于自己的掌控之下，以便于修复和升级。</li>
<li>你想将库共享给其他人，但不想让他们看到你的源代码。</li>
<li>你想创建一个还在不断开发的库的快照版本。</li>
</ul>


<p>本教程假设你已经完成学习<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>，并对其中展示如何应用图片特效的代码得心应手。</p>

<p>将上述代码添加到一个静态库中，然后在一个应用的修改版本中使用这个静态库。我们会得到一个带有上面列表中全部好处的完全相同的应用。</p>

<h2>开始</h2>

<p>运行Xcode，选择<code>File\New\Project</code>，在<code>Choose a template</code> 对话框中选择<code>iOS\Framework &amp; Library\Cocoa Touch Static Library</code>,如下图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-01.png" title="New Lib" alt="New Lib" /></p>

<p>点击<code>Next</code>。在工程选项对话框中，输入<code>ImageFilters</code>作为产品名。再输入一个唯一的公司标识，确保<code>Use Automatic Reference Counting</code>被选中且<code>Include Unit Tests</code>未选中。如下图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-02.png" title="Lib Name" alt="Lib Name" /></p>

<p>点击<code>Next</code>。最后，选择你想保存工程的位置并点击<code>Create</code>。</p>

<p>Xcode已经准备好静态库工程，甚至已经为你添加了一个<code>ImageFilters</code>类。这就是你的滤镜代码将要存放的地方。</p>

<blockquote><p>注意: 你可以添加任意数量的类到静态库中或者从中删除原有的类。本教程中的代码都会写在开始就被创建好的<code>ImageFilters</code>类中。</p></blockquote>

<p>你的Xcode工程还是一片空白，现在我们添加一些代码进去!</p>

<h2>图片滤镜</h2>

<p>该库使用UIKit，为iOS设计，所以你要做的第一件事就是在头文件中导入UIKit。打开<code>ImageFilters.h</code>，在文件顶部添加以下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>接下来将以下声明部分的代码粘贴到<code>@interface ImageFilters : NSObject</code>下面</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">readonly</span><span class="p">)</span> <span class="n">UIImage</span> <span class="o">*</span><span class="n">originalImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithImage:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">grayScaleImage</span><span class="p">;</span>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">oldImageWithIntensity:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">level</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些头文件中的声明定义了类的公开接口。其他开发者(包括你自己)使用该库时，只需通过阅读该头文件就可以知道类名和暴露的方法。</p>

<p>现在增加实现。打开<code>ImageFilters.m</code>文件，粘贴以下代码到<code>#import "ImageFilters.h"</code>下面:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">@interface</span> <span class="nc">ImageFilters</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">strong</span><span class="p">)</span> <span class="n">CIContext</span>  <span class="o">*</span><span class="n">context</span><span class="p">;</span>
</span><span class='line'><span class="k">@property</span> <span class="p">(</span><span class="n">nonatomic</span><span class="p">,</span><span class="n">strong</span><span class="p">)</span> <span class="n">CIImage</span>    <span class="o">*</span><span class="n">beginImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码声明了一些内部使用的属性。它们不是公开的，所以使用该库的引用没有使用它们的入口。</p>

<p>最后，你需要实现方法。粘贴以下代码到<code>@implementation ImageFilters:</code>下面:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithImage:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">self</span> <span class="o">=</span> <span class="p">[</span><span class="n">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">_originalImage</span>  <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'>        <span class="n">_context</span>        <span class="o">=</span> <span class="p">[</span><span class="n">CIContext</span> <span class="nl">contextWithOptions:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>        <span class="n">_beginImage</span>     <span class="o">=</span> <span class="p">[[</span><span class="n">CIImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithImage:</span><span class="n">_originalImage</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">self</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span><span class="o">*</span><span class="p">)</span><span class="nf">imageWithCIImage:</span><span class="p">(</span><span class="n">CIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">ciImage</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">CGImageRef</span> <span class="n">cgiImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">context</span> <span class="nl">createCGImage:</span><span class="n">ciImage</span> <span class="nl">fromRect:</span><span class="n">ciImage</span><span class="p">.</span><span class="n">extent</span><span class="p">];</span>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="nl">imageWithCGImage:</span><span class="n">cgiImage</span><span class="p">];</span>
</span><span class='line'>    <span class="n">CGImageRelease</span><span class="p">(</span><span class="n">cgiImage</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">image</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">grayScaleImage</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">originalImage</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIImage</span> <span class="o">*</span><span class="n">grayScaleFilter</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIColorControls&quot;</span> <span class="nl">keysAndValues:</span><span class="n">kCIInputImageKey</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">beginImage</span><span class="p">,</span> <span class="s">@&quot;inputBrightness&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">0.0</span><span class="p">],</span> <span class="s">@&quot;inputContrast&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">1.1</span><span class="p">],</span> <span class="s">@&quot;inputSaturation&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">0.0</span><span class="p">],</span> <span class="nb">nil</span><span class="p">].</span><span class="n">outputImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIImage</span> <span class="o">*</span><span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIExposureAdjust&quot;</span> <span class="nl">keysAndValues:</span><span class="n">kCIInputImageKey</span><span class="p">,</span> <span class="n">grayScaleFilter</span><span class="p">,</span> <span class="s">@&quot;inputEV&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">NSNumber</span> <span class="nl">numberWithFloat:</span><span class="mf">0.7</span><span class="p">],</span> <span class="nb">nil</span><span class="p">].</span><span class="n">outputImage</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">filteredImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">imageWithCIImage:</span><span class="n">output</span><span class="p">];</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">filteredImage</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nf">oldImageWithIntensity:</span><span class="p">(</span><span class="n">CGFloat</span><span class="p">)</span><span class="nv">intensity</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span> <span class="o">!</span><span class="n">self</span><span class="p">.</span><span class="n">originalImage</span> <span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIFilter</span> <span class="o">*</span><span class="n">sepia</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CISepiaTone&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">sepia</span> <span class="nl">setValue:</span><span class="n">self</span><span class="p">.</span><span class="n">beginImage</span> <span class="nl">forKey:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">sepia</span> <span class="nl">setValue:</span><span class="err">@</span><span class="p">(</span><span class="n">intensity</span><span class="p">)</span> <span class="nl">forKey:</span><span class="s">@&quot;inputIntensity&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIFilter</span> <span class="o">*</span><span class="n">random</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIRandomGenerator&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIFilter</span> <span class="o">*</span><span class="n">lighten</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIColorControls&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">lighten</span> <span class="nl">setValue:</span><span class="n">random</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">lighten</span> <span class="nl">setValue:</span><span class="err">@</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">intensity</span><span class="p">)</span> <span class="nl">forKey:</span><span class="s">@&quot;inputBrightness&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">lighten</span> <span class="nl">setValue:</span><span class="err">@</span><span class="mf">0.0</span> <span class="nl">forKey:</span><span class="s">@&quot;inputSaturation&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIImage</span> <span class="o">*</span><span class="n">croppedImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">lighten</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">imageByCroppingToRect:</span><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">beginImage</span> <span class="n">extent</span><span class="p">]];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIFilter</span> <span class="o">*</span><span class="n">composite</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIHardLightBlendMode&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">composite</span> <span class="nl">setValue:</span><span class="n">sepia</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">composite</span> <span class="nl">setValue:</span><span class="n">croppedImage</span> <span class="nl">forKey:</span><span class="n">kCIInputBackgroundImageKey</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">CIFilter</span> <span class="o">*</span><span class="n">vignette</span> <span class="o">=</span> <span class="p">[</span><span class="n">CIFilter</span> <span class="nl">filterWithName:</span><span class="s">@&quot;CIVignette&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">vignette</span> <span class="nl">setValue:</span><span class="n">composite</span><span class="p">.</span><span class="n">outputImage</span> <span class="nl">forKey:</span><span class="n">kCIInputImageKey</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">vignette</span> <span class="nl">setValue:</span><span class="err">@</span><span class="p">(</span><span class="n">intensity</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="nl">forKey:</span><span class="s">@&quot;inputIntensity&quot;</span><span class="p">];</span>
</span><span class='line'>    <span class="p">[</span><span class="n">vignette</span> <span class="nl">setValue:</span><span class="err">@</span><span class="p">(</span><span class="n">intensity</span> <span class="o">*</span> <span class="mi">30</span><span class="p">)</span> <span class="nl">forKey:</span><span class="s">@&quot;inputRadius&quot;</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">UIImage</span> <span class="o">*</span><span class="n">filteredImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">self</span> <span class="nl">imageWithCIImage:</span><span class="n">vignette</span><span class="p">.</span><span class="n">outputImage</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">filteredImage</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码实现了初始化和图片滤镜功能。详细解释上述代码的功能已经超出了本教程的范围，你可以从<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>中了解到更多的关于 Core Image 和滤镜的知识。</p>

<p>到这里，你已经有了一个静态库，它有一个暴露了以下3个方法的公开类<code>ImageFilters</code>:</p>

<ul>
<li><code>initWithImage</code> : 初始化滤镜类</li>
<li><code>grayScaleImage</code> : 创建灰阶图片</li>
<li><code>oldImageWithIntensity</code> : 创建怀旧效果的图片</li>
</ul>


<p>现在构建并运行你的库。你会注意到Xcode的&#8221;Run&#8221;按钮只是执行了一次构建，而并不能真正的运行库去查看效果，因为并没有真正的应用。</p>

<p>静态库的后缀名是<code>.a</code>而并不是一个<code>.app</code>或者<code>.ipa</code>文件。可以在工程导航栏中的<code>Products</code>文件夹下找到生成的静态库。右键点击<code>libImageFilters.a</code>并在弹出菜单中选择<code>Show in Finder</code>。</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-03.png" title="Show in Finder" alt="Show in Finder" /></p>

<p>Xcode会在Finder中打开文件夹，你可以看到以下类似的结构:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-04.png" title="Lib Structure" alt="Lib Structure" /></p>

<p>离完成一个库产品还剩两件事:</p>

<ul>
<li><strong>Header files</strong> : 在<code>include</code>文件夹中可以找到库的所有公开头文件。在该示例中，只有一个公开类所以文件夹中只有一个<code>ImageFilters.h</code>文件。稍后你会在你的应用工程中用到这个头文件以便于Xcode在编译期识别暴露的类。</li>
<li><strong>Binary Libraty</strong> : Xcode生成的静态库是<code>ImageFilters.a</code>。想在应用中使用该库，你需要用该文件链接。</li>
</ul>


<p>这两个部分和你想在应用里包含一些新的框架时所需要做的事很相似，简单的导入框架头文件并建立链接。</p>

<p>库已经准备就绪，需要附加说明的是，默认情况下，库文件只会为当前的架构构建。如果你在模拟器下构建，那么库会包含对应i386架构的结果代码；如果在真机设备下构建，你将会得到对应ARM架构的代码。你可能需要构建两个版本的库，并且当从模拟器切换到设备的时候选择其中一个使用。</p>

<p>怎么办？</p>

<p>幸运的是，有一个更好的办法可以不建立多个配置或在工程中构建产品就可以支持多个平台。你可以创建一个对应 <em>2个</em> 架构的包含结果代码的<code>universal binary</code>。</p>

<h2>通用二进制</h2>

<p>通用二进制是一种特殊的二进制文件，它包含对应多个架构的结果代码。你可能在从PowerPC(PPC)到Inter(i386)的Mac电脑产品线的过渡中对其有所熟悉。在这个过程中，Mac应用程序通常迁移为包含 <em>2个</em> 可执行包的一个二进制文件，这样应用程序即能在Inter也能在PowerPC的Mac电脑上运行。</p>

<p>同时支持ARM和i386的概念并没有太大不同。在这里静态库要包含支持iOS设备(ARM)和模拟器(i386)的结果代码。Xcode可以识别通用库，每次你构建应用的时候，它会根据目标选择适当的架构。</p>

<p>为了创建通用二进制库，需要使用一个名为<a href="https://developer.apple.com/library/mac/documentation/darwin/reference/manpages/man1/lipo.1.html">lipo</a>的系统工具。</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-05.jpg" title="Lipo Cat" alt="Lipo Cat" /></p>

<p>别担心宝贝，不是那种lipo! :] (lipo有脂肪的意思 &mdash; 译者注)</p>

<p><strong>lipo</strong>是一个命令行工具，它允许在通用文件上执行操作(类似于创建通用二进制, 列出通用文件内容等等)。本教程中使用<strong>lipo</strong>的目的是联合不同架构的二进制文件到单个输出文件中。你可以直接在命令行中使用<strong>lipo</strong>命令，但在本教程中你可以让Xcode执行一段创建通用库的命令行脚本来为你做这件事。</p>

<p>Xcode中一个集合目标可以一次构建多个目标，包括命令行脚本。在Xcode菜单中选择<code>File/New/Target</code>，选择<code>iOS/Other</code>并点击<code>Aggregate</code>，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-06.png" title="Aggregate Target" alt="Aggregate Target" /></p>

<p>将目标命名为<code>UniversalLib</code>，确保选中<code>ImageFilters</code>工程，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-07.png" title="Aggregate Universal" alt="Aggregate Universal" /></p>

<p>在工程导航视图中选中<code>ImageFilters</code>，然后选择<code>UniversalLib</code>目标。切换到<code>Build Phases</code>标签；在这里设置构建目标时将要执行的动作。</p>

<p>点击<code>Add Build Phase</code>按钮，在弹出的菜单中选择<code>Add Run Script</code>，如下图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-08.png" title="Aggregate Phase" alt="Aggregate Phase" /></p>

<p>现在你需要设置脚本项。展开<code>Run Script</code>模块，在<code>Shell</code>行下粘贴如下代码:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="c"># define output folder environment variable</span>
</span><span class='line'><span class="nv">UNIVERSAL_OUTPUTFOLDER</span><span class="o">=</span><span class="k">${</span><span class="nv">BUILD_DIR</span><span class="k">}</span>/<span class="k">${</span><span class="nv">CONFIGURATION</span><span class="k">}</span>-universal
</span><span class='line'>
</span><span class='line'><span class="c"># Step 1. Build Device and Simulator versions</span>
</span><span class='line'>xcodebuild -target ImageFilters <span class="nv">ONLY_ACTIVE_ARCH</span><span class="o">=</span>NO -configuration <span class="k">${</span><span class="nv">CONFIGURATION</span><span class="k">}</span> -sdk iphoneos  <span class="nv">BUILD_DIR</span><span class="o">=</span><span class="s2">&quot;${BUILD_DIR}&quot;</span> <span class="nv">BUILD_ROOT</span><span class="o">=</span><span class="s2">&quot;${BUILD_ROOT}&quot;</span>
</span><span class='line'>xcodebuild -target ImageFilters -configuration <span class="k">${</span><span class="nv">CONFIGURATION</span><span class="k">}</span> -sdk iphonesimulator -arch i386 <span class="nv">BUILD_DIR</span><span class="o">=</span><span class="s2">&quot;${BUILD_DIR}&quot;</span> <span class="nv">BUILD_ROOT</span><span class="o">=</span><span class="s2">&quot;${BUILD_ROOT}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># make sure the output directory exists</span>
</span><span class='line'>mkdir -p <span class="s2">&quot;${UNIVERSAL_OUTPUTFOLDER}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Step 2. Create universal binary file using lipo</span>
</span><span class='line'>lipo -create -output <span class="s2">&quot;${UNIVERSAL_OUTPUTFOLDER}/lib${PROJECT_NAME}.a&quot;</span> <span class="s2">&quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/lib${PROJECT_NAME}.a&quot;</span> <span class="s2">&quot;${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/lib${PROJECT_NAME}.a&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Last touch. copy the header files. Just for convenience</span>
</span><span class='line'>cp -R <span class="s2">&quot;${BUILD_DIR}/${CONFIGURATION}-iphoneos/include&quot;</span> <span class="s2">&quot;${UNIVERSAL_OUTPUTFOLDER}/&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码并不十分复杂，它是这样工作的:</p>

<ul>
<li><strong>UNIVERSAL_OUTPUTFOLDER</strong> 包括了通用二进制包将要被存放的文件夹:&ldquo;Debug-universal&rdquo;</li>
<li><strong>Step 1.</strong> 第2行执行了<code>xcodebuild</code>并命令它构建ARM架构的二进制文件。(你可以看到这行中的<code>-sdk iphoneos</code>参数)</li>
<li>下一行再次执行了<code>xcodebuild</code>命令并在另一个文件夹中构建了一个针对Inter架构的iPhone模拟器的二进制文件，在这里关键参数是<code>-sdk iphonesimulator -arch i386</code>。(如果感兴趣，你可以在<a href="http://developer.apple.com/documentation/Darwin/Reference/ManPages/man1/xcodebuild.1.html">man page</a>了解更多关于xcodebuild的资料)</li>
<li><strong>Step 2.</strong> 现在已经有了2个.a文件分别对应两个架构。执行<code>lipo -create</code>，用它们创建出一个通用二进制。</li>
<li>最后一行的作用是复制头文件到通用构建文件夹的外层。(用<code>cp</code>命令)</li>
</ul>


<p>你的Run Script窗口应该看起来如下:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-09.png" title="Aggregate Script" alt="Aggregate Script" /></p>

<p>现在你已经准备好构建一个静态库的通用版本。在方案下啦菜单中选择集合目标<code>UniversalLib</code>，如下(不像截图上的&#8221;iOS Device&#8221;，你看到的可能是自己的设备名字):</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-10.png" title="Aggregate Scheme" alt="Aggregate Scheme" /></p>

<p>点击<code>Play</code>按钮来为集合方案构建目标。</p>

<p>在<code>libImageFilters.a</code>上再次选择<code>Show in Finder</code>查看结果。将Finder切换到列视图查看文件夹层次，可以看到一个包含库的通用版本的叫做<code>Debug-Universal</code>的新文件夹(或<code>Release-Universal</code>如果你构建了发布版本)，如下图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-11.png" title="St Finder" alt="St Finder" /></p>

<p>除了这个链接到模拟器和真实设备的二进制文件，你还可以找到普通的头文件和静态库文件。</p>

<p>这是你创建自己的通用静态库所需要学习的所有知识。</p>

<p>概括起来，一个静态库工程和一个应用工程非常相似。可以拥有一个或多个类，最后的产品是头文件和一个.a文件。这个.a文件就是可以链接到多个应用程序中的静态库。</p>

<h2>在应用中使用静态库</h2>

<p>在应用中使用<code>ImageFilters</code>类和直接使用源代码并没有太大区别:导入头文件然后开始使用类。问题是Xcode并不知道头文件和库文件的位置。</p>

<p>有两种办法可以将静态库引入到工程中:</p>

<ul>
<li><strong>方法 1:</strong> 直接引用头文件和库二进制文件(.a)</li>
<li><strong>方法 2:</strong> 将库工程作为子项目</li>
</ul>


<p>选择哪一种方法完全取决于你的喜好或者是否有静态库的源代码和工程配置文件任由你支配。</p>

<p>本教程将分别介绍两种方法。你可以自由尝试第一个或第二个，但推荐按照文中介绍的顺序分别尝试两个。在两个部分的开头，需要一个zip文件，该文件是在<a href="http://www.raywenderlich.com/22167/beginning-core-image-in-ios-6">Core Image Tutorial</a>中创建的应用的修改版本，修改后的版本使用了库中新的<code>ImageFilters</code>类。</p>

<p>本教程的主要目的是教你如何使用静态库，所以修改后的工程包括了所有应用需要的源代码。这样你就可以将注意力集中在使用库所需要的工程设置上。</p>

<h2>方法 1: 头文件和库二进制文件</h2>

<p>在本节中，你需要下载<a href="http://cdn2.raywenderlich.com/wp-content/uploads/2013/07/CoreImageFun.staticlib.zip">starter project for this section</a>。复制压缩文件到硬盘上的任意文件夹并解压。可以看到如下的文件夹结构:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-12.png" title="Lib File Tree" alt="Lib File Tree" /></p>

<p>为了方便起见，.a通用库文件和头文件已经复制了一份在其中，但工程并未设置使用它们。你将从这里开始。</p>

<blockquote><p>注意: 标准的Unix引入惯例是一个<code>include</code>文件夹，用来存放头文件，一个<code>lib</code>文件夹用来存放库文件(.a)。这种文件夹结构这是一种惯例，并不强制。你并不需要一定遵从这种结构或者复制文件到工程文件夹中。在你自己的应用中，你可以任意选择头文件和库文件的位置，只要随后在Xcode工程中设置了适当的路径。</p></blockquote>

<p>打开工程，构建并运行你的应用，将会看到以下错误:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-13.png" title="Lib Error Include" alt="Lib Error Include" /></p>

<p>正如所期望的那样，应用并不知道去哪里寻找头文件。为了解决这个问题，你需要在工程中添加一个<code>Header Search Path</code>，指明头文件存放的位置。设置头文件搜索路径始终是使用静态库的第一步。</p>

<p>按照下图示范，在导航栏中点击工程根节点(1)，选择<code>CoreImageFun</code>目标(2)。选择<code>Build Settings</code>(3)，在列表中找出<code>Header Search Paths</code>设置项。如果必要，可以在搜索框中输入&#8221;header search&#8221;来过滤庞大的设置列表(4)。</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-14.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>双击<code>Header Search Paths</code>项，弹出一个浮动窗口，点击<code>+</code>按钮，输入:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$SOURCE_ROOT</span>/include
</span></code></pre></td></tr></table></div></figure>


<p>弹出窗口应该如下所示:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-15.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p><strong>$SOURCE_ROOT</strong>是一个Xcode环境变量，指向工程根文件夹。Xcode会使用包含你工程的实际文件夹代替此变量，这意味着即使你把工程移动到其它文件夹或驱动器，它仍然可以指向最新的位置。</p>

<p>在弹出窗口范围外点击鼠标使其消失，你会看到Xcode已经自动将变量转换为工程的实际位置，如图所示:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-16.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>构建并运行应用，看看结果是什么。呃……一些链接错误出现了:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-17.png" title="Lib Header Search" alt="Lib Header Search" /></p>

<p>这看起来并不是很好，但是给了你另一个你所需要的信息。仔细看，会发现所有的编译错误全都消失了，全部被链接错误所代替。这表示Xcode找到了头文件并且用它去编译应用，但在链接阶段，Xcode无法找到<code>ImageFilter</code>类的结果代码。为什么？</p>

<p>很简单 &mdash; 你还没有告诉Xcode去哪里寻找包含类实现的库文件。(看，没什么大不了)</p>

<p>如下面的屏幕截图所示，回到<code>CoreImageFun</code>目标(2)的构建设置(1)。选择<code>Build Phases</code>标签(3)，展开<code>Link Binary With Libraries</code>部分(4)。最后，点击<code>+</code>按钮(5)。</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-18.png" title="Lib Link" alt="Lib Link" /></p>

<p>在出现的窗口中，点击<code>Add Other…</code>按钮，在工程根文件夹下的<code>lib</code>子目录中找到<code>libImageFilters.a</code>库文件，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-19.png" title="Lib Link" alt="Lib Link" /></p>

<p>完成这些以后，你的Build Phase标签看起来如下:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-20.png" title="Lib Link" alt="Lib Link" /></p>

<p>最后一步是增加<code>-ObjC</code>链接标识。该链接尝试更高效的只包含需要的代码，而有时会排除静态库代码。使用该标识，库中的所有Objective-C类和类别都将被适当的加载。你可以从苹果的<a href="http://developer.apple.com/library/mac/#qa/qa1490/_index.html">Technical Q&amp;A QA1490</a>了解详细信息。</p>

<p>点击<code>Build Settings</code>标签，找到<code>Other linker Flags</code>设置，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-21.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>在弹出窗口中，点击<code>+</code>按钮并输入<code>-ObjC</code>，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-22.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>最后构建并运行应用，此时应该不会得到任何构建错误信息，应用顺利展示它的光彩之处:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-23.png" title="App" alt="App" /></p>

<p>拖动滑块改变滤镜级别，或者点击GrayScale按钮。对图片应用滤镜的代码来自于静态库，而不是应用。</p>

<p>恭喜 &mdash; 你已经构建了你的第一个静态库并在一个真正的应用里使用它!你会发现这种包含头文件和库的方法在很多第三方库中使用，如AdMob，TestFlight或一些不提供源代码的商业库。</p>

<h2>方法 2: 子项目</h2>

<p>在这部分，请在<a href="http://cdn1.raywenderlich.com/wp-content/uploads/2013/07/CoreImageFun.subproject.zip">这里</a>下载所需工程。</p>

<p>复制下载的文件到任意位置，解压。可以看到以下文件夹结构:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-24.png" title="Subproject Structure" alt="Subproject Structure" /></p>

<p>如果学习了方法一，你可能注意到了工程的差异。这个工程里没有任何的头文件和静态库文件 &mdash; 因为根本不需要。作为替代方案，你要将你在本教程开始创建的<code>ImageFilters</code>库工程添作为依赖加到本工程中。</p>

<p>在做这些之前，构建并运行应用。会看到以下错误:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-25.png" title="Lib Error Include" alt="Lib Error Include" /></p>

<p>如果学习过上一个方法，你已经知道如何修复这个问题。在示例工程中，你在<code>ViewController</code>类中使用了<code>ImageFilters</code>类，但并未告诉Xcode去哪里寻找头文件。Xcode会尝试寻找<code>ImageFilters.h</code>文件，但是失败了。</p>

<p>将<code>ImageFilters</code>库工程作为子项目所需的所有操作就是拖拽库工程文件到库文件树中。如果该工程已经在另一个Xcode窗口中被打开，那么Xcode无法正确将其添加为子工程。所以在继续本教程之前，确保<code>ImageFilters</code>库工程已经被关闭。</p>

<p>在Finder中找到名为<code>ImageFilters.xcodeproj</code>库工程文件。拖拽它到<code>CoreImageFun</code>工程左侧的导航栏中，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-26.png" title="Subproject Drag" alt="Subproject Drag" /></p>

<p>完成拖放后，你的工程浏览视图应该如下图所示:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-27.png" title="Subproject Drag" alt="Subproject Drag" /></p>

<p>现在Xcode已经识别了子工程，你可以将库添加为工程依赖。这样Xcode就可以在构建主应用之前确保库为最新版本。</p>

<p>点击工程文件(1)，选择<code>CoreImageFun</code>目标(2)。点击<code>Build Phases</code>标签(3)并展开<code>Target Dependencies</code>(4)，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-28.png" title="Dependencies" alt="Dependencies" /></p>

<p>点击<code>+</code>按钮增加一个新依赖。如下图所示，确保你从弹出窗口中选择了<code>ImageFilters</code>目标(不是<code>universalLib</code>):</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-29.png" title="Dependency" alt="Dependency" /></p>

<p>添加完成之后，依赖窗口应该如图所示:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-30.png" title="Dependency" alt="Dependency" /></p>

<p>最后，设置静态库工程链接到应用。展开<code>Link Binary with libraries</code>，点击<code>+</code>按钮，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-31.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>选择<code>libImageFilters.a</code>，点击<code>Add</code>:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-32.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>添加库之后，<code>Link Binary with Libraries</code>部分应该如图所示:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-33.png" title="Subproject Link" alt="Subproject Link" /></p>

<p>像方法一那样，最后一步是增加<code>-ObjC</code>链接标识。点击<code>Build Settings</code>标签，找到<code>Other linker Flags</code>设置，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-34.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>在弹出窗口中，点击<code>+</code>按钮并输入<code>-ObjC</code>，如图:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-35.png" title="OBJC Flag" alt="OBJC Flag" /></p>

<p>构建并运行应用，应该没有任何错误，应用会再一次被打开:</p>

<p><img src="http://objcio.com/images/posts/2013-11-30-creating-a-static-library-in-ios-tutorial-36.png" title="App" alt="App" /></p>

<p>拖动滑块或者点击GrayScale按钮查看图片滤镜结果。滤镜逻辑的代码完全包含在库中。</p>

<p>如果按照第一种方法在应用中添加库(使用头文件和库文件)，你可能注意到和第二种方法的区别。在方法二中，你没有在工程设置中添加任何头文件搜索路径。另一个区别是你没有使用通用库。</p>

<p>为什么会有这样的区别？当添加一个库作为一个子工程，Xcode会为你考虑几乎所有的事情。添加子工程和依赖后，Xcode知道去哪里寻找头文件和二进制文件，也知道根据你的设置去选择哪需要构建哪一个架构的库。这非常方便。</p>

<p>如果你使用你自己的库或者拥有源代码和工程文件，将库作为子工程不失为一个引入静态库的简便的方法。让你更容易作为工程依赖构建整合，并担心更少的事情。</p>

<h2>未来</h2>

<p>你可以从<a href="http://cdn5.raywenderlich.com/wp-content/uploads/2013/07/Staticlibrary.fullsource.zip">这里</a>下载到包括了本教程所有代码的工程。</p>

<p>希望本教程能够让你对静态库的基本概念和怎样在应用中使用它们有一个更深入的了解。</p>

<p>下一步就是用所学到的知识构建你自己的库了。你肯定有一些添加到工程中通用类。它们是你加入你自己的可复用库的优秀候选人。你也可以考虑根据功能创建多个库:网络部分的代码作为一个，UI部分作为另一个，等等。你可以只向工程中添加所需要的代码。</p>

<p>为了强化和深入探讨你在本教程中所学到的概念，我推荐苹果的文档<a href="http://developer.apple.com/library/ios/#technotes/iOSStaticLibraries/Introduction.html">Introduction to Using Static Libraries in iOS</a>。</p>

<p>希望你喜欢本教程，如果你有任何问题或评论，请在下面的讨论区中讨论。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[你好, Octopress]]></title>
    <link href="http://objcio.com/blog/2013/09/15/hello-octopress/"/>
    <updated>2013-09-15T15:27:00+08:00</updated>
    <id>http://objcio.com/blog/2013/09/15/hello-octopress</id>
    <content type="html"><![CDATA[<p>一直想搭建一个以技术为主的个人博客，可现有的博客平台要么太丑，要么功能满足不了需求。Woredpress？对于我它显得太过繁琐笨重。不过幸好这世界上有无所不能的Github和令人爱不释手的Octopress。</p>

<p>Octopress搭建起来很傻瓜化，官方文档写的很详细。网上也有大量的教程和资料可参考。本文介绍一下我在Github上搭建Octopress以及使用其过程中所借鉴的一些资料。</p>

<!--more-->


<h2>安装及配置</h2>

<p>Octopress的安装还是很简单的，基本上跟着教程一步一步走下来就可以了。这个步骤主要参考了:</p>

<ul>
<li><a href="http://beyondvincent.com/blog/2013/08/03/108-creating-a-github-blog-using-octopress/">利用Octopress搭建一个Github博客</a></li>
<li><a href="http://beyondvincent.com/blog/2013/07/27/107-hello-page-of-github/">你好！github页面</a></li>
</ul>


<h2>主题</h2>

<p>Octopress默认的主题简洁明快，基本可以满足需求，网上很多使用者都使用该主题。但看的多了难免会审美疲劳，觉得不够漂亮。已经有一些开发者为Octopress提供了一定数量的主题，使用者可以在其中自由选择。虽然数量远不如Wordpress庞大，但相信会有越来越多的人加入到其中。以下两个地址集合了一些Octopress主题，安装也很简单。本博客截至到此文发表时所使用的主题是 <a href="https://github.com/shashankmehta/greyshade"><code>greyshade</code></a>:</p>

<ul>
<li><a href="http://opthemes.com/">Octopress Themes</a></li>
<li><a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">3rd Party Octopress Themes</a></li>
</ul>


<h2>Markdown</h2>

<p>在Octopress上写博客用的是 <a href="http://zh.wikipedia.org/wiki/Markdown"><strong>Markdown</strong></a>。虽然Markdown已经足够轻巧，但是对于接触比较少的使用者来说，想达到纯熟使用的境界还是需要一些时间。在使用过程中除了标准Markdown，Github和Octopress还支持一些额外的语法。以下给出文档地址:</p>

<ul>
<li><a href="http://wowubuntu.com/markdown/">Markdown 语法说明 (简体中文版)</a></li>
<li><a href="https://help.github.com/articles/github-flavored-markdown">GitHub Flavored Markdown</a></li>
<li><a href="http://octopress.org/docs/blogging/plugins/">Plugins</a></li>
</ul>


<p>我在Mac平台下使用的Markdown编辑器是 <a href="http://mouapp.com/">Mou</a>，很好用。</p>

<h2>总结</h2>

<p>基本上有了以上介绍的资料作为参考，就可以顺利的搭建起一个属于自己的博客了。</p>
]]></content>
  </entry>
  
</feed>
